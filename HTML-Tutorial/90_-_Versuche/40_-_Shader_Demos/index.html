<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>40 - Shader Demos</title>
    <style>
      pre {background-color:#BBBBFF; color:#000000; font-family: Fixedsys,Courier,monospace; padding:10px;}
    </style>
  </head>
  <body bgcolor="#DDDDFF">
    <b><h1>90 - Versuche</h1></b>
    <b><h2>40 - Shader Demos</h2></b>
<img src="image.png" alt="Selfhtml"><br><br>
Zum Schluss eine kleine Spielerei: Hier wird ein Mandelbrot im Shader (also auf der GPU) berechnet.<br>
Mit der CPU hatte ich noch keine so schnelle Berechnung hingekriegt, trotz Assembler.<br>
<br>
Anmerkung: Bei diesem Beispiel geht es nicht um mathematische Hintegr端nde, sondern es soll legentlich demonstrieren, das man mit Shader-Programs sehr komplexe Berechnungen machen kann.<br>
<br>
Der Lazarus-Code ist nichts besonderes, es wird nur ein Rechteck gerendert und anschliessend mit einer Matrix gedreht. Was eine Matrix ist, wird im Kapitel Matrix beschrieben.<br>
<b>Achtung:</b> Eine lahme Grafikkarte kann bei Vollbild ins Stockern kommen.<br>
Zur Beschleunigung kann der Wert <b>#define depth 1000.0</b> im Fragment-Shader verkleinert werden.<br>
<hr><br>
<b>Vertex-Shader:</b><br>
<pre><code><b><font color="#008800">#version</font></b> <font color="#0077BB">330</font>

<b><font color="0000BB">layout</font></b> (location = <font color="#0077BB">10</font>) <b><font color="0000BB">in</font></b> <b><font color="0000BB">vec3</font></b> inPos;   <i><font color="#FFFF00">// Vertex-Koordinaten</font></i>

<b><font color="0000BB">out</font></b> <b><font color="0000BB">vec2</font></b> pos;                           <i><font color="#FFFF00">// Koordinaten f端r den Fragment-Shader</font></i>

<b><font color="0000BB">void</font></b> main(<b><font color="0000BB">void</font></b>) {
  gl_Position = <b><font color="0000BB">vec4</font></b>(inPos, <font color="#0077BB">1</font>.<font color="#0077BB">0</font>);
  pos = gl_Position.xy;                 <i><font color="#FFFF00">// XY an Fragment-Shader</font></i>
}
</pre></code>
<hr><br>
<b>Fragment-Shader:</b><br>
<br>
Hier steckt die ganze Berechnung f端r das Mandelbrot.<br>
<pre><code><b><font color="#008800">#version</font></b> <font color="#0077BB">330</font>

<b><font color="0000BB">uniform</font></b> <b><font color="0000BB">vec2</font></b> iResolution;
<b><font color="0000BB">uniform</font></b> <b><font color="0000BB">float</font></b> iTime;
<b><font color="0000BB">uniform</font></b> <b><font color="0000BB">float</font></b> iFrame = <font color="#0077BB">30</font>.<font color="#0077BB">0</font>;
<b><font color="0000BB">uniform</font></b> <b><font color="0000BB">vec3</font></b> iMouse = <b><font color="0000BB">vec3</font></b>(<font color="#0077BB">100</font>.<font color="#0077BB">0</font>, <font color="#0077BB">100</font>.<font color="#0077BB">0</font>, <font color="#0077BB">0</font>.<font color="#0077BB">0</font>);

<b><font color="0000BB">in</font></b> <b><font color="0000BB">vec2</font></b> pos;                           <i><font color="#FFFF00">// Koordinaten f端r den Fragment-Shader</font></i>
<b><font color="0000BB">out</font></b> <b><font color="0000BB">vec4</font></b> fragColor;


<b><font color="0000BB">vec3</font></b> zset( <b><font color="0000BB">vec3</font></b> p, <b><font color="0000BB">float</font></b> v ) {
  <b><font color="0000BB">return</font></b> <b><font color="0000BB">vec3</font></b>( p.x, p.y, v );
}
<b><font color="0000BB">float</font></b> saturate( <b><font color="0000BB">float</font></b> x ) {
  <b><font color="0000BB">return</font></b> clamp( x, <b><font color="0000BB">float</font></b>(<font color="#0077BB">0</font>.<font color="#0077BB">0</font>), <b><font color="0000BB">float</font></b>(<font color="#0077BB">1</font>.<font color="#0077BB">0</font>) );
}
<b><font color="0000BB">vec4</font></b> saturate( <b><font color="0000BB">vec4</font></b> x ) {
  <b><font color="0000BB">return</font></b> clamp( x, <b><font color="0000BB">vec4</font></b>(<font color="#0077BB">0</font>.<font color="#0077BB">0</font>), <b><font color="0000BB">vec4</font></b>(<font color="#0077BB">1</font>.<font color="#0077BB">0</font>) );
}
<b><font color="0000BB">float</font></b> exp_decay( <b><font color="0000BB">float</font></b> x ) {
  <b><font color="0000BB">return</font></b> <font color="#0077BB">1</font>. - exp( -x );
}
<i><font color="#FFFF00">// for rcp_decay, max x with something < 0 to prevent infinity and cull the other side</font></i>
<b><font color="0000BB">float</font></b> rcp_decay( <b><font color="0000BB">float</font></b> x ) {
  <b><font color="0000BB">return</font></b> x / ( <font color="#0077BB">1</font>. + x );
}
<b><font color="0000BB">float</font></b> smoothstep_unchecked( <b><font color="0000BB">float</font></b> x ) {
  <b><font color="0000BB">return</font></b> ( x * x ) * ( <font color="#0077BB">3</font>.<font color="#0077BB">0</font> - x * <font color="#0077BB">2</font>.<font color="#0077BB">0</font> );
}
<b><font color="0000BB">float</font></b> linearstep( <b><font color="0000BB">float</font></b> a, <b><font color="0000BB">float</font></b> b, <b><font color="0000BB">float</font></b> x ) {
  <b><font color="0000BB">return</font></b> saturate( ( x - a ) / ( b - a ) );
}
<b><font color="0000BB">float</font></b> exp_bell( <b><font color="0000BB">float</font></b> x, <b><font color="0000BB">float</font></b> r ) {
  x *= ( <font color="#0077BB">1</font>. / r );
  <b><font color="0000BB">return</font></b> exp( -x * x );
}
<b><font color="0000BB">float</font></b> smoothbump( <b><font color="0000BB">float</font></b> a, <b><font color="0000BB">float</font></b> r, <b><font color="0000BB">float</font></b> x ) {
  <b><font color="0000BB">return</font></b> <font color="#0077BB">1</font>.<font color="#0077BB">0</font> - smoothstep_unchecked( min( abs( x - a ), r ) / r );
}
<b><font color="0000BB">float</font></b> smoothbump( <b><font color="0000BB">float</font></b> x, <b><font color="0000BB">float</font></b> s1, <b><font color="0000BB">float</font></b> e1, <b><font color="0000BB">float</font></b> s2, <b><font color="0000BB">float</font></b> e2 ) {
  <b><font color="0000BB">return</font></b> smoothstep( s1, e1, x ) * smoothstep( e2, s2, x );
}
<b><font color="0000BB">float</font></b> cosbump( <b><font color="0000BB">float</font></b> x, <b><font color="0000BB">float</font></b> x0, <b><font color="0000BB">float</font></b> r ) {
  <b><font color="0000BB">return</font></b> ( <font color="#0077BB">1</font>. + cos( min( abs( ( x - x0 ) / r ), <font color="#0077BB">1</font>. ) * <font color="#0077BB">3</font>.<font color="#0077BB">141592654</font> ) ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>;
}
<i><font color="#FFFF00">// like smoothstep, but takes a center and a radius instead</font></i>
<b><font color="0000BB">float</font></b> smoothstep_c( <b><font color="0000BB">float</font></b> x, <b><font color="0000BB">float</font></b> c, <b><font color="0000BB">float</font></b> r ) {
  <b><font color="0000BB">return</font></b> smoothstep( c - r, c + r, x );
}
<i><font color="#FFFF00">// band, centered at 0... like smoothstep_c but different semantics</font></i>
<b><font color="0000BB">float</font></b> band( <b><font color="0000BB">float</font></b> x, <b><font color="0000BB">float</font></b> r, <b><font color="0000BB">float</font></b> raa ) {
  <b><font color="0000BB">return</font></b> <font color="#0077BB">1</font>. - smoothstep_c( abs( x ), r, raa );
}
<i><font color="#FFFF00">// range start,end</font></i>
<b><font color="0000BB">float</font></b> band( <b><font color="0000BB">float</font></b> x, <b><font color="0000BB">float</font></b> s, <b><font color="0000BB">float</font></b> e, <b><font color="0000BB">float</font></b> raa ) {
  <b><font color="0000BB">return</font></b> band( x - ( e + s ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>, ( e - s ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>, raa );
}
<b><font color="0000BB">vec2</font></b> perp( <b><font color="0000BB">vec2</font></b> v ) {
  <b><font color="0000BB">return</font></b> <b><font color="0000BB">vec2</font></b>( -v.y, v.x );
}
<i><font color="#FFFF00">// return range -pi,pi</font></i>
<b><font color="0000BB">float</font></b> calc_angle( <b><font color="0000BB">vec2</font></b> v ) {
  <b><font color="0000BB">return</font></b> atan( v.y, v.x );
}
<b><font color="0000BB">float</font></b> calc_angle( <b><font color="0000BB">vec2</font></b> a, <b><font color="0000BB">vec2</font></b> b ) {
  <b><font color="0000BB">return</font></b> calc_angle( <b><font color="0000BB">vec2</font></b>( dot( a, b ), dot( perp( a ), b ) ) );
}
<b><font color="0000BB">vec3</font></b> contrast( <b><font color="0000BB">vec3</font></b> x, <b><font color="0000BB">vec3</font></b> s ) {
  <b><font color="0000BB">return</font></b> ( x - <font color="#0077BB">0</font>.<font color="#0077BB">5</font> ) * s + <font color="#0077BB">0</font>.<font color="#0077BB">5</font>;
}
<b><font color="0000BB">float</font></b> pow2( <b><font color="0000BB">float</font></b> x ) {
  <b><font color="0000BB">return</font></b> x * x;
}
<b><font color="0000BB">vec3</font></b> pow2( <b><font color="0000BB">vec3</font></b> x ) {
  <b><font color="0000BB">return</font></b> x * x;
}
<b><font color="0000BB">vec4</font></b> pow2( <b><font color="0000BB">vec4</font></b> x ) {
  <b><font color="0000BB">return</font></b> x * x;
}
<b><font color="0000BB">float</font></b> pow5( <b><font color="0000BB">float</font></b> x ) {
  <b><font color="0000BB">float</font></b> x2 = x * x;
  <b><font color="0000BB">return</font></b> x2 * x2 * x;
}
<i><font color="#FFFF00">// in soft min don't go too crazy with small values of k</font></i>
<i><font color="#FFFF00">// those are not real min/max (returned values can exceed input values)</font></i>
<b><font color="0000BB">float</font></b> soft_min2( <b><font color="0000BB">float</font></b> a, <b><font color="0000BB">float</font></b> b, <b><font color="0000BB">float</font></b> k ) {
  <b><font color="0000BB">return</font></b> -log2( exp2( -k * a ) + exp2( -k * b ) ) / k;
}
<b><font color="0000BB">float</font></b> soft_max2( <b><font color="0000BB">float</font></b> a, <b><font color="0000BB">float</font></b> b, <b><font color="0000BB">float</font></b> k ) {
  <b><font color="0000BB">return</font></b> -soft_min2( -a, -b, k );
}
<b><font color="0000BB">float</font></b> powerful_scurve( <b><font color="0000BB">float</font></b> x, <b><font color="0000BB">float</font></b> p1, <b><font color="0000BB">float</font></b> p2 ) {
  <b><font color="0000BB">return</font></b> pow( <font color="#0077BB">1</font>.<font color="#0077BB">0</font> - pow( <font color="#0077BB">1</font>.<font color="#0077BB">0</font> - clamp( x, <font color="#0077BB">0</font>.<font color="#0077BB">0</font>, <font color="#0077BB">1</font>.<font color="#0077BB">0</font> ), p2 ), p1 );
}
<b><font color="0000BB">float</font></b> maxcomp( <b><font color="0000BB">float</font></b> x ) {
  <b><font color="0000BB">return</font></b> x;
}
<b><font color="0000BB">float</font></b> maxcomp( <b><font color="0000BB">vec2</font></b> v ) {
  <b><font color="0000BB">return</font></b> max( v.x, v.y );
}
<b><font color="0000BB">float</font></b> maxcomp( <b><font color="0000BB">vec3</font></b> v ) {
  <b><font color="0000BB">return</font></b> max( max( v.x, v.y ), v.z );
}
<b><font color="0000BB">float</font></b> mincomp( <b><font color="0000BB">float</font></b> x ) {
  <b><font color="0000BB">return</font></b> x;
}
<b><font color="0000BB">float</font></b> mincomp( <b><font color="0000BB">vec2</font></b> v ) {
  <b><font color="0000BB">return</font></b> min( v.x, v.y );
}
<b><font color="0000BB">float</font></b> mincomp( <b><font color="0000BB">vec3</font></b> v ) {
  <b><font color="0000BB">return</font></b> min( min( v.x, v.y ), v.z );
}
<b><font color="0000BB">vec3</font></b> luminance( <b><font color="0000BB">vec3</font></b> c ) {
  <b><font color="0000BB">return</font></b> <b><font color="0000BB">vec3</font></b>( dot( <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">2989</font>, <font color="#0077BB">0</font>.<font color="#0077BB">5866</font>, <font color="#0077BB">0</font>.<font color="#0077BB">1145</font> ), c ) );
}
<b><font color="0000BB">float</font></b> sum( <b><font color="0000BB">vec3</font></b> v ) {
  <b><font color="0000BB">return</font></b> v.x + v.y + v.z;
}
<i><font color="#FFFF00">// symmetrize/mirror x around a</font></i>
<b><font color="0000BB">float</font></b> fold( <b><font color="0000BB">float</font></b> x, <b><font color="0000BB">float</font></b> a ) {
  <b><font color="0000BB">return</font></b> x + <font color="#0077BB">2</font>. * min( <font color="#0077BB">0</font>., a - x );
}
<b><font color="0000BB">vec2</font></b> fold( <b><font color="0000BB">vec2</font></b> p, <b><font color="0000BB">vec2</font></b> o, <b><font color="0000BB">vec2</font></b> n ) {
  <b><font color="0000BB">float</font></b> a = dot( p - o, n );
  <b><font color="0000BB">return</font></b> p - <font color="#0077BB">2</font>. * min( a, <font color="#0077BB">0</font>. ) * n;
}
<i><font color="#FFFF00">// acos overflow bugs (subtle ot not) are the worse</font></i>
<b><font color="0000BB">float</font></b> safe_acos( <b><font color="0000BB">float</font></b> x ) {
  <b><font color="0000BB">return</font></b> acos( clamp( x, -<font color="#0077BB">1</font>., <font color="#0077BB">1</font>. ) );
}
<b><font color="0000BB">vec4</font></b> safe_acos( <b><font color="0000BB">vec4</font></b> x ) {
  <b><font color="0000BB">return</font></b> acos( clamp( x, <b><font color="0000BB">vec4</font></b>(-<font color="#0077BB">1</font>.), <b><font color="0000BB">vec4</font></b>(<font color="#0077BB">1</font>.) ) );
}
<i><font color="#FFFF00">// http://iquilezles.org/www/articles/smin/smin.htm</font></i>
<i><font color="#FFFF00">// polynomial smooth min (k = 0.1);</font></i>
<b><font color="0000BB">float</font></b> smin_pol( <b><font color="0000BB">float</font></b> a, <b><font color="0000BB">float</font></b> b, <b><font color="0000BB">float</font></b> k )
{
  <b><font color="0000BB">float</font></b> h = clamp( <font color="#0077BB">0</font>.<font color="#0077BB">5</font> + <font color="#0077BB">0</font>.<font color="#0077BB">5</font> * ( b - a ) / k, <font color="#0077BB">0</font>.<font color="#0077BB">0</font>, <font color="#0077BB">1</font>.<font color="#0077BB">0</font> );
  <b><font color="0000BB">return</font></b> mix( b, a, h ) - k * h * ( <font color="#0077BB">1</font>.<font color="#0077BB">0</font> - h );
}
<i><font color="#FFFF00">// https://mynameismjp.wordpress.com/2016/10/09/sg-series-part-2-spherical-gaussians-101/</font></i>
<i><font color="#FFFF00">// v is the eval direction, v and axis assumed normalized and cos_v_axis = dot(v,axis)</font></i>
<b><font color="0000BB">float</font></b> spherical_gaussian( <b><font color="0000BB">float</font></b> cos_v_axis, <b><font color="0000BB">float</font></b> amplitude, <b><font color="0000BB">float</font></b> sharpness ) {
  <b><font color="0000BB">return</font></b> amplitude * exp( ( cos_v_axis - <font color="#0077BB">1</font>. ) * sharpness );
}
<b><font color="0000BB">vec3</font></b> spherical_gaussian( <b><font color="0000BB">float</font></b> cos_v_axis, <b><font color="0000BB">vec3</font></b> amplitude, <b><font color="0000BB">vec3</font></b> sharpness ) {
  <b><font color="0000BB">return</font></b> amplitude * exp( ( cos_v_axis - <font color="#0077BB">1</font>. ) * sharpness );
}
<b><font color="0000BB">vec3</font></b> spherical_gaussian( <b><font color="0000BB">float</font></b> cos_v_axis, <b><font color="0000BB">vec3</font></b> amplitude, <b><font color="0000BB">float</font></b> sharpness ) {
  <b><font color="0000BB">return</font></b> amplitude * exp( ( cos_v_axis - <font color="#0077BB">1</font>. ) * sharpness );
}
<i><font color="#FFFF00">// http://www.iquilezles.org/www/articles/functions/functions.htm</font></i>
<b><font color="0000BB">float</font></b> impulse( <b><font color="0000BB">float</font></b> a, <b><font color="0000BB">float</font></b> x ) {
  <b><font color="0000BB">float</font></b> ax = a * x;
  <b><font color="0000BB">return</font></b> ax * exp( <font color="#0077BB">1</font>. - ax );
}
<b><font color="0000BB">vec2</font></b> impulse( <b><font color="0000BB">vec2</font></b> a, <b><font color="0000BB">vec2</font></b> x ) {
  <b><font color="0000BB">vec2</font></b> ax = a * x;
  <b><font color="0000BB">return</font></b> ax * exp( <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">1</font>. ) - ax );
}
<b><font color="0000BB">float</font></b> biexp2( <b><font color="0000BB">float</font></b> x, <b><font color="0000BB">float</font></b> a, <b><font color="0000BB">float</font></b> b ) {
  <b><font color="0000BB">return</font></b> ( ( a * b ) / ( a - b ) ) * ( exp2( -b * x ) - exp2( -a * x ) );
}
<b><font color="0000BB">vec3</font></b> biexp2( <b><font color="0000BB">vec3</font></b> x, <b><font color="0000BB">vec3</font></b> a, <b><font color="0000BB">vec3</font></b> b ) {
  <b><font color="0000BB">return</font></b> ( ( a * b ) / ( a - b ) ) * ( exp2( -b * x ) - exp2( -a * x ) );
}
<i><font color="#FFFF00">//https://www.shadertoy.com/view/MsS3Wc</font></i>
<b><font color="0000BB">vec3</font></b> hsv2rgb( <b><font color="0000BB">in</font></b> <b><font color="0000BB">vec3</font></b> c )
{
  <b><font color="0000BB">vec3</font></b> rgb = clamp( abs( mod( c.x * <font color="#0077BB">6</font>.<font color="#0077BB">0</font> + <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">0</font>, <font color="#0077BB">4</font>.<font color="#0077BB">0</font>, <font color="#0077BB">2</font>.<font color="#0077BB">0</font> ), <font color="#0077BB">6</font>.<font color="#0077BB">0</font> ) - <font color="#0077BB">3</font>.<font color="#0077BB">0</font> ) - <font color="#0077BB">1</font>.<font color="#0077BB">0</font>, <font color="#0077BB">0</font>.<font color="#0077BB">0</font>, <font color="#0077BB">1</font>.<font color="#0077BB">0</font> );
  <b><font color="0000BB">return</font></b> c.z * mix( <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">1</font>.<font color="#0077BB">0</font> ), rgb, c.y );
}
<b><font color="0000BB">struct</font></b> bounds1 {
  <b><font color="0000BB">float</font></b> pmin;
  <b><font color="0000BB">float</font></b> pmax;
}; bounds1 mkbounds_unchecked( <b><font color="0000BB">float</font></b> amin, <b><font color="0000BB">float</font></b> amax ) {
  bounds1 ret;
  ret.pmin = amin;
  ret.pmax = amax;
  <b><font color="0000BB">return</font></b> ret;
} <b><font color="0000BB">float</font></b> size( bounds1 b ) {
  <b><font color="0000BB">return</font></b> b.pmax - b.pmin;
} <b><font color="0000BB">float</font></b> center( bounds1 b ) {
  <b><font color="0000BB">return</font></b> <font color="#0077BB">0</font>.<font color="#0077BB">5</font> * ( b.pmax + b.pmin );
} /* grid multiplier range */ /* bounds b is cell "<font color="#0077BB">0</font>,<font color="#0077BB">0</font>" */ /* min_xs is pmin offset (<b><font color="0000BB">in</font></b> multiples of bounds size) */ /* max_xs is pmax offset (<b><font color="0000BB">in</font></b> multiples of bounds size) */ bounds1 mkbounds_unchecked_gx( bounds1 b, <b><font color="0000BB">float</font></b> min_xs, <b><font color="0000BB">float</font></b> max_xs ) {
  <b><font color="0000BB">float</font></b> s = size( b );
  bounds1 ret = b;
  ret.pmin += s * min_xs;
  ret.pmax += s * max_xs;
  <b><font color="0000BB">return</font></b> ret;
}
<b><font color="0000BB">struct</font></b> bounds2 {
  <b><font color="0000BB">vec2</font></b> pmin;
  <b><font color="0000BB">vec2</font></b> pmax;
}; bounds2 mkbounds_unchecked( <b><font color="0000BB">vec2</font></b> amin, <b><font color="0000BB">vec2</font></b> amax ) {
  bounds2 ret;
  ret.pmin = amin;
  ret.pmax = amax;
  <b><font color="0000BB">return</font></b> ret;
} <b><font color="0000BB">vec2</font></b> size( bounds2 b ) {
  <b><font color="0000BB">return</font></b> b.pmax - b.pmin;
} <b><font color="0000BB">vec2</font></b> center( bounds2 b ) {
  <b><font color="0000BB">return</font></b> <font color="#0077BB">0</font>.<font color="#0077BB">5</font> * ( b.pmax + b.pmin );
} /* grid multiplier range */ /* bounds b is cell "<font color="#0077BB">0</font>,<font color="#0077BB">0</font>" */ /* min_xs is pmin offset (<b><font color="0000BB">in</font></b> multiples of bounds size) */ /* max_xs is pmax offset (<b><font color="0000BB">in</font></b> multiples of bounds size) */ bounds2 mkbounds_unchecked_gx( bounds2 b, <b><font color="0000BB">vec2</font></b> min_xs, <b><font color="0000BB">vec2</font></b> max_xs ) {
  <b><font color="0000BB">vec2</font></b> s = size( b );
  bounds2 ret = b;
  ret.pmin += s * min_xs;
  ret.pmax += s * max_xs;
  <b><font color="0000BB">return</font></b> ret;
}
<b><font color="0000BB">struct</font></b> bounds3 {
  <b><font color="0000BB">vec3</font></b> pmin;
  <b><font color="0000BB">vec3</font></b> pmax;
}; bounds3 mkbounds_unchecked( <b><font color="0000BB">vec3</font></b> amin, <b><font color="0000BB">vec3</font></b> amax ) {
  bounds3 ret;
  ret.pmin = amin;
  ret.pmax = amax;
  <b><font color="0000BB">return</font></b> ret;
} <b><font color="0000BB">vec3</font></b> size( bounds3 b ) {
  <b><font color="0000BB">return</font></b> b.pmax - b.pmin;
} <b><font color="0000BB">vec3</font></b> center( bounds3 b ) {
  <b><font color="0000BB">return</font></b> <font color="#0077BB">0</font>.<font color="#0077BB">5</font> * ( b.pmax + b.pmin );
} /* grid multiplier range */ /* bounds b is cell "<font color="#0077BB">0</font>,<font color="#0077BB">0</font>" */ /* min_xs is pmin offset (<b><font color="0000BB">in</font></b> multiples of bounds size) */ /* max_xs is pmax offset (<b><font color="0000BB">in</font></b> multiples of bounds size) */ bounds3 mkbounds_unchecked_gx( bounds3 b, <b><font color="0000BB">vec3</font></b> min_xs, <b><font color="0000BB">vec3</font></b> max_xs ) {
  <b><font color="0000BB">vec3</font></b> s = size( b );
  bounds3 ret = b;
  ret.pmin += s * min_xs;
  ret.pmax += s * max_xs;
  <b><font color="0000BB">return</font></b> ret;
}
<b><font color="0000BB">float</font></b> repeat( <b><font color="0000BB">float</font></b> x, <b><font color="0000BB">float</font></b> len ) {
  <b><font color="0000BB">return</font></b> len * fract( x * ( <b><font color="0000BB">float</font></b>( <font color="#0077BB">1</font>.<font color="#0077BB">0</font> ) / len ) );
} <b><font color="0000BB">float</font></b> repeat_mirror( <b><font color="0000BB">float</font></b> x, <b><font color="0000BB">float</font></b> len ) {
  <b><font color="0000BB">return</font></b> len * abs( <b><font color="0000BB">float</font></b>( -<font color="#0077BB">1</font>.<font color="#0077BB">0</font> ) + <font color="#0077BB">2</font>.<font color="#0077BB">0</font> * fract( ( ( x * ( <b><font color="0000BB">float</font></b>( <font color="#0077BB">1</font>.<font color="#0077BB">0</font> ) / len ) ) - <b><font color="0000BB">float</font></b>( -<font color="#0077BB">1</font>.<font color="#0077BB">0</font> ) ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> ) );
}/* <b><font color="0000BB">return</font></b> identity <b><font color="0000BB">in</font></b> range start,start+len, and repeat mirror elsewhere */<b><font color="0000BB">float</font></b> repeat_mirror_l( <b><font color="0000BB">float</font></b> x, <b><font color="0000BB">float</font></b> start, <b><font color="0000BB">float</font></b> len ) {
  <b><font color="0000BB">return</font></b> start + repeat_mirror( x - start, len );
} <b><font color="0000BB">float</font></b> repeat_mirror_e( <b><font color="0000BB">float</font></b> x, <b><font color="0000BB">float</font></b> start, <b><font color="0000BB">float</font></b> end ) {
  <b><font color="0000BB">return</font></b> start + repeat_mirror( x - start, end - start );
}/* <b><font color="0000BB">return</font></b> identity <b><font color="0000BB">in</font></b> range start,start+len, and repeat elsewhere */<b><font color="0000BB">float</font></b> repeat_e( <b><font color="0000BB">float</font></b> x, <b><font color="0000BB">float</font></b> start, <b><font color="0000BB">float</font></b> end ) {
  <b><font color="0000BB">return</font></b> start + repeat( x - start, end - start );
} <b><font color="0000BB">float</font></b> repeat_b( <b><font color="0000BB">float</font></b> x, bounds1 b ) {
  <b><font color="0000BB">return</font></b> b.pmin + repeat( x - b.pmin, b.pmax - b.pmin );
}
<b><font color="0000BB">vec2</font></b> repeat( <b><font color="0000BB">vec2</font></b> x, <b><font color="0000BB">vec2</font></b> len ) {
  <b><font color="0000BB">return</font></b> len * fract( x * ( <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">1</font>.<font color="#0077BB">0</font> ) / len ) );
} <b><font color="0000BB">vec2</font></b> repeat_mirror( <b><font color="0000BB">vec2</font></b> x, <b><font color="0000BB">vec2</font></b> len ) {
  <b><font color="0000BB">return</font></b> len * abs( <b><font color="0000BB">vec2</font></b>( -<font color="#0077BB">1</font>.<font color="#0077BB">0</font> ) + <font color="#0077BB">2</font>.<font color="#0077BB">0</font> * fract( ( ( x * ( <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">1</font>.<font color="#0077BB">0</font> ) / len ) ) - <b><font color="0000BB">vec2</font></b>( -<font color="#0077BB">1</font>.<font color="#0077BB">0</font> ) ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> ) );
}/* <b><font color="0000BB">return</font></b> identity <b><font color="0000BB">in</font></b> range start,start+len, and repeat mirror elsewhere */<b><font color="0000BB">vec2</font></b> repeat_mirror_l( <b><font color="0000BB">vec2</font></b> x, <b><font color="0000BB">vec2</font></b> start, <b><font color="0000BB">vec2</font></b> len ) {
  <b><font color="0000BB">return</font></b> start + repeat_mirror( x - start, len );
} <b><font color="0000BB">vec2</font></b> repeat_mirror_e( <b><font color="0000BB">vec2</font></b> x, <b><font color="0000BB">vec2</font></b> start, <b><font color="0000BB">vec2</font></b> end ) {
  <b><font color="0000BB">return</font></b> start + repeat_mirror( x - start, end - start );
}/* <b><font color="0000BB">return</font></b> identity <b><font color="0000BB">in</font></b> range start,start+len, and repeat elsewhere */<b><font color="0000BB">vec2</font></b> repeat_e( <b><font color="0000BB">vec2</font></b> x, <b><font color="0000BB">vec2</font></b> start, <b><font color="0000BB">vec2</font></b> end ) {
  <b><font color="0000BB">return</font></b> start + repeat( x - start, end - start );
} <b><font color="0000BB">vec2</font></b> repeat_b( <b><font color="0000BB">vec2</font></b> x, bounds2 b ) {
  <b><font color="0000BB">return</font></b> b.pmin + repeat( x - b.pmin, b.pmax - b.pmin );
}
<b><font color="0000BB">vec3</font></b> repeat( <b><font color="0000BB">vec3</font></b> x, <b><font color="0000BB">vec3</font></b> len ) {
  <b><font color="0000BB">return</font></b> len * fract( x * ( <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">1</font>.<font color="#0077BB">0</font> ) / len ) );
} <b><font color="0000BB">vec3</font></b> repeat_mirror( <b><font color="0000BB">vec3</font></b> x, <b><font color="0000BB">vec3</font></b> len ) {
  <b><font color="0000BB">return</font></b> len * abs( <b><font color="0000BB">vec3</font></b>( -<font color="#0077BB">1</font>.<font color="#0077BB">0</font> ) + <font color="#0077BB">2</font>.<font color="#0077BB">0</font> * fract( ( ( x * ( <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">1</font>.<font color="#0077BB">0</font> ) / len ) ) - <b><font color="0000BB">vec3</font></b>( -<font color="#0077BB">1</font>.<font color="#0077BB">0</font> ) ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> ) );
}/* <b><font color="0000BB">return</font></b> identity <b><font color="0000BB">in</font></b> range start,start+len, and repeat mirror elsewhere */<b><font color="0000BB">vec3</font></b> repeat_mirror_l( <b><font color="0000BB">vec3</font></b> x, <b><font color="0000BB">vec3</font></b> start, <b><font color="0000BB">vec3</font></b> len ) {
  <b><font color="0000BB">return</font></b> start + repeat_mirror( x - start, len );
} <b><font color="0000BB">vec3</font></b> repeat_mirror_e( <b><font color="0000BB">vec3</font></b> x, <b><font color="0000BB">vec3</font></b> start, <b><font color="0000BB">vec3</font></b> end ) {
  <b><font color="0000BB">return</font></b> start + repeat_mirror( x - start, end - start );
}/* <b><font color="0000BB">return</font></b> identity <b><font color="0000BB">in</font></b> range start,start+len, and repeat elsewhere */<b><font color="0000BB">vec3</font></b> repeat_e( <b><font color="0000BB">vec3</font></b> x, <b><font color="0000BB">vec3</font></b> start, <b><font color="0000BB">vec3</font></b> end ) {
  <b><font color="0000BB">return</font></b> start + repeat( x - start, end - start );
} <b><font color="0000BB">vec3</font></b> repeat_b( <b><font color="0000BB">vec3</font></b> x, bounds3 b ) {
  <b><font color="0000BB">return</font></b> b.pmin + repeat( x - b.pmin, b.pmax - b.pmin );
}
/* function returns <font color="#0077BB">0</font> at x = half_width */ <b><font color="0000BB">float</font></b> tri_p( <b><font color="0000BB">float</font></b> x, <b><font color="0000BB">float</font></b> half_width, <b><font color="0000BB">float</font></b> half_period ) {
  <b><font color="0000BB">return</font></b> half_width - repeat_mirror( x, half_period );
} /* function returns <font color="#0077BB">0</font> at x = half_width */ <b><font color="0000BB">float</font></b> tri_s( <b><font color="0000BB">float</font></b> x, <b><font color="0000BB">float</font></b> half_width, <b><font color="0000BB">float</font></b> half_spacing ) {
  <b><font color="0000BB">return</font></b> half_width - repeat_mirror( x, half_width + half_spacing );
} /* tri_b repeats bounds1 [s1,e1] inside a repeated bounds0 [s0,e0] */ /* be careful, it is *not* equivalent to using repeat_b on b0 and sd_bounds b1 inside that, unless b1 is centered */ /* use tri_b or sd_bounds_repeat_* to correctly repeat bounds sdf */ <b><font color="0000BB">float</font></b> tri_b( <b><font color="0000BB">float</font></b> p, <b><font color="0000BB">float</font></b> s0, <b><font color="0000BB">float</font></b> e0, <b><font color="0000BB">float</font></b> s1, <b><font color="0000BB">float</font></b> e1) {
  <b><font color="0000BB">float</font></b> c = s0 + ( e1 + s1 ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>;
  <b><font color="0000BB">return</font></b> -tri_p( p - c, ( e1 - s1 ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>, ( e0 - s0 ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> );
} /* same as above but with bounds */ <b><font color="0000BB">float</font></b> tri_b( <b><font color="0000BB">float</font></b> p, bounds1 b0, bounds1 b1) {
  <b><font color="0000BB">return</font></b> tri_b( p, b0.pmin, b0.pmax, b1.pmin, b1.pmax );
}
/* function returns <font color="#0077BB">0</font> at x = half_width */ <b><font color="0000BB">vec2</font></b> tri_p( <b><font color="0000BB">vec2</font></b> x, <b><font color="0000BB">vec2</font></b> half_width, <b><font color="0000BB">vec2</font></b> half_period ) {
  <b><font color="0000BB">return</font></b> half_width - repeat_mirror( x, half_period );
} /* function returns <font color="#0077BB">0</font> at x = half_width */ <b><font color="0000BB">vec2</font></b> tri_s( <b><font color="0000BB">vec2</font></b> x, <b><font color="0000BB">vec2</font></b> half_width, <b><font color="0000BB">vec2</font></b> half_spacing ) {
  <b><font color="0000BB">return</font></b> half_width - repeat_mirror( x, half_width + half_spacing );
} /* tri_b repeats bounds1 [s1,e1] inside a repeated bounds0 [s0,e0] */ /* be careful, it is *not* equivalent to using repeat_b on b0 and sd_bounds b1 inside that, unless b1 is centered */ /* use tri_b or sd_bounds_repeat_* to correctly repeat bounds sdf */ <b><font color="0000BB">vec2</font></b> tri_b( <b><font color="0000BB">vec2</font></b> p, <b><font color="0000BB">vec2</font></b> s0, <b><font color="0000BB">vec2</font></b> e0, <b><font color="0000BB">vec2</font></b> s1, <b><font color="0000BB">vec2</font></b> e1) {
  <b><font color="0000BB">vec2</font></b> c = s0 + ( e1 + s1 ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>;
  <b><font color="0000BB">return</font></b> -tri_p( p - c, ( e1 - s1 ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>, ( e0 - s0 ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> );
} /* same as above but with bounds */ <b><font color="0000BB">vec2</font></b> tri_b( <b><font color="0000BB">vec2</font></b> p, bounds2 b0, bounds2 b1) {
  <b><font color="0000BB">return</font></b> tri_b( p, b0.pmin, b0.pmax, b1.pmin, b1.pmax );
}
/* function returns <font color="#0077BB">0</font> at x = half_width */ <b><font color="0000BB">vec3</font></b> tri_p( <b><font color="0000BB">vec3</font></b> x, <b><font color="0000BB">vec3</font></b> half_width, <b><font color="0000BB">vec3</font></b> half_period ) {
  <b><font color="0000BB">return</font></b> half_width - repeat_mirror( x, half_period );
} /* function returns <font color="#0077BB">0</font> at x = half_width */ <b><font color="0000BB">vec3</font></b> tri_s( <b><font color="0000BB">vec3</font></b> x, <b><font color="0000BB">vec3</font></b> half_width, <b><font color="0000BB">vec3</font></b> half_spacing ) {
  <b><font color="0000BB">return</font></b> half_width - repeat_mirror( x, half_width + half_spacing );
} /* tri_b repeats bounds1 [s1,e1] inside a repeated bounds0 [s0,e0] */ /* be careful, it is *not* equivalent to using repeat_b on b0 and sd_bounds b1 inside that, unless b1 is centered */ /* use tri_b or sd_bounds_repeat_* to correctly repeat bounds sdf */ <b><font color="0000BB">vec3</font></b> tri_b( <b><font color="0000BB">vec3</font></b> p, <b><font color="0000BB">vec3</font></b> s0, <b><font color="0000BB">vec3</font></b> e0, <b><font color="0000BB">vec3</font></b> s1, <b><font color="0000BB">vec3</font></b> e1) {
  <b><font color="0000BB">vec3</font></b> c = s0 + ( e1 + s1 ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>;
  <b><font color="0000BB">return</font></b> -tri_p( p - c, ( e1 - s1 ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>, ( e0 - s0 ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> );
} /* same as above but with bounds */ <b><font color="0000BB">vec3</font></b> tri_b( <b><font color="0000BB">vec3</font></b> p, bounds3 b0, bounds3 b1) {
  <b><font color="0000BB">return</font></b> tri_b( p, b0.pmin, b0.pmax, b1.pmin, b1.pmax );
}
<i><font color="#FFFF00">// like band() but repeated, using smoothstep as poor AA</font></i>
<i><font color="#FFFF00">// - r is the half width of the stripes</font></i>
<i><font color="#FFFF00">// - raa is the half size of the edge/aa smoothstep (ex: pixel_size)</font></i>
<i><font color="#FFFF00">// - period is the distance between 2 consecutive stripes</font></i>
<b><font color="0000BB">float</font></b> stripes( <b><font color="0000BB">float</font></b> x, <b><font color="0000BB">float</font></b> period, <b><font color="0000BB">float</font></b> r, <b><font color="0000BB">float</font></b> raa ) {
  <b><font color="0000BB">return</font></b> smoothstep( r + raa, r - raa, repeat_mirror( x, period * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> ) );
}
<b><font color="0000BB">vec2</font></b> stripes( <b><font color="0000BB">vec2</font></b> x, <b><font color="0000BB">vec2</font></b> period, <b><font color="0000BB">vec2</font></b> r, <b><font color="0000BB">vec2</font></b> raa ) {
  <b><font color="0000BB">return</font></b> smoothstep( r + raa, r - raa, repeat_mirror( x, period * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> ) );
}
<i><font color="#FFFF00">// variation of stripes where multiple period overlap (stripes not centered on 0)</font></i>
<b><font color="0000BB">float</font></b> stripes2( <b><font color="0000BB">float</font></b> x, <b><font color="0000BB">float</font></b> period, <b><font color="0000BB">float</font></b> r, <b><font color="0000BB">float</font></b> raa ) {
  <b><font color="0000BB">return</font></b> smoothstep( r + raa, r - raa, repeat_mirror( x - r, period * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> ) );
}
<i><font color="#FFFF00">// hash functions from David Hoskins's https://www.shadertoy.com/view/4djSRW using "integer stepped ranges" settings</font></i>
<b><font color="0000BB">float</font></b> hash11( <b><font color="0000BB">float</font></b> p ) {
  <b><font color="0000BB">vec3</font></b> p3 = fract( <b><font color="0000BB">vec3</font></b>( p ) * .<font color="#0077BB">1031</font> );
  p3 += dot( p3, p3.yzx + <font color="#0077BB">19</font>.<font color="#0077BB">19</font> );
  <b><font color="0000BB">return</font></b> fract( ( p3.x + p3.y ) * p3.z );
}
<b><font color="0000BB">vec3</font></b> hash32( <b><font color="0000BB">vec2</font></b> p ) {
  <b><font color="0000BB">vec3</font></b> p3 = fract( <b><font color="0000BB">vec3</font></b>( p.xyx ) * <b><font color="0000BB">vec3</font></b>(.<font color="#0077BB">1031</font>, .<font color="#0077BB">1030</font>, .<font color="#0077BB">0973</font>) );
  p3 += dot( p3, p3.yxz + <font color="#0077BB">19</font>.<font color="#0077BB">19</font> );
  <b><font color="0000BB">return</font></b> fract( ( p3.xxy + p3.yzz ) * p3.zyx );
}
<i><font color="#FFFF00">// hopefully stable hash (across gpus and/or webgl) functions, munged from iq's version https://www.shadertoy.com/view/XlXcW</font></i>
<b><font color="0000BB">vec4</font></b> hash44_( <b><font color="0000BB">ivec4</font></b> x0 ) {
  <b><font color="0000BB">uint</font></b> k;
  k = <font color="#0077BB">1103515245</font>U;
  <b><font color="0000BB">uvec4</font></b> x = <b><font color="0000BB">uvec4</font></b>( x0 );
  x = (( x >> <font color="#0077BB">13</font>U ) ^ x.yzwx ) * k;
  x = (( x >> <font color="#0077BB">13</font>U ) ^ x.zwxy ) * k;
  <i><font color="#FFFF00">//  x = (( x >> 13U ) ^ x.wxyz ) * k; // can't really tell the difference</font></i>
  <b><font color="0000BB">return</font></b> <b><font color="0000BB">vec4</font></b>( x ) * ( <font color="#0077BB">1</font>.<font color="#0077BB">0</font> / <b><font color="0000BB">float</font></b>( <font color="#0077BB">0</font>xffffffffU ));
}
<b><font color="0000BB">vec4</font></b> hash42_( <b><font color="0000BB">ivec2</font></b> x0 )
{
  <b><font color="0000BB">uint</font></b> k = <font color="#0077BB">1103515245</font>U; <i><font color="#FFFF00">// GLIB C</font></i>
  <b><font color="0000BB">uvec4</font></b> x = <b><font color="0000BB">uvec4</font></b>( x0, x0 * <font color="#0077BB">0</font>x<font color="#0077BB">8</font>da6b343 );
  x = (( x >> <font color="#0077BB">13</font>U ) ^ x.yzwx ) * k;
  x = (( x >> <font color="#0077BB">13</font>U ) ^ x.zwxy ) * k;
  <i><font color="#FFFF00">//  x = (( x >> 13U ) ^ x.wxyz ) * k; // can't really tell the difference</font></i>
  <b><font color="0000BB">return</font></b> <b><font color="0000BB">vec4</font></b>( x ) * ( <font color="#0077BB">1</font>.<font color="#0077BB">0</font> / <b><font color="0000BB">float</font></b>( <font color="#0077BB">0</font>xffffffffU ));
}
<b><font color="0000BB">vec2</font></b> hash22_( <b><font color="0000BB">ivec2</font></b> p ) {
  <b><font color="0000BB">return</font></b> hash42_( p ).xy;
}
<b><font color="0000BB">vec2</font></b> hash24_( <b><font color="0000BB">ivec4</font></b> p ) {
  <b><font color="0000BB">return</font></b> hash44_( p ).xy;
}
<i><font color="#FFFF00">// return a unit vector, or an angle (it's the same thing)</font></i>
<b><font color="0000BB">vec2</font></b> unit_vector2( <b><font color="0000BB">float</font></b> angle ) {
  <b><font color="0000BB">return</font></b> <b><font color="0000BB">vec2</font></b>( cos( angle ), sin( angle ) );
}
<i><font color="#FFFF00">// note that if point p is also a unit vector, rotate_with_unit_vector returns the same as doing unit_vector2 on the sum of the angles (obvious but)</font></i>
<b><font color="0000BB">vec2</font></b> rotate_with_unit_vector( <b><font color="0000BB">vec2</font></b> p, <b><font color="0000BB">vec2</font></b> cs ) {
  <b><font color="0000BB">return</font></b> <b><font color="0000BB">vec2</font></b>( cs.x * p.x - cs.y * p.y, cs.y * p.x + cs.x * p.y );
}
<b><font color="0000BB">vec2</font></b> rotate_with_unit_vector_neg( <b><font color="0000BB">vec2</font></b> p, <b><font color="0000BB">vec2</font></b> cs ) {
  <b><font color="0000BB">return</font></b> <b><font color="0000BB">vec2</font></b>( cs.x * p.x + cs.y * p.y, -cs.y * p.x + cs.x * p.y );
}
<b><font color="0000BB">vec2</font></b> rotate_with_angle( <b><font color="0000BB">vec2</font></b> p, <b><font color="0000BB">float</font></b> a_angle ) {
  <b><font color="0000BB">return</font></b> rotate_with_unit_vector( p, unit_vector2( a_angle ) );
}
<i><font color="#FFFF00">// theta is the angle with the z axis, range [0,pi]</font></i>
<i><font color="#FFFF00">// phi is the angle with x vectors on z=0 plane, range [0,2pi]</font></i>
<b><font color="0000BB">vec3</font></b> zup_spherical_coords_to_vector( <b><font color="0000BB">float</font></b> theta, <b><font color="0000BB">float</font></b> phi ) {
  <b><font color="0000BB">vec2</font></b> theta_vec = unit_vector2( theta );
  <b><font color="0000BB">return</font></b> <b><font color="0000BB">vec3</font></b>( theta_vec.y * unit_vector2( phi ), theta_vec.x );
}
<b><font color="0000BB">vec3</font></b> yup_spherical_coords_to_vector( <b><font color="0000BB">float</font></b> theta, <b><font color="0000BB">float</font></b> phi ) {
  <b><font color="0000BB">return</font></b> zup_spherical_coords_to_vector( theta, phi ).yzx;
}
<b><font color="0000BB">mat4</font></b> yup_spherical_offset( <b><font color="0000BB">float</font></b> theta, <b><font color="0000BB">float</font></b> phi )
{
  <b><font color="0000BB">vec3</font></b> y = yup_spherical_coords_to_vector( theta, phi );
  <b><font color="0000BB">vec3</font></b> z = yup_spherical_coords_to_vector( theta + <font color="#0077BB">3</font>.<font color="#0077BB">141592654</font> * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>, phi );
  <b><font color="0000BB">vec3</font></b> x = cross( y, z );
  <b><font color="0000BB">return</font></b> <b><font color="0000BB">mat4</font></b>( <b><font color="0000BB">vec4</font></b>( x, <font color="#0077BB">0</font>.<font color="#0077BB">0</font> ), <b><font color="0000BB">vec4</font></b>( y, <font color="#0077BB">0</font>.<font color="#0077BB">0</font> ), <b><font color="0000BB">vec4</font></b>( z, <font color="#0077BB">0</font>.<font color="#0077BB">0</font> ), <b><font color="0000BB">vec4</font></b>( <font color="#0077BB">0</font>, <font color="#0077BB">0</font>, <font color="#0077BB">0</font>, <font color="#0077BB">1</font> ) );
}
<b><font color="0000BB">mat4</font></b> z_rotation( <b><font color="0000BB">float</font></b> angle ) {
  <b><font color="0000BB">vec2</font></b> v = unit_vector2( angle );
  <b><font color="0000BB">return</font></b> <b><font color="0000BB">mat4</font></b>( <b><font color="0000BB">vec4</font></b>( v.x, v.y, <font color="#0077BB">0</font>.<font color="#0077BB">0</font>, <font color="#0077BB">0</font>.<font color="#0077BB">0</font> ), <b><font color="0000BB">vec4</font></b>( -v.y, v.x, <font color="#0077BB">0</font>.<font color="#0077BB">0</font>, <font color="#0077BB">0</font>.<font color="#0077BB">0</font> ), <b><font color="0000BB">vec4</font></b>( <font color="#0077BB">0</font>, <font color="#0077BB">0</font>, <font color="#0077BB">1</font>, <font color="#0077BB">0</font> ), <b><font color="0000BB">vec4</font></b>( <font color="#0077BB">0</font>, <font color="#0077BB">0</font>, <font color="#0077BB">0</font>, <font color="#0077BB">1</font> ) );
}
<b><font color="0000BB">struct</font></b> Ray {
  <b><font color="0000BB">vec3</font></b> o;
  <b><font color="0000BB">vec3</font></b> d;
};
Ray mkray( <b><font color="0000BB">vec3</font></b> o, <b><font color="0000BB">vec3</font></b> d ) {
  Ray tmp;
  tmp.o = o;
  tmp.d = d;
  <b><font color="0000BB">return</font></b> tmp;
}
Ray get_view_ray( <b><font color="0000BB">vec2</font></b> normalized_pos, <b><font color="0000BB">float</font></b> z, <b><font color="0000BB">float</font></b> aspect, <b><font color="0000BB">float</font></b> tan_half_fovy ) {
  <b><font color="0000BB">vec3</font></b> p = <b><font color="0000BB">vec3</font></b>( normalized_pos * <b><font color="0000BB">vec2</font></b>( aspect, <font color="#0077BB">1</font>.<font color="#0077BB">0</font> ) * tan_half_fovy, -<font color="#0077BB">1</font>.<font color="#0077BB">0</font> ) * z;
  <b><font color="0000BB">return</font></b> mkray( p, normalize( p ) );
}
<b><font color="0000BB">mat4</font></b> lookat( <b><font color="0000BB">vec3</font></b> eye, <b><font color="0000BB">vec3</font></b> center, <b><font color="0000BB">vec3</font></b> up ) {
  <b><font color="0000BB">vec3</font></b> z = normalize( eye - center );
  <b><font color="0000BB">vec3</font></b> x = normalize( cross( up, z ) );
  <b><font color="0000BB">vec3</font></b> y = cross( z, x );
  <b><font color="0000BB">return</font></b> <b><font color="0000BB">mat4</font></b>( <b><font color="0000BB">vec4</font></b>( x, <font color="#0077BB">0</font>.<font color="#0077BB">0</font> ), <b><font color="0000BB">vec4</font></b>( y, <font color="#0077BB">0</font>.<font color="#0077BB">0</font> ), <b><font color="0000BB">vec4</font></b>( z, <font color="#0077BB">0</font>.<font color="#0077BB">0</font> ), <b><font color="0000BB">vec4</font></b>( eye, <font color="#0077BB">1</font>.<font color="#0077BB">0</font> ) );
}
<b><font color="0000BB">float</font></b> plane_trace_z( Ray ray, <b><font color="0000BB">float</font></b> base, <b><font color="0000BB">float</font></b> epsilon ) {
  <b><font color="0000BB">return</font></b> abs( ray.d.z ) > epsilon ? ( base - ray.o.z ) / ray.d.z : /* FLT_MAX */<font color="#0077BB">1000000</font>.;
}
<i><font color="#FFFF00">// build a little quadric so that y'(0)=0, y(r)=r, y'(r)=1 here</font></i>
<b><font color="0000BB">float</font></b> her2( <b><font color="0000BB">float</font></b> x, <b><font color="0000BB">float</font></b> r ) {
  <b><font color="0000BB">return</font></b> <font color="#0077BB">0</font>.<font color="#0077BB">5</font> * ( ( <font color="#0077BB">1</font>.<font color="#0077BB">0</font> / r ) * x * x + r );
}
<i><font color="#FFFF00">// customize max of f(x)=0 and f(x)=x in the x in [ -r,r] interval</font></i>
<b><font color="0000BB">float</font></b> curved_max_vfunc_hard_bevel( <b><font color="0000BB">float</font></b> x, <b><font color="0000BB">float</font></b> r ) {
  <b><font color="0000BB">return</font></b> max( r, abs( x ) );
}
<b><font color="0000BB">float</font></b> curved_max_vfunc_weld_quadric( <b><font color="0000BB">float</font></b> x, <b><font color="0000BB">float</font></b> r ) {
  x = abs( x );
  <b><font color="0000BB">if</font></b> ( x > r ) <b><font color="0000BB">return</font></b> x;
  <b><font color="0000BB">return</font></b> her2( x, r );
}
<i><font color="#FFFF00">// rr in 0,1, set < 1 if you want to see a flat bit</font></i>
<i><font color="#FFFF00">// rr == 1 gives a soft bevel, slightly different shape and a bit more expensive than curved_max_vfunc_weld_quadric</font></i>
<b><font color="0000BB">float</font></b> curved_max_vfunc_round_bevel( <b><font color="0000BB">float</font></b> x, <b><font color="0000BB">float</font></b> r, <b><font color="0000BB">float</font></b> rr )
{
  x = abs( x );
  <b><font color="0000BB">if</font></b> ( x > r ) <b><font color="0000BB">return</font></b> x;
  <b><font color="0000BB">float</font></b> a = rr * r; <i><font color="#FFFF00">// make bevel radius relative to r (so rr is a 0,1 value, if you go above 1 yo get a discontinuity at 0)</font></i>
  <b><font color="0000BB">float</font></b> cr = a * <font color="#0077BB">1</font>.<font color="#0077BB">414213562</font>; <i><font color="#FFFF00">// this is the radius of the circle used to make the round bevel</font></i>
  <b><font color="0000BB">vec2</font></b> c = <b><font color="0000BB">vec2</font></b>( r - a, r + a ); <i><font color="#FFFF00">// center of round bevel is at (r-a,r+a) (on a y=1-x line that emanates from (r,r))</font></i>
  <b><font color="0000BB">return</font></b> c.y - sqrt( cr * cr - pow2( max( <font color="#0077BB">0</font>.<font color="#0077BB">0</font>, x - c.x ) ) );
}
<i><font color="#FFFF00">// max</font></i>
<b><font color="0000BB">float</font></b> opI( <b><font color="0000BB">float</font></b> d1, <b><font color="0000BB">float</font></b> d2 ) {
  <b><font color="0000BB">return</font></b> max( d1, d2 );
}
<b><font color="0000BB">float</font></b> opI_soft2( <b><font color="0000BB">float</font></b> a, <b><font color="0000BB">float</font></b> b, <b><font color="0000BB">float</font></b> k ) {
  <b><font color="0000BB">return</font></b> soft_max2( a, b, k );
}
<b><font color="0000BB">float</font></b> opI_hard_bevel( <b><font color="0000BB">float</font></b> a, <b><font color="0000BB">float</font></b> b, <b><font color="0000BB">float</font></b> r ) {
  <b><font color="0000BB">float</font></b> c = ( a + b ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>;
  <b><font color="0000BB">return</font></b> c + curved_max_vfunc_hard_bevel( a - c, r );
}
<b><font color="0000BB">float</font></b> opI_round_bevel( <b><font color="0000BB">float</font></b> a, <b><font color="0000BB">float</font></b> b, <b><font color="0000BB">float</font></b> r, <b><font color="0000BB">float</font></b> rr ) {
  <b><font color="0000BB">float</font></b> c = ( a + b ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>;
  <b><font color="0000BB">return</font></b> c + curved_max_vfunc_round_bevel( a - c, r, rr );
}
<b><font color="0000BB">float</font></b> opU( <b><font color="0000BB">float</font></b> d1, <b><font color="0000BB">float</font></b> d2 ) {
  <b><font color="0000BB">return</font></b> -max( -d1, -d2 );
}
<b><font color="0000BB">float</font></b> opU_hard_bevel( <b><font color="0000BB">float</font></b> a, <b><font color="0000BB">float</font></b> b, <b><font color="0000BB">float</font></b> r ) {
  <b><font color="0000BB">return</font></b> -opI_hard_bevel( -a, -b, r );
}
<b><font color="0000BB">float</font></b> opS( <b><font color="0000BB">float</font></b> d1, <b><font color="0000BB">float</font></b> d2 ) {
  <b><font color="0000BB">return</font></b> max( -d2, d1 );
}
<b><font color="0000BB">float</font></b> opS_hard_bevel( <b><font color="0000BB">float</font></b> a, <b><font color="0000BB">float</font></b> b, <b><font color="0000BB">float</font></b> r ) {
  <b><font color="0000BB">return</font></b> opI_hard_bevel( -b, a, r );
}
<b><font color="0000BB">float</font></b> opI( <b><font color="0000BB">float</font></b> d1, <b><font color="0000BB">float</font></b> d2, <b><font color="0000BB">float</font></b> d3 ) {
  <b><font color="0000BB">return</font></b> max( max( d1, d2 ), d3 );
}
<i><font color="#FFFF00">// Band/border operations (extract a band from an sdf)</font></i>
<i><font color="#FFFF00">// band c-r,c+r</font></i>
<b><font color="0000BB">float</font></b> opB_rc( <b><font color="0000BB">float</font></b> d, <b><font color="0000BB">float</font></b> r, <b><font color="0000BB">float</font></b> c ) {
  <b><font color="0000BB">return</font></b> abs( d - c ) - r;
}
<i><font color="#FFFF00">// band -w,0</font></i>
<b><font color="0000BB">float</font></b> opB_inside( <b><font color="0000BB">float</font></b> d, <b><font color="0000BB">float</font></b> w ) {
  <b><font color="0000BB">float</font></b> r = w * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>;
  <b><font color="0000BB">return</font></b> opB_rc( d, r, -r );
}
<i><font color="#FFFF00">// band 0,w</font></i>
<b><font color="0000BB">float</font></b> opB_outside( <b><font color="0000BB">float</font></b> d, <b><font color="0000BB">float</font></b> w ) {
  <b><font color="0000BB">float</font></b> r = w * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>;
  <b><font color="0000BB">return</font></b> opB_rc( d, r, r );
}
<i><font color="#FFFF00">// band mi,ma</font></i>
<i><font color="#FFFF00">// should be same as sd_bounds_range(d,mi,ma)</font></i>
<b><font color="0000BB">float</font></b> opB_range( <b><font color="0000BB">float</font></b> d, <b><font color="0000BB">float</font></b> mi, <b><font color="0000BB">float</font></b> ma ) {
  <b><font color="0000BB">return</font></b> opB_rc( d, ( ma - mi ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>, ( mi + ma ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> );
}
<i><font color="#FFFF00">// trying many apis to see what sticks.</font></i>
<b><font color="0000BB">float</font></b> sd_bounds_range_round( <b><font color="0000BB">vec2</font></b> p, <b><font color="0000BB">vec2</font></b> mi, <b><font color="0000BB">vec2</font></b> ma, <b><font color="0000BB">float</font></b> r )
{
  <b><font color="0000BB">vec2</font></b> h = ( ma - mi ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>;
  p = abs( p - ( mi + ma ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> );
  <b><font color="0000BB">vec2</font></b> c = h - r;
  <b><font color="0000BB">float</font></b> mask = max( step( c.x, p.x ), step( c.y, p.y ) );
  <b><font color="0000BB">return</font></b> mix( -r + max( ( p - c ).x, ( p - c ).y ), length( max( p - c, <font color="#0077BB">0</font>.<font color="#0077BB">0</font> ) ) - r, mask );
}
<b><font color="0000BB">float</font></b> sd_bounds_half_size( <b><font color="0000BB">float</font></b> p, <b><font color="0000BB">float</font></b> h ) {
  p = abs( p ) - h;
  <b><font color="0000BB">return</font></b> p;
}
<b><font color="0000BB">float</font></b> sd_bounds_half_size( <b><font color="0000BB">vec2</font></b> p, <b><font color="0000BB">vec2</font></b> h ) {
  p = abs( p ) - h;
  <b><font color="0000BB">return</font></b> opI( p.x, p.y );
}
<b><font color="0000BB">float</font></b> sd_bounds_half_size( <b><font color="0000BB">vec3</font></b> p, <b><font color="0000BB">vec3</font></b> h ) {
  p = abs( p ) - h;
  <b><font color="0000BB">return</font></b> opI( p.x, p.y, p.z );
}
<b><font color="0000BB">float</font></b> sd_bounds_range( <b><font color="0000BB">vec2</font></b> p, <b><font color="0000BB">vec2</font></b> mi, <b><font color="0000BB">vec2</font></b> ma ) {
  <b><font color="0000BB">vec2</font></b> hmi = mi * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>;
  <b><font color="0000BB">vec2</font></b> hma = ma * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>;
  <b><font color="0000BB">return</font></b> sd_bounds_half_size( p - ( hma + hmi ), hma - hmi );
}
<i><font color="#FFFF00">// those bounds repeat might be good after all, since they centering and lead to a correct repeat...</font></i>
<b><font color="0000BB">float</font></b> sd_bounds_range( <b><font color="0000BB">float</font></b> p, <b><font color="0000BB">float</font></b> mi, <b><font color="0000BB">float</font></b> ma ) {
  <b><font color="0000BB">return</font></b> sd_bounds_half_size( p - ( ( ma + mi ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> ), ( ma - mi ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> );
}
<b><font color="0000BB">float</font></b> sd_bounds_range( <b><font color="0000BB">vec3</font></b> p, <b><font color="0000BB">vec3</font></b> mi, <b><font color="0000BB">vec3</font></b> ma ) {
  <b><font color="0000BB">return</font></b> sd_bounds_half_size( p - ( ( ma + mi ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> ), ( ma - mi ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> );
}
<b><font color="0000BB">float</font></b> sd_bounds( <b><font color="0000BB">vec2</font></b> p, bounds2 b ) {
  <b><font color="0000BB">return</font></b> sd_bounds_range( p, b.pmin, b.pmax );
}
<b><font color="0000BB">float</font></b> sd_bounds( <b><font color="0000BB">vec3</font></b> p, bounds3 b ) {
  <b><font color="0000BB">return</font></b> sd_bounds_range( p, b.pmin, b.pmax );
}
<i><font color="#FFFF00">// see sd_bounds_repeat_range_range instead of sd_bounds_repeat_size_margin</font></i>
<b><font color="0000BB">float</font></b> sd_bounds_repeat_size_margin( <b><font color="0000BB">float</font></b> p, <b><font color="0000BB">float</font></b> size, <b><font color="0000BB">float</font></b> margin ) {
  <b><font color="0000BB">return</font></b> sd_bounds_range( repeat( p, size ), margin, size - margin );
}
<b><font color="0000BB">float</font></b> sd_bounds_repeat_size_margin( <b><font color="0000BB">vec2</font></b> p, <b><font color="0000BB">vec2</font></b> size, <b><font color="0000BB">vec2</font></b> margin ) {
  <b><font color="0000BB">return</font></b> sd_bounds_range( repeat( p, size ), margin, size - margin );
}
<b><font color="0000BB">float</font></b> sd_bounds_repeat_size_margin( <b><font color="0000BB">vec3</font></b> p, <b><font color="0000BB">vec3</font></b> size, <b><font color="0000BB">vec3</font></b> margin ) {
  <b><font color="0000BB">return</font></b> sd_bounds_range( repeat( p, size ), margin, size - margin );
}
<i><font color="#FFFF00">// repeat bounds with margin, (mi1,ma1) is included inside (mi,ma)</font></i>
<b><font color="0000BB">float</font></b> sd_bounds_repeat_range_range( <b><font color="0000BB">float</font></b> p, <b><font color="0000BB">float</font></b> mi, <b><font color="0000BB">float</font></b> ma, <b><font color="0000BB">float</font></b> mi1, <b><font color="0000BB">float</font></b> ma1 ) {
  <b><font color="0000BB">return</font></b> maxcomp( tri_b( p, mi, ma, mi1, ma1 ) );
}
<b><font color="0000BB">float</font></b> sd_bounds_repeat_range_range( <b><font color="0000BB">vec2</font></b> p, <b><font color="0000BB">vec2</font></b> mi, <b><font color="0000BB">vec2</font></b> ma, <b><font color="0000BB">vec2</font></b> mi1, <b><font color="0000BB">vec2</font></b> ma1 ) {
  <b><font color="0000BB">return</font></b> maxcomp( tri_b( p, mi, ma, mi1, ma1 ) );
}
<i><font color="#FFFF00">// https://learnopengl.com/#!PBR/Theory</font></i>
<i><font color="#FFFF00">// http://graphicrants.blogspot.jp/</font></i>
<i><font color="#FFFF00">// alpha = roughness*roughness and "m stands for the microfacet normal... in practice you input the half vector for m"</font></i>
<i><font color="#FFFF00">// Trowbridge-Reitz</font></i>
<b><font color="0000BB">float</font></b> D_GGX( <b><font color="0000BB">float</font></b> m_dot_n, <b><font color="0000BB">float</font></b> alpha ) {
  <b><font color="0000BB">float</font></b> alpha_sqr = alpha * alpha;
  <b><font color="0000BB">return</font></b> alpha_sqr / ( <font color="#0077BB">3</font>.<font color="#0077BB">141592654</font> * pow2( pow2( m_dot_n ) * ( alpha_sqr - <font color="#0077BB">1</font>. ) + <font color="#0077BB">1</font>. ) );
}
<b><font color="0000BB">float</font></b> G_kelemen( <b><font color="0000BB">float</font></b> n_dot_l, <b><font color="0000BB">float</font></b> n_dot_v, <b><font color="0000BB">float</font></b> v_dot_h ) {
  <b><font color="0000BB">return</font></b> n_dot_l * n_dot_v / pow2( v_dot_h );
}
<b><font color="0000BB">float</font></b> F_none( <b><font color="0000BB">float</font></b> v_dot_h, <b><font color="0000BB">float</font></b> F0 ) {
  <b><font color="0000BB">return</font></b> F0;
}
<b><font color="0000BB">float</font></b> F_schlick( <b><font color="0000BB">float</font></b> v_dot_h, <b><font color="0000BB">float</font></b> F0 ) {
  <b><font color="0000BB">return</font></b> F0 + ( <font color="#0077BB">1</font>. - F0 ) * pow5( <font color="#0077BB">1</font>. - v_dot_h );
}
<i><font color="#FFFF00">// I am not going to pretend anything is physically realistic here, but at least try to use standardized functions</font></i>
<i><font color="#FFFF00">// v = wi</font></i>
<b><font color="0000BB">vec3</font></b> add_light_contrib( <b><font color="0000BB">vec3</font></b> albedo, <b><font color="0000BB">vec3</font></b> l, <b><font color="0000BB">vec3</font></b> n, <b><font color="0000BB">vec3</font></b> v, <b><font color="0000BB">vec3</font></b> Li, <b><font color="0000BB">float</font></b> dwi, <b><font color="0000BB">float</font></b> kdiffuse, <b><font color="0000BB">float</font></b> kspecular, <b><font color="0000BB">float</font></b> roughness )
{
  <b><font color="0000BB">float</font></b> F0 = <font color="#0077BB">0</font>.<font color="#0077BB">08</font>;
  <b><font color="0000BB">float</font></b> alpha = roughness * roughness;
  <b><font color="0000BB">vec3</font></b> h = normalize( l + v );
  <b><font color="0000BB">float</font></b> eps = <font color="#0077BB">1</font>e-<font color="#0077BB">4</font>; <i><font color="#FFFF00">// else divides by zero</font></i>
  <b><font color="0000BB">float</font></b> n_dot_l = max( eps, dot( n, l ) );
  <b><font color="0000BB">float</font></b> n_dot_v = max( eps, dot( n, v ) );
  <b><font color="0000BB">float</font></b> n_dot_h = max( eps, dot( n, h ) );
  <b><font color="0000BB">float</font></b> v_dot_h = max( eps, dot( h, v ) );
  <b><font color="0000BB">float</font></b> D = D_GGX( n_dot_h, alpha ); <i><font color="#FFFF00">// n_dot_h should probably be clamped to >=0</font></i>
  <b><font color="0000BB">float</font></b> G = G_kelemen( n_dot_l, n_dot_v, v_dot_h );
  <i><font color="#FFFF00">//  float F = F_none( n_dot_v, F0 );</font></i>
  <b><font color="0000BB">float</font></b> F = F_schlick( n_dot_v, F0 );
  <i><font color="#FFFF00">//  float F = F_schlick( n_dot_h, F0 ); // can't be right</font></i>
  <b><font color="0000BB">return</font></b> ( ( kdiffuse * albedo * ( <font color="#0077BB">1</font>. / <font color="#0077BB">3</font>.<font color="#0077BB">141592654</font> )
             + kspecular * ( D * F * G ) / ( <font color="#0077BB">4</font>. * n_dot_l * n_dot_v ) ) ) * Li * n_dot_l * dwi;
}
<i><font color="#FFFF00">//http://www.cs.utah.edu/~reinhard/cdrom/tonemap.pdf</font></i>
<b><font color="0000BB">vec3</font></b> tonemap_reinhard( <b><font color="0000BB">vec3</font></b> x ) {
  <b><font color="0000BB">return</font></b> x / ( <font color="#0077BB">1</font>. + x );
}
<b><font color="0000BB">vec3</font></b> gamma_correction( <b><font color="0000BB">vec3</font></b> L ) {
  <b><font color="0000BB">return</font></b> pow( L, <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">45</font> ) );
}
<i><font color="#FFFF00">// mentioned in http://resources.mpi-inf.mpg.de/tmo/logmap/ , more dark tones friendly than just pow(L,0.45)</font></i>
<b><font color="0000BB">vec3</font></b> gamma_correction_itu( <b><font color="0000BB">vec3</font></b> L ) {
  <b><font color="0000BB">return</font></b> mix( <font color="#0077BB">4</font>.<font color="#0077BB">5061986</font> * L, <font color="#0077BB">1</font>.<font color="#0077BB">099</font> * pow( L, <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">45</font> ) ) - <font color="#0077BB">0</font>.<font color="#0077BB">099</font>, step( <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">018</font> ), L ) );
}
<i><font color="#FFFF00">// returns 0 if v component is zero, rcp else, pass s = sign( v ) (values for s are -1, 0, 1)</font></i>
<b><font color="0000BB">vec3</font></b> zrcp( <b><font color="0000BB">vec3</font></b> v, <b><font color="0000BB">vec3</font></b> s ) {
  s = abs( s );
  <b><font color="0000BB">return</font></b> s / ( ( s - <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">1</font>. ) ) + v );
}
<i><font color="#FFFF00">// encapsulate dda iteration a little bit for readability</font></i>
<b><font color="0000BB">struct</font></b> DDA3
{
  <b><font color="0000BB">vec3</font></b> start, v; <i><font color="#FFFF00">// v = end - start</font></i>
  <b><font color="0000BB">vec3</font></b> s; <i><font color="#FFFF00">// sign(v)</font></i>
  <b><font color="0000BB">vec3</font></b> f1; <i><font color="#FFFF00">// spacing (as a fraction of v, not distance) between 2 grid lines, to be multiplied by v to get a vector</font></i>
  <b><font color="0000BB">vec3</font></b> f; <i><font color="#FFFF00">// segment intersects unit grid at points i = dda.start + ( dda.t[k] + i * dda.t1[k] ) * dda.v</font></i>
  <b><font color="0000BB">vec3</font></b> c; <i><font color="#FFFF00">// cell index we entered (coords of bottom left corner)</font></i>
  <b><font color="0000BB">int</font></b> done; <i><font color="#FFFF00">// iteration end condition</font></i>
  <b><font color="0000BB">vec3</font></b> am; <i><font color="#FFFF00">// argmin used during iteration</font></i>
  <b><font color="0000BB">vec3</font></b> p; <i><font color="#FFFF00">// which point we entered the cell from, or start, or end</font></i>
};
<i><font color="#FFFF00">// iterate on p = dda.start + ( dda.end - dda.start ) * dda.alpha such that p intersect canonical dda.a</font></i>
<i><font color="#FFFF00">// supporting arbitrary cell size is not much more expensive so we do it</font></i>
DDA3 dda_init( <b><font color="0000BB">vec3</font></b> a_start, <b><font color="0000BB">vec3</font></b> a_end, <b><font color="0000BB">vec3</font></b> a_size, <b><font color="0000BB">bool</font></b> a_finite )
{
  DDA3 dda;
  dda.start = a_start;
  dda.v = a_end - a_start;
  dda.s = sign( dda.v ); <i><font color="#FFFF00">// -1, 0, 1</font></i>
  <b><font color="0000BB">vec3</font></b> v_zrcp = <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">1</font>. ) / dda.v; <i><font color="#FFFF00">// divide by zero</font></i>
  <b><font color="0000BB">vec3</font></b> cell_size_rcp = <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">1</font>. ) / a_size;
  dda.c = floor( a_start * cell_size_rcp ); <i><font color="#FFFF00">// start cell</font></i>
  dda.f = ( ( dda.c + ( dda.s + <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">1</font>. ) ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> ) * a_size - a_start ) * v_zrcp; <i><font color="#FFFF00">// go positive or negative direction, initial fractional t</font></i>
  <i><font color="#FFFF00">// do this only for dda_step_segment</font></i>
  <b><font color="0000BB">if</font></b> ( a_finite ) dda.f = min( <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">1</font>. ), dda.f + <font color="#0077BB">1</font>. - abs( dda.s ) ); <i><font color="#FFFF00">// if the sign is 0, set t to 1, meaning we are done on this axis</font></i>
  dda.f1 = dda.s * v_zrcp * a_size; <i><font color="#FFFF00">// per axis grid steping as a fraction of v</font></i>
  dda.done = <font color="#0077BB">0</font>;
  dda.am = <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">0</font>. );
  dda.p = dda.start;
  <b><font color="0000BB">return</font></b> dda;
}
<i><font color="#FFFF00">// returns 1,0,0 if x is the min, 0,1,0 if y is the min, 0,0,1 if z is the min (function code is from iq's shader)</font></i>
<i><font color="#FFFF00">// very good for shader because we don't have to use random access which is sometimes borked in surprising ways</font></i>
<b><font color="0000BB">vec3</font></b> argminv( <b><font color="0000BB">vec3</font></b> v ) {
  <b><font color="0000BB">return</font></b> step( v.xyz, v.yxy ) * step( v.xyz, v.zzx );
}
<i><font color="#FFFF00">// iterate on all cells intersecting the input segment</font></i>
<i><font color="#FFFF00">// make sure you called dda_init with a_finite = true</font></i>
<i><font color="#FFFF00">// dda.done == 1 is the loop exit condition</font></i>
<i><font color="#FFFF00">//void dda_step_segment( inout DDA3 dda )</font></i>
<i><font color="#FFFF00">//{</font></i>
<i><font color="#FFFF00">//  if ( sum( dda.f ) == 3. ) ++dda.done; // all 1. means we covered v and we should be at the end point</font></i>
<i><font color="#FFFF00">//  else</font></i>
<i><font color="#FFFF00">//  {</font></i>
<i><font color="#FFFF00">//    dda.am = argminv( dda.f );</font></i>
<i><font color="#FFFF00">//    dda.p = dda.start + sum( dda.am * dda.f ) * dda.v;</font></i>
<i><font color="#FFFF00">//    dda.c += dda.am * dda.s;</font></i>
<i><font color="#FFFF00">//    dda.f = min( dda.f + dda.am * dda.f1, vec3( 1. ) ); // next dda.f</font></i>
<i><font color="#FFFF00">//  }</font></i>
<i><font color="#FFFF00">//}</font></i>
<i><font color="#FFFF00">// iterate forever - if you don't care about iterating exactly the segment length, a bunch of things can be skipped</font></i>
<i><font color="#FFFF00">// make sure you called dda_init with a_finite = false</font></i>
<b><font color="0000BB">void</font></b> dda_step_infinite( <b><font color="0000BB">inout</font></b> DDA3 dda )
{
  dda.am = argminv( dda.f );
  dda.p = dda.start + sum( dda.am * dda.f ) * dda.v;
  dda.c += dda.am * dda.s;
  dda.f = dda.f + dda.am * dda.f1; <i><font color="#FFFF00">// next dda.f</font></i>
}
<b><font color="0000BB">vec3</font></b> dda_point( <b><font color="0000BB">in</font></b> DDA3 dda, <b><font color="0000BB">float</font></b> f ) {
  <b><font color="0000BB">return</font></b> dda.start + dda.v * f;
}
<i><font color="#FFFF00">// t0, t1 are t ranges along rays on each dimension, returns (union min, union max) range, ray intersects iff .y > .x</font></i>
<b><font color="0000BB">vec2</font></b> intersect_ranges( <b><font color="0000BB">vec3</font></b> t0, <b><font color="0000BB">vec3</font></b> t1 )
{
  <b><font color="0000BB">return</font></b> <b><font color="0000BB">vec2</font></b>( maxcomp( <b><font color="0000BB">vec3</font></b>( min( t0.x, t1.x ), min( t0.y, t1.y ), min( t0.z, t1.z ) ) ),
               mincomp( <b><font color="0000BB">vec3</font></b>( max( t0.x, t1.x ), max( t0.y, t1.y ), max( t0.z, t1.z ) ) ) );
}
<b><font color="0000BB">struct</font></b> Ranges_x4
{
  <b><font color="0000BB">vec2</font></b> rA, rB, rC, rD; <i><font color="#FFFF00">// ranges along the ray, for each bound b[i]</font></i>
  bounds3 bA, bB, bC, bD; <i><font color="#FFFF00">// we could store bounds2 + height</font></i>
};
<i><font color="#FFFF00">// factorize and pack a few terms used in raytracing of 4 children bounds</font></i>
<b><font color="0000BB">struct</font></b> Split4bSetup
{
  <b><font color="0000BB">vec3</font></b> drcp;
  <b><font color="0000BB">float</font></b> dz;
  <b><font color="0000BB">vec3</font></b> dmargin;
  <b><font color="0000BB">vec2</font></b> dmin, dmax;
};
Split4bSetup setup_Split4b( Ray ray, <b><font color="0000BB">vec2</font></b> amin, <b><font color="0000BB">vec2</font></b> amax, <b><font color="0000BB">vec2</font></b> margin )
{
  Split4bSetup set;
  set.drcp = <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">1</font>. ) / ray.d; <i><font color="#FFFF00">// divide by zero</font></i>
  set.dmin = ( amin - ray.o.xy ) * set.drcp.xy;
  set.dmax = ( amax - ray.o.xy ) * set.drcp.xy;
  set.dz = ray.o.z * set.drcp.z;
  set.dmargin = <b><font color="0000BB">vec3</font></b>( margin * set.drcp.xy, <font color="#0077BB">0</font>. );
  <b><font color="0000BB">return</font></b> set;
}
<i><font color="#FFFF00">// --------------</font></i>
<i><font color="#FFFF00">// |   |   | D  |</font></i>
<i><font color="#FFFF00">// | A | B |----| amix.z</font></i>
<i><font color="#FFFF00">// |   |   | C  |</font></i>
<i><font color="#FFFF00">// --------------</font></i>
<i><font color="#FFFF00">//   amix.x amix.y</font></i>
<b><font color="0000BB">void</font></b> trace_Split4b_xxy( <b><font color="0000BB">inout</font></b> Ranges_x4 ret, Ray ray, <b><font color="0000BB">in</font></b> Split4bSetup set, <b><font color="0000BB">vec3</font></b> amix, <b><font color="0000BB">vec4</font></b> h )
{
  <b><font color="0000BB">vec3</font></b> set_dmix = ( amix - ray.o.xxy ) * set.drcp.xxy; <i><font color="#FFFF00">// split axis described in amix are x,x,y</font></i>
  ret.rA = intersect_ranges( <b><font color="0000BB">vec3</font></b>( set.dmin.x, set.dmin.y, -set.dz ) + set.dmargin, <b><font color="0000BB">vec3</font></b>( set_dmix.x, set.dmax.y, h.x * set.drcp.z - set.dz ) - set.dmargin );
  ret.rB = intersect_ranges( <b><font color="0000BB">vec3</font></b>( set_dmix.x, set.dmin.y, -set.dz ) + set.dmargin, <b><font color="0000BB">vec3</font></b>( set_dmix.y, set.dmax.y, h.y * set.drcp.z - set.dz ) - set.dmargin );
  ret.rC = intersect_ranges( <b><font color="0000BB">vec3</font></b>( set_dmix.y, set.dmin.y, -set.dz ) + set.dmargin, <b><font color="0000BB">vec3</font></b>( set.dmax.x, set_dmix.z, h.z * set.drcp.z - set.dz ) - set.dmargin );
  ret.rD = intersect_ranges( <b><font color="0000BB">vec3</font></b>( set_dmix.y, set_dmix.z, -set.dz ) + set.dmargin, <b><font color="0000BB">vec3</font></b>( set.dmax.x, set.dmax.y, h.w * set.drcp.z - set.dz ) - set.dmargin );
}
<b><font color="0000BB">void</font></b> bound_Split4b_xxy( <b><font color="0000BB">inout</font></b> Ranges_x4 ret, Ray ray, <b><font color="0000BB">vec2</font></b> amin, <b><font color="0000BB">vec2</font></b> amax, <b><font color="0000BB">vec3</font></b> amix, <b><font color="0000BB">vec4</font></b> h, <b><font color="0000BB">vec2</font></b> margin )
{
  <b><font color="0000BB">vec3</font></b> m = <b><font color="0000BB">vec3</font></b>( margin, <font color="#0077BB">0</font>. );
  ret.bA = mkbounds_unchecked( <b><font color="0000BB">vec3</font></b>( amin.x, amin.y, <font color="#0077BB">0</font>. ) + m, <b><font color="0000BB">vec3</font></b>( amix.x, amax.y, h.x ) - m );
  ret.bB = mkbounds_unchecked( <b><font color="0000BB">vec3</font></b>( amix.x, amin.y, <font color="#0077BB">0</font>. ) + m, <b><font color="0000BB">vec3</font></b>( amix.y, amax.y, h.y ) - m );
  ret.bC = mkbounds_unchecked( <b><font color="0000BB">vec3</font></b>( amix.y, amin.y, <font color="#0077BB">0</font>. ) + m, <b><font color="0000BB">vec3</font></b>( amax.x, amix.z, h.z ) - m );
  ret.bD = mkbounds_unchecked( <b><font color="0000BB">vec3</font></b>( amix.y, amix.z, <font color="#0077BB">0</font>. ) + m, <b><font color="0000BB">vec3</font></b>( amax.x, amax.y, h.w ) - m );
}
<i><font color="#FFFF00">// -----------------</font></i>
<i><font color="#FFFF00">// |   |   |   |   |</font></i>
<i><font color="#FFFF00">// | A | B | C | D |</font></i>
<i><font color="#FFFF00">// |   |   |   |   |</font></i>
<i><font color="#FFFF00">// -----------------</font></i>
<i><font color="#FFFF00">//   amix.x amix.y amix.z</font></i>
<b><font color="0000BB">void</font></b> trace_Split4b_xxx( <b><font color="0000BB">inout</font></b> Ranges_x4 ret, Ray ray, <b><font color="0000BB">in</font></b> Split4bSetup set, <b><font color="0000BB">vec3</font></b> amix, <b><font color="0000BB">vec4</font></b> h )
{
  <b><font color="0000BB">vec3</font></b> set_dmix = ( amix - ray.o.xxx ) * set.drcp.xxx; <i><font color="#FFFF00">// split axis described in amix are x,x,x</font></i>
  ret.rA = intersect_ranges( <b><font color="0000BB">vec3</font></b>( set.dmin.x, set.dmin.y, -set.dz ) + set.dmargin, <b><font color="0000BB">vec3</font></b>( set_dmix.x, set.dmax.y, h.x * set.drcp.z - set.dz ) - set.dmargin );
  ret.rB = intersect_ranges( <b><font color="0000BB">vec3</font></b>( set_dmix.x, set.dmin.y, -set.dz ) + set.dmargin, <b><font color="0000BB">vec3</font></b>( set_dmix.y, set.dmax.y, h.y * set.drcp.z - set.dz ) - set.dmargin );
  ret.rC = intersect_ranges( <b><font color="0000BB">vec3</font></b>( set_dmix.y, set.dmin.y, -set.dz ) + set.dmargin, <b><font color="0000BB">vec3</font></b>( set_dmix.z, set.dmax.y, h.z * set.drcp.z - set.dz ) - set.dmargin );
  ret.rD = intersect_ranges( <b><font color="0000BB">vec3</font></b>( set_dmix.z, set.dmin.y, -set.dz ) + set.dmargin, <b><font color="0000BB">vec3</font></b>( set.dmax.x, set.dmax.y, h.w * set.drcp.z - set.dz ) - set.dmargin );
}
<b><font color="0000BB">void</font></b> bound_Split4b_xxx( <b><font color="0000BB">inout</font></b> Ranges_x4 ret, Ray ray, <b><font color="0000BB">vec2</font></b> amin, <b><font color="0000BB">vec2</font></b> amax, <b><font color="0000BB">vec3</font></b> amix, <b><font color="0000BB">vec4</font></b> h, <b><font color="0000BB">vec2</font></b> margin )
{
  <b><font color="0000BB">vec3</font></b> m = <b><font color="0000BB">vec3</font></b>( margin, <font color="#0077BB">0</font>. );
  ret.bA = mkbounds_unchecked( <b><font color="0000BB">vec3</font></b>( amin.x, amin.y, <font color="#0077BB">0</font>. ) + m, <b><font color="0000BB">vec3</font></b>( amix.x, amax.y, h.x ) - m );
  ret.bB = mkbounds_unchecked( <b><font color="0000BB">vec3</font></b>( amix.x, amin.y, <font color="#0077BB">0</font>. ) + m, <b><font color="0000BB">vec3</font></b>( amix.y, amax.y, h.y ) - m );
  ret.bC = mkbounds_unchecked( <b><font color="0000BB">vec3</font></b>( amix.y, amin.y, <font color="#0077BB">0</font>. ) + m, <b><font color="0000BB">vec3</font></b>( amix.z, amax.y, h.z ) - m );
  ret.bD = mkbounds_unchecked( <b><font color="0000BB">vec3</font></b>( amix.z, amin.y, <font color="#0077BB">0</font>. ) + m, <b><font color="0000BB">vec3</font></b>( amax.x, amax.y, h.w ) - m );
}
<i><font color="#FFFF00">//        -----------</font></i>
<i><font color="#FFFF00">//        |  C |    |</font></i>
<i><font color="#FFFF00">// amix.y |----| D  |</font></i>
<i><font color="#FFFF00">//        |  A |----| amix.z</font></i>
<i><font color="#FFFF00">//        |    | B  |</font></i>
<i><font color="#FFFF00">//        -----------</font></i>
<i><font color="#FFFF00">//           amix.x</font></i>
<b><font color="0000BB">void</font></b> trace_Split4b_xyy( <b><font color="0000BB">inout</font></b> Ranges_x4 ret, Ray ray, <b><font color="0000BB">in</font></b> Split4bSetup set, <b><font color="0000BB">vec3</font></b> amix, <b><font color="0000BB">vec4</font></b> h )
{
  <b><font color="0000BB">vec3</font></b> set_dmix = ( amix - ray.o.xyy ) * set.drcp.xyy; <i><font color="#FFFF00">// split axis described in amix are x,x,y</font></i>
  ret.rA = intersect_ranges( <b><font color="0000BB">vec3</font></b>( set.dmin.x, set.dmin.y, -set.dz ) + set.dmargin, <b><font color="0000BB">vec3</font></b>( set_dmix.x, set_dmix.y, h.x * set.drcp.z - set.dz ) - set.dmargin );
  ret.rB = intersect_ranges( <b><font color="0000BB">vec3</font></b>( set_dmix.x, set.dmin.y, -set.dz ) + set.dmargin, <b><font color="0000BB">vec3</font></b>( set.dmax.x, set_dmix.z, h.y * set.drcp.z - set.dz ) - set.dmargin );
  ret.rC = intersect_ranges( <b><font color="0000BB">vec3</font></b>( set.dmin.x, set_dmix.y, -set.dz ) + set.dmargin, <b><font color="0000BB">vec3</font></b>( set_dmix.x, set.dmax.y, h.z * set.drcp.z - set.dz ) - set.dmargin );
  ret.rD = intersect_ranges( <b><font color="0000BB">vec3</font></b>( set_dmix.x, set_dmix.z, -set.dz ) + set.dmargin, <b><font color="0000BB">vec3</font></b>( set.dmax.x, set.dmax.y, h.w * set.drcp.z - set.dz ) - set.dmargin );
}
<b><font color="0000BB">void</font></b> bound_Split4b_xyy( <b><font color="0000BB">inout</font></b> Ranges_x4 ret, Ray ray, <b><font color="0000BB">vec2</font></b> amin, <b><font color="0000BB">vec2</font></b> amax, <b><font color="0000BB">vec3</font></b> amix, <b><font color="0000BB">vec4</font></b> h, <b><font color="0000BB">vec2</font></b> margin )
{
  <b><font color="0000BB">vec3</font></b> m = <b><font color="0000BB">vec3</font></b>( margin, <font color="#0077BB">0</font>. );
  ret.bA = mkbounds_unchecked( <b><font color="0000BB">vec3</font></b>( amin.x, amin.y, <font color="#0077BB">0</font>. ) + m, <b><font color="0000BB">vec3</font></b>( amix.x, amix.y, h.x ) - m );
  ret.bB = mkbounds_unchecked( <b><font color="0000BB">vec3</font></b>( amix.x, amin.y, <font color="#0077BB">0</font>. ) + m, <b><font color="0000BB">vec3</font></b>( amax.x, amix.z, h.y ) - m );
  ret.bC = mkbounds_unchecked( <b><font color="0000BB">vec3</font></b>( amin.x, amix.y, <font color="#0077BB">0</font>. ) + m, <b><font color="0000BB">vec3</font></b>( amix.x, amax.y, h.z ) - m );
  ret.bD = mkbounds_unchecked( <b><font color="0000BB">vec3</font></b>( amix.x, amix.z, <font color="#0077BB">0</font>. ) + m, <b><font color="0000BB">vec3</font></b>( amax.x, amax.y, h.w ) - m );
}
<i><font color="#FFFF00">//  -------------</font></i>
<i><font color="#FFFF00">//  |   | D |   |</font></i>
<i><font color="#FFFF00">//  |   |   |   |</font></i>
<i><font color="#FFFF00">//  | A |---| C | amix.y</font></i>
<i><font color="#FFFF00">//  |   | B |   |</font></i>
<i><font color="#FFFF00">//  -------------</font></i>
<i><font color="#FFFF00">//  amix.x amix.z</font></i>
<b><font color="0000BB">void</font></b> trace_Split4b_xyx( <b><font color="0000BB">inout</font></b> Ranges_x4 ret, Ray ray, <b><font color="0000BB">in</font></b> Split4bSetup set, <b><font color="0000BB">vec3</font></b> amix, <b><font color="0000BB">vec4</font></b> h )
{
  <b><font color="0000BB">vec3</font></b> set_dmix = ( amix - ray.o.xyx ) * set.drcp.xyx; <i><font color="#FFFF00">// split axis described in amix are x,x,y</font></i>
  ret.rA = intersect_ranges( <b><font color="0000BB">vec3</font></b>( set.dmin.x, set.dmin.y, -set.dz ) + set.dmargin, <b><font color="0000BB">vec3</font></b>( set_dmix.x, set.dmax.y, h.x * set.drcp.z - set.dz ) - set.dmargin );
  ret.rB = intersect_ranges( <b><font color="0000BB">vec3</font></b>( set_dmix.x, set.dmin.y, -set.dz ) + set.dmargin, <b><font color="0000BB">vec3</font></b>( set_dmix.z, set_dmix.y, h.y * set.drcp.z - set.dz ) - set.dmargin );
  ret.rC = intersect_ranges( <b><font color="0000BB">vec3</font></b>( set_dmix.z, set.dmin.y, -set.dz ) + set.dmargin, <b><font color="0000BB">vec3</font></b>( set.dmax.x, set.dmax.y, h.z * set.drcp.z - set.dz ) - set.dmargin );
  ret.rD = intersect_ranges( <b><font color="0000BB">vec3</font></b>( set_dmix.x, set_dmix.y, -set.dz ) + set.dmargin, <b><font color="0000BB">vec3</font></b>( set_dmix.z, set.dmax.y, h.w * set.drcp.z - set.dz ) - set.dmargin );
}
<b><font color="0000BB">void</font></b> bound_Split4b_xyx( <b><font color="0000BB">inout</font></b> Ranges_x4 ret, Ray ray, <b><font color="0000BB">vec2</font></b> amin, <b><font color="0000BB">vec2</font></b> amax, <b><font color="0000BB">vec3</font></b> amix, <b><font color="0000BB">vec4</font></b> h, <b><font color="0000BB">vec2</font></b> margin )
{
  <b><font color="0000BB">vec3</font></b> m = <b><font color="0000BB">vec3</font></b>( margin, <font color="#0077BB">0</font>. );
  ret.bA = mkbounds_unchecked( <b><font color="0000BB">vec3</font></b>( amin.x, amin.y, <font color="#0077BB">0</font>. ) + m, <b><font color="0000BB">vec3</font></b>( amix.x, amax.y, h.x ) - m );
  ret.bB = mkbounds_unchecked( <b><font color="0000BB">vec3</font></b>( amix.x, amin.y, <font color="#0077BB">0</font>. ) + m, <b><font color="0000BB">vec3</font></b>( amix.z, amix.y, h.y ) - m );
  ret.bC = mkbounds_unchecked( <b><font color="0000BB">vec3</font></b>( amix.z, amin.y, <font color="#0077BB">0</font>. ) + m, <b><font color="0000BB">vec3</font></b>( amax.x, amax.y, h.z ) - m );
  ret.bD = mkbounds_unchecked( <b><font color="0000BB">vec3</font></b>( amix.x, amix.y, <font color="#0077BB">0</font>. ) + m, <b><font color="0000BB">vec3</font></b>( amix.z, amax.y, h.w ) - m );
}
<i><font color="#FFFF00">// turn n relative sizes (unit don't matter, only respective sizes do) into n-1 unit size offsets</font></i>
<b><font color="0000BB">vec2</font></b> fractions( <b><font color="0000BB">vec3</font></b> r ) {
  <b><font color="0000BB">float</font></b> sum_f_xy = r.x + r.y;
  <b><font color="0000BB">float</font></b> sum_f_xyz = sum_f_xy + r.z;
  <b><font color="0000BB">return</font></b> <b><font color="0000BB">vec2</font></b>( r.x, sum_f_xy ) / sum_f_xyz;
}
<b><font color="0000BB">vec3</font></b> fractions( <b><font color="0000BB">vec4</font></b> r ) {
  <b><font color="0000BB">float</font></b> sum_f_xy = r.x + r.y;
  <b><font color="0000BB">float</font></b> sum_f_xyz = sum_f_xy + r.z;
  <b><font color="0000BB">float</font></b> sum_f_xyzw = sum_f_xyz + r.w;
  <b><font color="0000BB">return</font></b> <b><font color="0000BB">vec3</font></b>( r.x, sum_f_xy, sum_f_xyz ) / sum_f_xyzw;
}
<i><font color="#FFFF00">// -------------------------------------------------------- shader begin</font></i>
<b><font color="0000BB">float</font></b> sd_SurfaceFacade7( <b><font color="0000BB">vec3</font></b> p, <b><font color="0000BB">float</font></b> dAll )
{
  dAll -= -<font color="#0077BB">0</font>.<font color="#0077BB">142857149</font>;
  <b><font color="0000BB">vec3</font></b> _p1 = p; <b><font color="0000BB">vec2</font></b> _ci1 = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">649999976</font>, <font color="#0077BB">0</font>.<font color="#0077BB">375</font> ); <b><font color="0000BB">vec2</font></b> _hp1 = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">625</font>, <font color="#0077BB">0</font>.<font color="#0077BB">300000011</font> ); <b><font color="0000BB">vec2</font></b> _hw1 = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">150000005</font>, <font color="#0077BB">0</font>.<font color="#0077BB">074999988</font> ); <b><font color="0000BB">vec2</font></b> _2hp1_rcp = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">800000011</font>, <font color="#0077BB">1</font>.<font color="#0077BB">666666626</font> ); _p1.xy -= _ci1; _p1.xy = -tri_p( _p1.xy, _hw1, _hp1 ); <b><font color="0000BB">float</font></b> _d1 = maxcomp( _p1.xy ); _d1 = opI( _d1, opB_range( p.z, -<font color="#0077BB">0</font>.<font color="#0077BB">171428576</font>, <font color="#0077BB">0</font>. ) );
  <b><font color="0000BB">vec3</font></b> _p2 = p; <b><font color="0000BB">vec2</font></b> _ci2 = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">400000005</font>, <font color="#0077BB">0</font>.<font color="#0077BB">234999999</font> ); <b><font color="0000BB">vec2</font></b> _hp2 = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">5</font>, <font color="#0077BB">0</font>.<font color="#0077BB">300000011</font> ); <b><font color="0000BB">vec2</font></b> _hw2 = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">400000005</font>, <font color="#0077BB">0</font>.<font color="#0077BB">015</font> ); <b><font color="0000BB">vec2</font></b> _2hp2_rcp = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">1</font>, <font color="#0077BB">1</font>.<font color="#0077BB">666666626</font> ); _p2.xy -= _ci2; <b><font color="0000BB">float</font></b> _d2 = -tri_p( _p2.y, <font color="#0077BB">0</font>.<font color="#0077BB">015</font>, <font color="#0077BB">0</font>.<font color="#0077BB">300000011</font> ); _d2 = opI( _d2, opB_range( p.z, -<font color="#0077BB">0</font>.<font color="#0077BB">142857149</font>, -<font color="#0077BB">0</font>.<font color="#0077BB">128571435</font> ) );
  dAll = opS_hard_bevel( dAll, _d1, <font color="#0077BB">0</font>.<font color="#0077BB">007805752</font> );
  dAll = opU( dAll, _d2 );
  <b><font color="0000BB">return</font></b> dAll;
}
<b><font color="0000BB">float</font></b> sd_SurfaceFacade10( <b><font color="0000BB">vec3</font></b> p, <b><font color="0000BB">float</font></b> dAll )
{
  <b><font color="0000BB">vec3</font></b> _p1 = p; <b><font color="0000BB">vec2</font></b> _ci1 = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">570779979</font>, <font color="#0077BB">0</font>.<font color="#0077BB">031555999</font> ); <b><font color="0000BB">vec2</font></b> _hp1 = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">569999992</font>, <font color="#0077BB">0</font>.<font color="#0077BB">029999999</font> ); <b><font color="0000BB">vec2</font></b> _hw1 = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">560779988</font>, <font color="#0077BB">0</font>.<font color="#0077BB">021556001</font> ); <b><font color="0000BB">vec2</font></b> _2hp1_rcp = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">877192974</font>, <font color="#0077BB">16</font>.<font color="#0077BB">666667938</font> ); _p1.xy -= _ci1; _p1.xy = -tri_p( _p1.xy, _hw1, _hp1 ); <b><font color="0000BB">float</font></b> _d1 = maxcomp( _p1.xy ); _d1 = opI( _d1, opB_range( p.z, -<font color="#0077BB">0</font>.<font color="#0077BB">028571428</font>, <font color="#0077BB">0</font>.<font color="#0077BB">100000001</font> ) );
  dAll = opS_hard_bevel( dAll, _d1, <font color="#0077BB">0</font>.<font color="#0077BB">003604186</font> );
  <b><font color="0000BB">return</font></b> dAll; <i><font color="#FFFF00">// return vec3(dAll,-0.028571428,0.100000001);</font></i>
}
<b><font color="0000BB">vec2</font></b> sd_SurfaceFacade0( <b><font color="0000BB">vec3</font></b> p, <b><font color="0000BB">float</font></b> dAll )
{
  dAll -= -<font color="#0077BB">0</font>.<font color="#0077BB">100000001</font>;
  <b><font color="0000BB">vec3</font></b> _p2 = p; <b><font color="0000BB">vec2</font></b> _ci2 = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">25</font>, <font color="#0077BB">0</font>.<font color="#0077BB">362500011</font> ); <b><font color="0000BB">vec2</font></b> _hp2 = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">1</font>., <font color="#0077BB">0</font>.<font color="#0077BB">300000011</font> ); <b><font color="0000BB">vec2</font></b> _hw2 = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">75</font>, <font color="#0077BB">0</font>.<font color="#0077BB">137500002</font> ); <b><font color="0000BB">vec2</font></b> _2hp2_rcp = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">5</font>, <font color="#0077BB">1</font>.<font color="#0077BB">666666626</font> ); _p2.xy -= _ci2; _p2.xy = -tri_p( _p2.xy, _hw2, _hp2 ); <b><font color="0000BB">float</font></b> _d2 = maxcomp( _p2.xy ); _d2 = opI( _d2, opB_range( p.z, -<font color="#0077BB">0</font>.<font color="#0077BB">200000002</font>, <font color="#0077BB">0</font>. ) );
  <b><font color="0000BB">vec3</font></b> _p3 = p; <b><font color="0000BB">vec2</font></b> _ci3 = <b><font color="0000BB">vec2</font></b>( -<font color="#0077BB">0</font>.<font color="#0077BB">75</font>, <font color="#0077BB">0</font>.<font color="#0077BB">300000011</font> ); <b><font color="0000BB">vec2</font></b> _hp3 = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">1</font>., <font color="#0077BB">0</font>.<font color="#0077BB">300000011</font> ); <b><font color="0000BB">vec2</font></b> _hw3 = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">112500011</font>, <font color="#0077BB">0</font>.<font color="#0077BB">300000011</font> ); <b><font color="0000BB">vec2</font></b> _2hp3_rcp = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">5</font>, <font color="#0077BB">1</font>.<font color="#0077BB">666666626</font> ); _p3.xy -= _ci3; <b><font color="0000BB">float</font></b> _d3 = -tri_p( _p3.x, <font color="#0077BB">0</font>.<font color="#0077BB">112500011</font>, <font color="#0077BB">1</font>. ); _d3 = opI( _d3, opB_range( p.z, -<font color="#0077BB">0</font>.<font color="#0077BB">200000002</font>, <font color="#0077BB">0</font>. ) );
  <b><font color="0000BB">vec3</font></b> _p1 = p; <b><font color="0000BB">vec2</font></b> _ci1 = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">75</font>, <font color="#0077BB">0</font>.<font color="#0077BB">362499982</font> ); <b><font color="0000BB">vec2</font></b> _hp1 = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">25</font>, <font color="#0077BB">0</font>.<font color="#0077BB">300000011</font> ); <b><font color="0000BB">vec2</font></b> _hw1 = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">25</font>, <font color="#0077BB">0</font>.<font color="#0077BB">147500008</font> ); <b><font color="0000BB">vec2</font></b> _2hp1_rcp = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">2</font>, <font color="#0077BB">1</font>.<font color="#0077BB">666666626</font> ); _p1.xy -= _ci1; _p1.xy = -tri_p( _p1.xy, _hw1, _hp1 ); <b><font color="0000BB">float</font></b> _d1 = maxcomp( _p1.xy ); /*band*/_d1 = opB_rc( _d1, <font color="#0077BB">0</font>.<font color="#0077BB">008236314</font>, <font color="#0077BB">0</font>.<font color="#0077BB">0</font> ); _d1 = opI( _d1, opB_range( p.z, -<font color="#0077BB">0</font>.<font color="#0077BB">200000002</font>, -<font color="#0077BB">0</font>.<font color="#0077BB">19428572</font> ) );
  dAll = opS_hard_bevel( dAll, _d2, <font color="#0077BB">0</font>.<font color="#0077BB">007714285</font> );
  dAll = opU_hard_bevel( dAll, _d3, <font color="#0077BB">0</font>.<font color="#0077BB">009999996</font> );
  dAll = opU_hard_bevel( dAll, _d1, <font color="#0077BB">0</font>.<font color="#0077BB">005900437</font> );
  <b><font color="0000BB">return</font></b> <b><font color="0000BB">vec2</font></b>( dAll, p.z + <font color="#0077BB">0</font>.<font color="#0077BB">200000002</font> ); <i><font color="#FFFF00">// return vec3(dAll,0,0.200000002);</font></i>
}
<b><font color="0000BB">vec2</font></b> sd_SurfaceFacade8( <b><font color="0000BB">vec3</font></b> p, <b><font color="0000BB">float</font></b> dAll )
{
  <b><font color="0000BB">vec3</font></b> _p3 = p; <b><font color="0000BB">vec2</font></b> _ci3 = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">200000002</font>, <font color="#0077BB">0</font>.<font color="#0077BB">685000002</font> ); <b><font color="0000BB">vec2</font></b> _hp3 = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">354999989</font>, <font color="#0077BB">0</font>.<font color="#0077BB">459999978</font> ); <b><font color="0000BB">vec2</font></b> _hw3 = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">149999991</font>, <font color="#0077BB">0</font>.<font color="#0077BB">115000009</font> ); <b><font color="0000BB">vec2</font></b> _2hp3_rcp = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">1</font>.<font color="#0077BB">408450722</font>, <font color="#0077BB">1</font>.<font color="#0077BB">08695662</font> ); _p3.xy -= _ci3; _p3.xy = -tri_p( _p3.xy, _hw3, _hp3 ); <b><font color="0000BB">float</font></b> _d3 = maxcomp( _p3.xy ); _d3 = opI( _d3, opB_range( p.z, -<font color="#0077BB">0</font>.<font color="#0077BB">057142857</font>, <font color="#0077BB">0</font>.<font color="#0077BB">014285714</font> ) );
  <b><font color="0000BB">vec3</font></b> _p1 = p; <b><font color="0000BB">vec2</font></b> _ci1 = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">200000002</font>, <font color="#0077BB">0</font>.<font color="#0077BB">685000002</font> ); <b><font color="0000BB">vec2</font></b> _hp1 = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">354999989</font>, <font color="#0077BB">0</font>.<font color="#0077BB">459999978</font> ); <b><font color="0000BB">vec2</font></b> _hw1 = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">149999991</font>, <font color="#0077BB">0</font>.<font color="#0077BB">115000009</font> ); <b><font color="0000BB">vec2</font></b> _2hp1_rcp = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">1</font>.<font color="#0077BB">408450722</font>, <font color="#0077BB">1</font>.<font color="#0077BB">08695662</font> ); _p1.xy -= _ci1; _p1.xy = -tri_p( _p1.xy, _hw1, _hp1 ); <b><font color="0000BB">float</font></b> _d1 = maxcomp( _p1.xy ); /*band*/_d1 = opB_rc( _d1, <font color="#0077BB">0</font>.<font color="#0077BB">002559998</font>, <font color="#0077BB">0</font>.<font color="#0077BB">0</font> ); _d1 = opI( _d1, opB_range( p.z, -<font color="#0077BB">0</font>.<font color="#0077BB">071428574</font>, <font color="#0077BB">0</font>. ) );
  <b><font color="0000BB">vec3</font></b> _p2 = p; <b><font color="0000BB">vec2</font></b> _ci2 = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">287499994</font>, <font color="#0077BB">0</font>.<font color="#0077BB">684999942</font> ); <b><font color="0000BB">vec2</font></b> _hp2 = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">354999989</font>, <font color="#0077BB">0</font>.<font color="#0077BB">459999978</font> ); <b><font color="0000BB">vec2</font></b> _hw2 = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">057500004</font>, <font color="#0077BB">0</font>.<font color="#0077BB">109999984</font> ); <b><font color="0000BB">vec2</font></b> _2hp2_rcp = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">1</font>.<font color="#0077BB">408450722</font>, <font color="#0077BB">1</font>.<font color="#0077BB">08695662</font> ); _p2.xy -= _ci2; _p2.xy = -tri_p( _p2.xy, _hw2, _hp2 ); <b><font color="0000BB">float</font></b> _d2 = maxcomp( _p2.xy ); /*band*/_d2 = opB_rc( _d2, <font color="#0077BB">0</font>.<font color="#0077BB">003154247</font>, <font color="#0077BB">0</font>.<font color="#0077BB">0</font> ); _d2 = opI( _d2, opB_range( p.z, -<font color="#0077BB">0</font>.<font color="#0077BB">085714288</font>, -<font color="#0077BB">0</font>.<font color="#0077BB">028571428</font> ) );
  dAll = opS_hard_bevel( dAll, _d3, <font color="#0077BB">0</font>.<font color="#0077BB">000975659</font> );
  dAll = opU_hard_bevel( dAll, _d1, <font color="#0077BB">0</font>.<font color="#0077BB">000975659</font> );
  dAll = opU_hard_bevel( dAll, _d2, <font color="#0077BB">0</font>.<font color="#0077BB">000138338</font> );
  <b><font color="0000BB">return</font></b> <b><font color="0000BB">vec2</font></b>( dAll, p.z + <font color="#0077BB">0</font>.<font color="#0077BB">057142857</font> ); <i><font color="#FFFF00">// return vec3(dAll,-0.085714288,0.014285714);</font></i>
}
<i><font color="#FFFF00">// function used to make roof tiles</font></i>
<i><font color="#FFFF00">// a1 is the slope of curve going up (1.)</font></i>
<i><font color="#FFFF00">// a2 is the slope of curve going down (-2.)</font></i>
<i><font color="#FFFF00">// p is the period</font></i>
<b><font color="0000BB">float</font></b> hard_waves( <b><font color="0000BB">float</font></b> x, <b><font color="0000BB">float</font></b> a1, <b><font color="0000BB">float</font></b> a2, <b><font color="0000BB">float</font></b> p ) {
  x = repeat( x, p );
  x = min( a1 * x, a2 * x - a2 * p );
  <b><font color="0000BB">return</font></b> x;
}
<i><font color="#FFFF00">// roof tiles height field (hf)</font></i>
<b><font color="0000BB">float</font></b> hf_SurfaceRoofTiles( <b><font color="0000BB">vec2</font></b> p ) {
  <b><font color="0000BB">return</font></b> ( <font color="#0077BB">0</font>.<font color="#0077BB">4</font> * hard_waves( p.y, <font color="#0077BB">0</font>.<font color="#0077BB">3</font>, -<font color="#0077BB">1</font>.<font color="#0077BB">6</font>, <font color="#0077BB">0</font>.<font color="#0077BB">19</font> ) + <font color="#0077BB">0</font>.<font color="#0077BB">02</font> * abs( sin( p.x * <font color="#0077BB">30</font>. ) ) );
}
<i><font color="#FFFF00">// build diagonal scopes on the top edges of a bounds b "extruded" by h</font></i>
<i><font color="#FFFF00">// they can be used as support planes for roof surface</font></i>
<i><font color="#FFFF00">// return value is a 3d point local to those symetrized diagonal plane spaces, that can be used to map the roof surface</font></i>
<i><font color="#FFFF00">// return value's .z is the distance to plane</font></i>
<i><font color="#FFFF00">// slope_ctrl controls the steepness of the roof planes, 1. for identity</font></i>
<i><font color="#FFFF00">// h is height of base house walls</font></i>
<i><font color="#FFFF00">// b is base/ground 2d scope bounds</font></i>
<i><font color="#FFFF00">// p is input world pos</font></i>
<i><font color="#FFFF00">// we don't return a scope because we are mirroring things here, Scope's .b and .dcc would have no sense</font></i>
<b><font color="0000BB">vec3</font></b> getRoofLocalX( <b><font color="0000BB">vec3</font></b> p, <b><font color="0000BB">float</font></b> slope_ctrl, bounds2 b, <b><font color="0000BB">float</font></b> h )
{
  <i><font color="#FFFF00">// gable roof with tiled surface</font></i>
  <b><font color="0000BB">float</font></b> hw = ( b.pmax.x - b.pmin.x ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>; <i><font color="#FFFF00">// half width</font></i>
  <b><font color="0000BB">float</font></b> cx = ( b.pmax.x + b.pmin.x ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>; <i><font color="#FFFF00">// center</font></i>
  <b><font color="0000BB">float</font></b> h2 = hw * slope_ctrl; <i><font color="#FFFF00">// roof height</font></i>
  <b><font color="0000BB">vec2</font></b> v = <b><font color="0000BB">vec2</font></b>( abs( p.x - cx ), p.z - ( h + h2 ) );
  <b><font color="0000BB">vec2</font></b> yy = normalize( <b><font color="0000BB">vec2</font></b>( hw, -h2 ) );
  <b><font color="0000BB">return</font></b> <b><font color="0000BB">vec3</font></b>( p.y, dot( v, yy ), dot( v, perp( yy ) ) );
}
<b><font color="0000BB">vec3</font></b> getRoofLocalY( <b><font color="0000BB">vec3</font></b> p, <b><font color="0000BB">float</font></b> slope_ctrl, bounds2 b, <b><font color="0000BB">float</font></b> h )
{
  <i><font color="#FFFF00">// gable roof with tiled surface</font></i>
  <b><font color="0000BB">float</font></b> hw = ( b.pmax.y - b.pmin.y ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>; <i><font color="#FFFF00">// half width</font></i>
  <b><font color="0000BB">float</font></b> cy = ( b.pmax.y + b.pmin.y ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>; <i><font color="#FFFF00">// center</font></i>
  <b><font color="0000BB">float</font></b> h2 = hw * slope_ctrl; <i><font color="#FFFF00">// roof height</font></i>
  <b><font color="0000BB">vec2</font></b> v = <b><font color="0000BB">vec2</font></b>( abs( p.y - cy ), p.z - ( h + h2 ) );
  <b><font color="0000BB">vec2</font></b> yy = normalize( <b><font color="0000BB">vec2</font></b>( hw, -h2 ) );
  <b><font color="0000BB">return</font></b> <b><font color="0000BB">vec3</font></b>( p.x, dot( v, yy ), dot( v, perp( yy ) ) );
}
<i><font color="#FFFF00">// rudimentary concept of "scope" for facade, roof surfaces etc.</font></i>
<b><font color="0000BB">struct</font></b> Scope
{
  <b><font color="0000BB">vec3</font></b> p; <i><font color="#FFFF00">// point in scope space, plane at p.z = 0</font></i>
  bounds2 b; <i><font color="#FFFF00">// bounds of scope shape, for clipping/shape cast</font></i>
  <b><font color="0000BB">float</font></b> dcc; <i><font color="#FFFF00">// df of scope shape ("cookie cutter"), for clipping/shape cast, should be included in .b for consistancy</font></i>
  <b><font color="0000BB">float</font></b> t; <i><font color="#FFFF00">// marching distance, used for error thresholds, "inflating" detail etc.</font></i>
};
Scope getScopeFacadeX( Scope base, <b><font color="0000BB">float</font></b> h, <b><font color="0000BB">int</font></b> select_side )
{
  Scope facade;
  facade.b = mkbounds_unchecked( <b><font color="0000BB">vec2</font></b>( base.b.pmin.y, <font color="#0077BB">0</font>.<font color="#0077BB">0</font> ), <b><font color="0000BB">vec2</font></b>( base.b.pmax.y, h ) );
  <i><font color="#FFFF00">// note: we just flip the sign of p.x for the other side, it will horizontally flip the content but most often we don't care</font></i>
  <b><font color="0000BB">if</font></b> ( select_side == ( <font color="#0077BB">1</font> | <font color="#0077BB">2</font> ) ) facade.p = <b><font color="0000BB">vec3</font></b>( base.p.y, base.p.z, abs( base.p.x - center( base.b ).x ) - size( base.b ).x * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> );
  <b><font color="0000BB">else</font></b> <b><font color="0000BB">if</font></b> ( select_side == <font color="#0077BB">1</font> ) facade.p = <b><font color="0000BB">vec3</font></b>( base.p.y, base.p.z, base.p.x - base.b.pmax.x );
  <b><font color="0000BB">else</font></b> <b><font color="0000BB">if</font></b> ( select_side == <font color="#0077BB">2</font> ) facade.p = <b><font color="0000BB">vec3</font></b>( base.p.y, base.p.z, -base.p.x + base.b.pmin.x );
  facade.dcc = sd_bounds( facade.p.xy, facade.b );
  <b><font color="0000BB">return</font></b> facade;
}
Scope getScopeFacadeY( Scope base, <b><font color="0000BB">float</font></b> h, <b><font color="0000BB">int</font></b> select_side )
{
  Scope facade;
  facade.b = mkbounds_unchecked( <b><font color="0000BB">vec2</font></b>( base.b.pmin.x, <font color="#0077BB">0</font>.<font color="#0077BB">0</font> ), <b><font color="0000BB">vec2</font></b>( base.b.pmax.x, h ) );
  <i><font color="#FFFF00">// note: we just flip the sign of p.x for the other side, it will horizontally flip the content but most often we don't care</font></i>
  <b><font color="0000BB">if</font></b> ( select_side == ( <font color="#0077BB">1</font> | <font color="#0077BB">2</font> ) ) facade.p = <b><font color="0000BB">vec3</font></b>( base.p.x, base.p.z, abs( base.p.y - center( base.b ).y ) - size( base.b ).y * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> );
  <b><font color="0000BB">else</font></b> <b><font color="0000BB">if</font></b> ( select_side == <font color="#0077BB">1</font> ) facade.p = <b><font color="0000BB">vec3</font></b>( base.p.x, base.p.z, base.p.y - base.b.pmax.y );
  <b><font color="0000BB">else</font></b> <b><font color="0000BB">if</font></b> ( select_side == <font color="#0077BB">2</font> ) facade.p = <b><font color="0000BB">vec3</font></b>( base.p.x, base.p.z, -base.p.y + base.b.pmin.y );
  facade.dcc = sd_bounds( facade.p.xy, facade.b );
  <b><font color="0000BB">return</font></b> facade;
}
<b><font color="0000BB">float</font></b> sd_RoofTopObject2( <b><font color="0000BB">float</font></b> dsofar, Scope roof, <b><font color="0000BB">float</font></b> h, <b><font color="0000BB">vec3</font></b> rnd )
{
  h *= <font color="#0077BB">0</font>.<font color="#0077BB">6</font> + <font color="#0077BB">0</font>.<font color="#0077BB">4</font> * mod( rnd.y, <font color="#0077BB">4</font>. ) * ( <font color="#0077BB">1</font>. / <font color="#0077BB">3</font>.<font color="#0077BB">333</font> );
  <b><font color="0000BB">float</font></b> roof_geom_max_height = <font color="#0077BB">0</font>.<font color="#0077BB">025</font>; <i><font color="#FFFF00">// a rough but conservative estimate of roof geometry height</font></i>
  h = max( <font color="#0077BB">0</font>., h - roof_geom_max_height ); <i><font color="#FFFF00">// fixme: hack: make sure h is bounding height instead</font></i>
  <i><font color="#FFFF00">// select a small bounds b0 as a fraction of b, that we are going to repeat</font></i>
  bounds2 b0 = mkbounds_unchecked_gx( roof.b, <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">1</font>, <font color="#0077BB">0</font>.<font color="#0077BB">1</font> ), <b><font color="0000BB">vec2</font></b>( -<font color="#0077BB">0</font>.<font color="#0077BB">7</font>, -<font color="#0077BB">0</font>.<font color="#0077BB">7</font> ) );
  <i><font color="#FFFF00">// select a subgrid, range of b0 we want to keep, store range in b3</font></i>
  <b><font color="0000BB">vec2</font></b> gridsize = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">1</font>. + mod( rnd.x, <font color="#0077BB">4</font>. ), <font color="#0077BB">1</font>. );
  bounds2 b3 = mkbounds_unchecked_gx( b0, <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>., <font color="#0077BB">0</font>. ), gridsize - <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">1</font>. ) );
  <i><font color="#FFFF00">//  if ( dsofar < sd_bounds_range( roof.p, vec3( b3.pmin, 0. ), vec3( b3.pmax, h ) ) || roof.p.z < 0. ) return dsofar; // early return if the roof object is further than dsofar, not necesserarily a win...</font></i>
  <i><font color="#FFFF00">// inside that select a centered bounds b1</font></i>
  bounds2 b1 = mkbounds_unchecked_gx( b0, <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">1</font>, <font color="#0077BB">0</font>.<font color="#0077BB">1</font> ), <b><font color="0000BB">vec2</font></b>( -<font color="#0077BB">0</font>.<font color="#0077BB">1</font>, -<font color="#0077BB">0</font>.<font color="#0077BB">1</font> ) );
  <b><font color="0000BB">vec3</font></b> p2 = roof.p;
  p2.xy = repeat_b( p2.xy, b0 ); <i><font color="#FFFF00">// remember: b1 must be centered inside b0!</font></i>
  Scope base = roof;
  base.p = p2;
  base.b = b1;
  base.dcc = sd_bounds( base.p.xy, base.b );
  base.dcc = opI( base.dcc, sd_bounds( roof.p.xy, b3 ) ); <i><font color="#FFFF00">// only keep b3 area</font></i>
  <i><font color="#FFFF00">// select a subgrid (clip against)</font></i>
  <b><font color="0000BB">float</font></b> d = opI( base.p.z - h, base.dcc );
  d = opI( -base.p.z, d );
  <i><font color="#FFFF00">//  d = opI( d, sd_bounds( roof.p.xy, mkbounds_unchecked_gx( b0, vec2( 0, 0 ), vec2( 2, 1 ) ) ) );</font></i>
  {
    <i><font color="#FFFF00">// facade</font></i>
    Scope facade = getScopeFacadeY( base, h, <font color="#0077BB">3</font> );
    <b><font color="0000BB">vec3</font></b> p3 = facade.p;
    p3.xy *= <font color="#0077BB">2</font>.; <b><font color="0000BB">float</font></b> d2 = sd_SurfaceFacade10( p3, facade.p.z );
    d = opI( d2, d );
  }
  {
    <i><font color="#FFFF00">// roof small border wall on top of object</font></i>
    Scope roof2 = base;
    roof2.p.z -= h;
    <b><font color="0000BB">float</font></b> small_roof_border = opB_inside( roof2.dcc, <font color="#0077BB">0</font>.<font color="#0077BB">01</font> );
    small_roof_border = opI( small_roof_border, opB_inside( -roof2.p.z, roof_geom_max_height ) );
    d = opU( d, small_roof_border );
  }
  <b><font color="0000BB">return</font></b> opI( d, roof.dcc );
}
<b><font color="0000BB">float</font></b> sd_JPBuildingRoofTopWithObjects( <b><font color="0000BB">float</font></b> d, Scope roof, <b><font color="0000BB">float</font></b> roof_geom_max_height, <b><font color="0000BB">bool</font></b> enable_objects, <b><font color="0000BB">vec3</font></b> rnd )
{
  <i><font color="#FFFF00">// roof small border wall</font></i>
  <b><font color="0000BB">float</font></b> dborder = opB_inside( roof.dcc, <font color="#0077BB">0</font>.<font color="#0077BB">02</font> );
  dborder = opI( dborder, opB_inside( -roof.p.z, <font color="#0077BB">0</font>.<font color="#0077BB">05</font> ) );
  <i><font color="#FFFF00">// roof ground tiles, perhaps this should be textured but never mind. we get more detail</font></i>
  <b><font color="0000BB">float</font></b> tile_size = <font color="#0077BB">0</font>.<font color="#0077BB">05</font>;
  <b><font color="0000BB">float</font></b> dtiles = -mincomp( tri_s( roof.p.xy, <b><font color="0000BB">vec2</font></b>( tile_size * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> ), <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">005</font> ) ) );
  dtiles = opI( roof.dcc + <font color="#0077BB">0</font>.<font color="#0077BB">05</font>, dtiles ) + roof.t * <font color="#0077BB">0</font>.<font color="#0077BB">004</font>; <i><font color="#FFFF00">// add t in spacing so we can see it from far away</font></i>
  dtiles = opI_round_bevel( dtiles, opB_range( roof.p.z, -<font color="#0077BB">0</font>.<font color="#0077BB">001</font>, <font color="#0077BB">0</font>.<font color="#0077BB">0025</font> ), <font color="#0077BB">0</font>.<font color="#0077BB">00125</font>, <font color="#0077BB">0</font>.<font color="#0077BB">75</font> );
  d = opU( d, opU( dtiles, dborder ) );
  <b><font color="0000BB">if</font></b> ( enable_objects )
  {
    <i><font color="#FFFF00">// parametric model for small features on roof</font></i>
    Scope roof_object_scope = roof;
    <b><font color="0000BB">float</font></b> droof_object = /* FLT_MAX */<font color="#0077BB">1000000</font>.;
    droof_object = sd_RoofTopObject2( d, roof_object_scope, roof_geom_max_height, rnd );
    <i><font color="#FFFF00">//    droof_object = opI( droof_object, -roof.p.z ); // cut all the bits below roof object level</font></i>
    d = opU( d, droof_object );
  }
  <b><font color="0000BB">return</font></b> d;
}
<i><font color="#FFFF00">// distance to highway center line requires special care in this shader</font></i>
<b><font color="0000BB">struct</font></b> NearestHighwayRetval
{
  <b><font color="0000BB">vec2</font></b> p; <i><font color="#FFFF00">// query point</font></i>
  <b><font color="0000BB">vec2</font></b> pr; <i><font color="#FFFF00">// query point in y repeat space</font></i>
  <b><font color="0000BB">float</font></b> d; <i><font color="#FFFF00">// distance to center line == length(d2f.xy)</font></i>
  <b><font color="0000BB">vec4</font></b> d2f; <i><font color="#FFFF00">// .xy is vector to closest point, .zw is the tangent at closest point</font></i>
  <b><font color="0000BB">vec2</font></b> o_clip, n_clip; <i><font color="#FFFF00">// clip plane so we can build clean clip facades for buildings in contact with the highway</font></i>
};
<i><font color="#FFFF00">// building sdf eval return value</font></i>
<b><font color="0000BB">struct</font></b> ParametricBuildingRetval
{
  <b><font color="0000BB">float</font></b> d, droof; <i><font color="#FFFF00">// distance to building and distance to closest roof point for coloring</font></i>
  <b><font color="0000BB">vec3</font></b> windr; <i><font color="#FFFF00">// distance to window in .x, windows 2d orientation in .zw (orientation is for better categorizing of pixels)</font></i>
};
<i><font color="#FFFF00">// modern buildings, most often square but can be clipped by nearby highways</font></i>
ParametricBuildingRetval sd_Building( <b><font color="0000BB">float</font></b> t, <b><font color="0000BB">vec3</font></b> p, bounds2 b, <b><font color="0000BB">float</font></b> h, NearestHighwayRetval nh, <b><font color="0000BB">vec3</font></b> rnd )
{
  <b><font color="0000BB">float</font></b> roof_geom_max_height = <font color="#0077BB">0</font>.<font color="#0077BB">3</font>; <i><font color="#FFFF00">// a rough but conservative estimate of roof geometry height</font></i>
  h -= roof_geom_max_height; <i><font color="#FFFF00">// fixme: hack: make sure h is bounding height instead</font></i>
  <i><font color="#FFFF00">// some building base scope</font></i>
  Scope base;
  base.p = p;
  base.b = b;
  base.dcc = sd_bounds( base.p.xy, base.b );
  base.t = t;
  <b><font color="0000BB">float</font></b> d = -/* FLT_MAX */<font color="#0077BB">1000000</font>.; <i><font color="#FFFF00">// opI( base.p.z - h, base.dcc ) is the base block, if you want to visualize it for debug</font></i>
  <b><font color="0000BB">vec3</font></b> windr = <b><font color="0000BB">vec3</font></b>( /* FLT_MAX */<font color="#0077BB">1000000</font>. );
  {
    <i><font color="#FFFF00">// front facade</font></i>
    Scope facade = getScopeFacadeX( base, h, <font color="#0077BB">3</font> );
    <b><font color="0000BB">vec2</font></b> d1 = sd_SurfaceFacade0( facade.p, facade.p.z );
    d = opI( d1.x, d );
    windr = <b><font color="0000BB">vec3</font></b>( d1.y, <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">1</font>., <font color="#0077BB">0</font>. ) );
  }
  {
    <i><font color="#FFFF00">// back facade with flat windows</font></i>
    Scope facade = getScopeFacadeY( base, h, <font color="#0077BB">3</font> );
    <b><font color="0000BB">float</font></b> d2 = sd_SurfaceFacade7( facade.p, facade.p.z );
    d = opI( d2, d );
  }
  <b><font color="0000BB">if</font></b> ( nh.d != /* FLT_MAX */<font color="#0077BB">1000000</font>. )
  {
    <i><font color="#FFFF00">// highway facing facade using nearest highway clip plane</font></i>
    <b><font color="0000BB">float</font></b> d10 = dot( p.xy - nh.o_clip, nh.n_clip ) - (<font color="#0077BB">1</font>.) * <font color="#0077BB">1</font>.<font color="#0077BB">3</font>;
    <b><font color="0000BB">vec3</font></b> pr = <b><font color="0000BB">vec3</font></b>( dot( p.xy, perp( nh.n_clip ) ), p.z, -d10 ); <i><font color="#FFFF00">// pr is the point in 2d facade space</font></i>
    <b><font color="0000BB">vec2</font></b> d3 = sd_SurfaceFacade0( pr, pr.z );
    d = opI( d3.x, d );
    <i><font color="#FFFF00">// pick this window if it's closest</font></i>
    windr = mix( windr, <b><font color="0000BB">vec3</font></b>( d3.y, nh.n_clip ), step( abs( d3.y ), abs( windr.x ) ) );
  }
  <b><font color="0000BB">float</font></b> droof = d; <i><font color="#FFFF00">// save d before we clamped base on h, that will give us a consistent base dcc to build the roof on</font></i>
  d = opI( d, base.p.z - h );
  {
    Scope roof = base;
    roof.p.z -= h;
    roof.dcc = droof;
    d = sd_JPBuildingRoofTopWithObjects( d, roof, roof_geom_max_height, <b><font color="0000BB">true</font></b>, rnd ); <i><font color="#FFFF00">// roof with border + objects on it</font></i>
  }
  ParametricBuildingRetval ret;
  ret.d = d;
  ret.windr = windr;
  ret.droof = /* FLT_MAX */<font color="#0077BB">1000000</font>.;
  <b><font color="0000BB">return</font></b> ret;
}
<i><font color="#FFFF00">// house with a tiled roof (Kyoto has lots of those, though the roof type is different and here is just a super crude abstracted version)</font></i>
ParametricBuildingRetval sd_House( <b><font color="0000BB">vec3</font></b> p, <b><font color="0000BB">float</font></b> t, bounds2 b, <b><font color="0000BB">float</font></b> h, NearestHighwayRetval nh )
{
  h -= <font color="#0077BB">1</font>.<font color="#0077BB">4</font>; <i><font color="#FFFF00">// fixme: hack: make sure h is bounding height instead</font></i>
  <b><font color="0000BB">vec2</font></b> inset = size( b ) * <font color="#0077BB">0</font>.<font color="#0077BB">01</font>; <i><font color="#FFFF00">// b is conservative, the house must be included inside it</font></i>
  b.pmin += inset; <i><font color="#FFFF00">// we want roof to hang over a bit so shrink the base a bit</font></i>
  b.pmax -= inset;
  <i><font color="#FFFF00">// some building base scope</font></i>
  Scope base;
  base.p = p;
  base.b = b;
  base.dcc = sd_bounds( base.p.xy, base.b );
  base.t = t;
  <i><font color="#FFFF00">// the base block, if you want to visualize it for debug</font></i>
  <i><font color="#FFFF00">//  float d = opI( base.p.z - h, base.dcc );</font></i>
  <i><font color="#FFFF00">// highway facing facade clipped using nearest highway clip plane</font></i>
  <b><font color="0000BB">float</font></b> d10 = nh.d != /* FLT_MAX */<font color="#0077BB">1000000</font>. ? dot( p.xy - nh.o_clip, nh.n_clip ) - (<font color="#0077BB">1</font>.) * <font color="#0077BB">0</font>.<font color="#0077BB">6</font> : /* FLT_MAX */<font color="#0077BB">1000000</font>.;
  base.dcc = opI( -d10, base.dcc ); <i><font color="#FFFF00">// clip the base shape so that we still get a bit of roof hang over</font></i>
  ParametricBuildingRetval ret;
  <b><font color="0000BB">float</font></b> slope_ctrl = <font color="#0077BB">0</font>.<font color="#0077BB">7</font>;
  <i><font color="#FFFF00">// hip roof with tiled surface</font></i>
  <b><font color="0000BB">vec3</font></b> prfx = getRoofLocalX( p, slope_ctrl, base.b, h );
  <b><font color="0000BB">float</font></b> rfxd = opS( prfx.z - hf_SurfaceRoofTiles( prfx.xy ), prfx.z - ( -<font color="#0077BB">0</font>.<font color="#0077BB">03</font> ) );
  rfxd = opI( base.dcc - <font color="#0077BB">0</font>.<font color="#0077BB">15</font>, rfxd ); <i><font color="#FFFF00">// vertical cookie cut, wider for roof geom</font></i>
  <b><font color="0000BB">vec3</font></b> prfy = getRoofLocalY( p, slope_ctrl, base.b, h );
  <b><font color="0000BB">float</font></b> rfyd = opS( prfy.z - hf_SurfaceRoofTiles( prfy.xy ), prfy.z - ( -<font color="#0077BB">0</font>.<font color="#0077BB">03</font> ) );
  rfyd = opI( base.dcc - <font color="#0077BB">0</font>.<font color="#0077BB">15</font>, rfyd ); <i><font color="#FFFF00">// vertical cookie cut, wider for roof geom</font></i>
  <i><font color="#FFFF00">// add windows</font></i>
  <b><font color="0000BB">float</font></b> dbottom = opI( base.dcc, opI( prfx.z, prfy.z ) );
  Scope wall_s = getScopeFacadeY( base, h, <font color="#0077BB">3</font> );
  <b><font color="0000BB">vec3</font></b> pf = <b><font color="0000BB">vec3</font></b>( wall_s.p.xy * <font color="#0077BB">1</font>.<font color="#0077BB">0</font> - <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>., -<font color="#0077BB">0</font>.<font color="#0077BB">28</font> ), wall_s.p.z * <font color="#0077BB">2</font>. );
  <b><font color="0000BB">vec2</font></b> df8 = sd_SurfaceFacade8( pf, dbottom );
  dbottom = opI( wall_s.dcc, df8.x ); <i><font color="#FFFF00">// base + window carved in</font></i>
  dbottom = opI( -d10, dbottom ); <i><font color="#FFFF00">// clip the base shape so that we still get a bit of roof hang over</font></i>
  ret.windr = <b><font color="0000BB">vec3</font></b>( df8.y, <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>., <font color="#0077BB">1</font>. ) );
  <i><font color="#FFFF00">// hip roof + roof surface</font></i>
  ret.droof = opU( opI( rfyd, prfx.z ), opI( rfxd, prfy.z ) ); <i><font color="#FFFF00">// just roof surface</font></i>
  ret.d = opU( ret.droof, dbottom );
  <i><font color="#FFFF00">// fill the empty bit under the roof (due to hang hover modeling),</font></i>
  <i><font color="#FFFF00">// which is visible when we did a highway clip</font></i>
  <b><font color="0000BB">float</font></b> dz = ( p.z - h ) / slope_ctrl;
  ret.d = opU( ret.d, opI( base.dcc + max( dz, <font color="#0077BB">0</font>. ), -dz ) );
  <b><font color="0000BB">return</font></b> ret;
}
<i><font color="#FFFF00">// highway curve as seem from above... wanted to do more complicated but stuck to the test curve instead</font></i>
<b><font color="0000BB">vec2</font></b> sd_HighwayCurveXY( <b><font color="0000BB">float</font></b> x ) {
  <b><font color="0000BB">float</font></b> xt = repeat_mirror_e( x, -<font color="#0077BB">20</font>., <font color="#0077BB">20</font>. );
  <b><font color="0000BB">return</font></b> <b><font color="0000BB">vec2</font></b>( x, smoothstep( <font color="#0077BB">0</font>., <font color="#0077BB">15</font>., xt ) * <font color="#0077BB">8</font>. );
}
<b><font color="0000BB">vec3</font></b> sd_CameraCurveXY( <b><font color="0000BB">float</font></b> x ) {
  <b><font color="0000BB">return</font></b> <b><font color="0000BB">vec3</font></b>( x, sd_HighwayCurveXY( x ).y, <font color="#0077BB">2</font>.<font color="#0077BB">18</font> );
}
<i><font color="#FFFF00">// highways are repeated on y axis</font></i>
NearestHighwayRetval evalHighwaySetup( <b><font color="0000BB">vec2</font></b> p )
{
  NearestHighwayRetval hret;
  hret.p = p.xy;
  hret.pr = p.xy;
  hret.pr.y = repeat_e( hret.pr.y, -<font color="#0077BB">35</font>., <font color="#0077BB">35</font>. ); <i><font color="#FFFF00">// note: mirror repeat wouldn't work</font></i>
  <b><font color="0000BB">return</font></b> hret;
}
<i><font color="#FFFF00">// do the actual distance to highway evaluation</font></i>
NearestHighwayRetval evalHighway( <b><font color="0000BB">vec2</font></b> p )
{
  NearestHighwayRetval hret = evalHighwaySetup( p );
  <b><font color="0000BB">vec4</font></b> ret;
  { /* we use this method <b><font color="0000BB">for</font></b> distance to curve: http:<i><font color="#FFFF00">//www.geometrie.tugraz.at/wallner/sproj.pdf */ /* it is a bit different from http://www.iquilezles.org/www/articles/distance/distance.htm in that since it is iterative there is a potential quality/perf trade off */ vec2 _p = hret.pr.xy, _c, _dc;</font></i>
    <b><font color="0000BB">float</font></b> _epsilon = <font color="#0077BB">0</font>.<font color="#0077BB">001</font> * p.x;
    <b><font color="0000BB">float</font></b> _t = _p.x; /* t0, could be a parameter <b><font color="0000BB">if</font></b> the user knows better */ <b><font color="0000BB">for</font></b> ( <b><font color="0000BB">int</font></b> _i = <font color="#0077BB">0</font>; _i < <font color="#0077BB">2</font>; ++_i ) {
      _c = sd_HighwayCurveXY( _t );
      _dc = ( sd_HighwayCurveXY( _t + _epsilon ) - _c ) * ( <font color="#0077BB">1</font>. / _epsilon );
      _t += dot( _p.xy - _c, _dc ) / dot( _dc, _dc ); /* simplification of _t += dot( _dc, _q - _c ) / dot( _dc, _dc ); where _q is _p.xy projected on (_c,_dc) line */
    } ret = <b><font color="0000BB">vec4</font></b>( _c - _p, _dc );
  };
  hret.d = length( ret.xy ); <i><font color="#FFFF00">// distance to center line, used in several places so cache</font></i>
  hret.d2f = ret;
  <b><font color="0000BB">return</font></b> hret;
}
<i><font color="#FFFF00">// used for lamp top silhouette</font></i>
<b><font color="0000BB">float</font></b> crochet( <b><font color="0000BB">float</font></b> x, <b><font color="0000BB">float</font></b> s2, <b><font color="0000BB">float</font></b> s1, <b><font color="0000BB">float</font></b> a, <b><font color="0000BB">float</font></b> b, <b><font color="0000BB">float</font></b> ym ) {
  <b><font color="0000BB">return</font></b> max( min( <font color="#0077BB">0</font>., ( -( x - b ) ) * s1 ), ym ) + min( <font color="#0077BB">0</font>., ( x - a ) * s2 );
}
<i><font color="#FFFF00">// street lamp object</font></i>
<i><font color="#FFFF00">// hw is the road half width</font></i>
<i><font color="#FFFF00">// p2.xy is cross section along u</font></i>
<i><font color="#FFFF00">// p2.y is already symmetric (distance to center)</font></i>
<b><font color="0000BB">vec2</font></b> sd_Lamps( <b><font color="0000BB">float</font></b> u, <b><font color="0000BB">vec2</font></b> p2, <b><font color="0000BB">float</font></b> hw, <b><font color="0000BB">float</font></b> lw, <b><font color="0000BB">float</font></b> lamp_height, <b><font color="0000BB">float</font></b> period )
{
  <b><font color="0000BB">vec2</font></b> p3 = p2.xy - <b><font color="0000BB">vec2</font></b>( hw, lamp_height ); <i><font color="#FFFF00">// center to lamp corner</font></i>
  <b><font color="0000BB">float</font></b> dline = opI( -dot( p3.xy, -<b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">5</font>, <font color="#0077BB">0</font>.<font color="#0077BB">866025403</font> ) ), p3.x ); <i><font color="#FFFF00">// lamp line</font></i>
  <b><font color="0000BB">float</font></b> width = <font color="#0077BB">0</font>.<font color="#0077BB">04</font>; <i><font color="#FFFF00">// pole width</font></i>
  <b><font color="0000BB">float</font></b> dslice = sd_bounds_repeat_range_range( u, <font color="#0077BB">0</font>., period, <font color="#0077BB">0</font>., width ); <i><font color="#FFFF00">// slice</font></i>
  dslice = opI( dslice, -p2.y ); <i><font color="#FFFF00">// keep upper bit only</font></i>
  <b><font color="0000BB">float</font></b> dpolebit = opB_outside( dline, <font color="#0077BB">0</font>.<font color="#0077BB">015</font> ); <i><font color="#FFFF00">// only keep outside band</font></i>
  dpolebit = opI( dpolebit, -p3.x - lw ); <i><font color="#FFFF00">// subtract center bit</font></i>
  <b><font color="0000BB">float</font></b> shrink = <font color="#0077BB">0</font>.<font color="#0077BB">004</font>;
  <b><font color="0000BB">float</font></b> dlampbit = opB_inside( dline - shrink, <font color="#0077BB">0</font>.<font color="#0077BB">02</font> ); <i><font color="#FFFF00">// only keep outside band, offset by shrink to ensure lamp geom stays in contact</font></i>
  dlampbit = opI( dlampbit, -p3.x - lw ); <i><font color="#FFFF00">// subtract center bit</font></i>
  dlampbit = opI( dlampbit, -p2.y + lamp_height * <font color="#0077BB">1</font>.<font color="#0077BB">025</font> ); <i><font color="#FFFF00">// only keep bit the top lamp bit (cut bottom)</font></i>
  dlampbit += shrink; <i><font color="#FFFF00">// make lamp geom smaller</font></i>
  <b><font color="0000BB">float</font></b> d = opU( dpolebit, dlampbit );
  d = opI( d, dslice - crochet( p3.x, <font color="#0077BB">0</font>.<font color="#0077BB">1</font>, <font color="#0077BB">0</font>.<font color="#0077BB">75</font>, -<font color="#0077BB">0</font>.<font color="#0077BB">1</font>, -<font color="#0077BB">0</font>.<font color="#0077BB">05</font>, -<font color="#0077BB">0</font>.<font color="#0077BB">01</font> ) ); <i><font color="#FFFF00">// extract a slice, and also make the slice slightly triangular</font></i>
  <b><font color="0000BB">return</font></b> <b><font color="0000BB">vec2</font></b>( d, dlampbit );
}
<i><font color="#FFFF00">// there will be SIGN_N-1 signs visible per period (because of clipping in curvy bits)</font></i>
<i><font color="#FFFF00">// pick a periodicity that doesn't expose the dodginess of the sdf in curvy sections</font></i>
<i><font color="#FFFF00">// highway signs (LCD screens)</font></i>
<b><font color="0000BB">vec2</font></b> sd_HighwaySigns( <b><font color="0000BB">float</font></b> u, <b><font color="0000BB">vec2</font></b> p2, <b><font color="0000BB">float</font></b> hw )
{
  u = repeat_mirror_e( u, -<font color="#0077BB">20</font>., <font color="#0077BB">20</font>. ); <i><font color="#FFFF00">// same repeat as sd_HighwayCurveXY</font></i>
  <b><font color="0000BB">float</font></b> period = (<font color="#0077BB">2</font>.*<font color="#0077BB">20</font>. / (<font color="#0077BB">3</font>.));
  u += period * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>;
  <b><font color="0000BB">float</font></b> width = <font color="#0077BB">0</font>.<font color="#0077BB">04</font>;
  <b><font color="0000BB">float</font></b> h2 = <font color="#0077BB">1</font>.<font color="#0077BB">2</font>; <i><font color="#FFFF00">// sign start h</font></i>
  <b><font color="0000BB">float</font></b> h3 = <font color="#0077BB">0</font>.<font color="#0077BB">3</font>; <i><font color="#FFFF00">// sign end h</font></i>
  <b><font color="0000BB">float</font></b> dslice = sd_bounds_repeat_range_range( u, <font color="#0077BB">0</font>., period, <font color="#0077BB">0</font>., width ); <i><font color="#FFFF00">// slice</font></i>
  dslice = opI( dslice, -p2.y ); <i><font color="#FFFF00">// keep upper bit only</font></i>
  <b><font color="0000BB">vec2</font></b> p3 = p2.xy - <b><font color="0000BB">vec2</font></b>( hw, h2 ); <i><font color="#FFFF00">// center to lamp corner</font></i>
  <b><font color="0000BB">float</font></b> d8 = opB_outside( p3.x, <font color="#0077BB">0</font>.<font color="#0077BB">015</font> ); <i><font color="#FFFF00">// only keep outside band</font></i>
  d8 = opI( d8, p3.y );
  d8 = opU( d8, sd_bounds_range( p3, <b><font color="0000BB">vec2</font></b>( -hw, <font color="#0077BB">0</font>. ), <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">05</font>, h3 ) ) );
  <b><font color="0000BB">return</font></b> <b><font color="0000BB">vec2</font></b>( opI( d8, dslice ), /* FLT_MAX */<font color="#0077BB">1000000</font>. );
}
<i><font color="#FFFF00">// ray marched city bits, this is global and has nothing to do with the dda</font></i>
<i><font color="#FFFF00">// return value: .x closest distance, .y closest distance to light emitter material</font></i>
<b><font color="0000BB">vec3</font></b> sd_RayMarchedCityBits( <b><font color="0000BB">vec3</font></b> p, <b><font color="0000BB">int</font></b> lod )
{
  <b><font color="0000BB">float</font></b> d = p.z - <font color="#0077BB">0</font>.; <i><font color="#FFFF00">// zero ground</font></i>
  NearestHighwayRetval hret = evalHighway( p.xy );
  <b><font color="0000BB">float</font></b> hw = (<font color="#0077BB">1</font>.); <i><font color="#FFFF00">// r1 is the half width</font></i>
  <b><font color="0000BB">float</font></b> h = <font color="#0077BB">2</font>.;
  <b><font color="0000BB">vec3</font></b> crvp = <b><font color="0000BB">vec3</font></b>( hret.d, p.z, ( hret.pr + hret.d2f.xy ).x ); <i><font color="#FFFF00">// curve 3d pos</font></i>
  <b><font color="0000BB">float</font></b> d2 = sd_bounds_range( crvp.xy, <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">0</font>, h - <font color="#0077BB">0</font>.<font color="#0077BB">05</font> ), <b><font color="0000BB">vec2</font></b>( hw, h ) ); <i><font color="#FFFF00">// highway cross section main block</font></i>
  <b><font color="0000BB">float</font></b> d3 = sd_bounds_range( crvp.xy, <b><font color="0000BB">vec2</font></b>( hw * <font color="#0077BB">0</font>.<font color="#0077BB">9</font>, h - <font color="#0077BB">0</font>.<font color="#0077BB">01</font> ), <b><font color="0000BB">vec2</font></b>( hw * <font color="#0077BB">1</font>.<font color="#0077BB">01</font>, h + <font color="#0077BB">0</font>.<font color="#0077BB">2</font> * <font color="#0077BB">1</font>.<font color="#0077BB">4</font> ) ); <i><font color="#FFFF00">// highway cross section border bit</font></i>
  d = opU( d, opU_hard_bevel( d3, d2, <font color="#0077BB">0</font>.<font color="#0077BB">05</font> ) );
  <i><font color="#FFFF00">// supporting column</font></i>
  <b><font color="0000BB">vec2</font></b> ppp = <b><font color="0000BB">vec2</font></b>( h - p.z, hret.d );
  <b><font color="0000BB">float</font></b> d4 = ppp.y - ( <font color="#0077BB">0</font>.<font color="#0077BB">2</font> + <font color="#0077BB">0</font>.<font color="#0077BB">2</font> * pow( <font color="#0077BB">1</font>. - saturate( ppp.x * <font color="#0077BB">2</font>. ), <font color="#0077BB">4</font>. ) );
  d4 = opI( -h + p.z, d4 );
  d4 = opI( d4, sd_bounds_repeat_range_range( crvp.z, <font color="#0077BB">0</font>., <font color="#0077BB">2</font>., <font color="#0077BB">0</font>.<font color="#0077BB">5</font>, <font color="#0077BB">0</font>.<font color="#0077BB">9</font> ) ); <i><font color="#FFFF00">// subtract space between supporting columns</font></i>
  d = opU( d, d4 );
  <b><font color="0000BB">vec2</font></b> dlamps = <b><font color="0000BB">vec2</font></b>( /* FLT_MAX */<font color="#0077BB">1000000</font>. );
  <b><font color="0000BB">vec2</font></b> dlamps2 = <b><font color="0000BB">vec2</font></b>( /* FLT_MAX */<font color="#0077BB">1000000</font>. );
  dlamps = sd_Lamps( crvp.z, <b><font color="0000BB">vec2</font></b>( hret.d, p.z - h ), hw, <font color="#0077BB">0</font>.<font color="#0077BB">25</font>, <font color="#0077BB">1</font>.<font color="#0077BB">2</font>, <font color="#0077BB">3</font>.<font color="#0077BB">2</font> );
  d = opU( d, dlamps.x );
  <i><font color="#FFFF00">// add billboard signs on highways</font></i>
  <b><font color="0000BB">vec2</font></b> dsigns = sd_HighwaySigns( crvp.z, <b><font color="0000BB">vec2</font></b>( hret.d, p.z - h ), hw );
  d = opU( d, dsigns.x );
  <i><font color="#FFFF00">// add ground and pavements</font></i>
  <b><font color="0000BB">vec3</font></b> pp = p;
  pp.xy = repeat_mirror_l( p.xy, <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>., <font color="#0077BB">0</font>. ), /* CELL_SIZE */<b><font color="0000BB">vec3</font></b>( <font color="#0077BB">8</font>., <font color="#0077BB">8</font>., <font color="#0077BB">100</font>. ).xy );
  <b><font color="0000BB">vec2</font></b> extra = -<b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">15</font> ); <i><font color="#FFFF00">// expand pavement a bit</font></i>
  <i><font color="#FFFF00">// for pavement we just repeat a round box with left, bottom side using wide road width and top, right sides using small road width</font></i>
  <b><font color="0000BB">float</font></b> dpavement = sd_bounds_range_round( pp.xy, /* CELL_SPACING */<b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">47</font>, <font color="#0077BB">1</font>.<font color="#0077BB">3</font> ).yy * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> + extra, /* CELL_SIZE */<b><font color="0000BB">vec3</font></b>( <font color="#0077BB">8</font>., <font color="#0077BB">8</font>., <font color="#0077BB">100</font>. ).xy - /* CELL_SPACING */<b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">47</font>, <font color="#0077BB">1</font>.<font color="#0077BB">3</font> ).xx - extra, <font color="#0077BB">0</font>.<font color="#0077BB">075</font> );
  dpavement = opS( dpavement, ( hret.d - (<font color="#0077BB">1</font>.) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> ) ); <i><font color="#FFFF00">// empty the bit below the highway... that makes roadmarkings worse</font></i>
  dpavement = opI_hard_bevel( dpavement, pp.z - <font color="#0077BB">0</font>.<font color="#0077BB">025</font>, <font color="#0077BB">0</font>.<font color="#0077BB">02</font> ); <i><font color="#FFFF00">// hard bevel to create border, clip with pavement top plane</font></i>
  d = opU( dpavement, d ); <i><font color="#FFFF00">// add pavement</font></i>
  <i><font color="#FFFF00">// add lamps on wide roads</font></i>
  <b><font color="0000BB">float</font></b> period = /* CELL_SIZE */<b><font color="0000BB">vec3</font></b>( <font color="#0077BB">8</font>., <font color="#0077BB">8</font>., <font color="#0077BB">100</font>. ).x / <font color="#0077BB">5</font>.;
  <i><font color="#FFFF00">// offset by peroid/2 to avoid putting lamps on crossing road (so we don't have to mask)</font></i>
  dlamps2 = sd_Lamps( p.y + period * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>, <b><font color="0000BB">vec2</font></b>( repeat_mirror_l( p.x, <font color="#0077BB">0</font>., /* CELL_SIZE */<b><font color="0000BB">vec3</font></b>( <font color="#0077BB">8</font>., <font color="#0077BB">8</font>., <font color="#0077BB">100</font>. ).x ), p.z )
                      , /* CELL_SPACING */<b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">47</font>, <font color="#0077BB">1</font>.<font color="#0077BB">3</font> ).x * <font color="#0077BB">1</font>.<font color="#0077BB">3</font> <i><font color="#FFFF00">// go on the pavement a bit</font></i>
                      , <font color="#0077BB">0</font>.<font color="#0077BB">08</font>, <font color="#0077BB">0</font>.<font color="#0077BB">65</font>, period );
  d = opU( d, dlamps2.x );
  <b><font color="0000BB">return</font></b> <b><font color="0000BB">vec3</font></b>( d, opU( dlamps.y, dlamps2.y ), dsigns.x );
}
<b><font color="0000BB">vec3</font></b> l2g( <b><font color="0000BB">vec3</font></b> v ) {
  <b><font color="0000BB">return</font></b> pow( v, <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">1</font>. / <font color="#0077BB">2</font>.<font color="#0077BB">22</font> ) );
}
<b><font color="0000BB">vec3</font></b> g2l( <b><font color="0000BB">vec3</font></b> v ) {
  <b><font color="0000BB">return</font></b> pow( v, <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">2</font>.<font color="#0077BB">22</font> ) );
}
<b><font color="0000BB">vec3</font></b> biexp2( <b><font color="0000BB">float</font></b> x, <b><font color="0000BB">vec4</font></b> r, <b><font color="0000BB">vec4</font></b> g, <b><font color="0000BB">vec4</font></b> b ) {
  <b><font color="0000BB">return</font></b> biexp2( x * <b><font color="0000BB">vec3</font></b>( r.x, g.x, b.x ), <b><font color="0000BB">vec3</font></b>( r.y, g.y, b.y ), <b><font color="0000BB">vec3</font></b>( r.z, g.z, b.z ) ) * <b><font color="0000BB">vec3</font></b>( r.w, g.w, b.w );
}
<i><font color="#FFFF00">// manual match of one of the probes at http://cgg.mff.cuni.cz/projects/SkylightModelling/HosekWilkie_SkylightModel_SIGGRAPH2012_Supplement.pdf</font></i>
<b><font color="0000BB">vec3</font></b> get_sky( <b><font color="0000BB">vec3</font></b> v, <b><font color="0000BB">float</font></b> sun_cos_theta, <b><font color="0000BB">float</font></b> cheat_glow_scale )
{
  <b><font color="0000BB">vec3</font></b> l = <b><font color="0000BB">vec3</font></b>( sqrt( <font color="#0077BB">1</font>. - sun_cos_theta * sun_cos_theta ), <font color="#0077BB">0</font>., sun_cos_theta );
  <b><font color="0000BB">float</font></b> theta = safe_acos( v.z ); <i><font color="#FFFF00">// in theory we don't need safe on normalized value, in practice you just never know</font></i>
  <b><font color="0000BB">float</font></b> sd = dot( v, l );
  <b><font color="0000BB">vec3</font></b> sky_top_color = <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">0182</font>, <font color="#0077BB">0</font>.<font color="#0077BB">040</font>, <font color="#0077BB">0</font>.<font color="#0077BB">076</font> ) * <font color="#0077BB">0</font>.<font color="#0077BB">95</font>; <i><font color="#FFFF00">// top sky color in linear space</font></i>
  <b><font color="0000BB">vec3</font></b> sky_top = sky_top_color;
  <i><font color="#FFFF00">//  return ref - sky_top; // show remnant signal to match</font></i>
  <b><font color="0000BB">float</font></b> x = ( <font color="#0077BB">1</font>. - theta / ( <font color="#0077BB">3</font>.<font color="#0077BB">141592654</font> * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> ) ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>;
  <b><font color="0000BB">vec3</font></b> sky_radial = biexp2( x, <b><font color="0000BB">vec4</font></b>( <font color="#0077BB">7</font>.<font color="#0077BB">5</font>, <font color="#0077BB">15</font>., <font color="#0077BB">2</font>., <font color="#0077BB">0</font>.<font color="#0077BB">1</font> ), <b><font color="0000BB">vec4</font></b>( <font color="#0077BB">7</font>.<font color="#0077BB">5</font>, <font color="#0077BB">10</font>., <font color="#0077BB">1</font>.<font color="#0077BB">7</font>, <font color="#0077BB">0</font>.<font color="#0077BB">14</font> ), <b><font color="0000BB">vec4</font></b>( <font color="#0077BB">4</font>., <font color="#0077BB">5</font>., <font color="#0077BB">5</font>.<font color="#0077BB">5</font>, <font color="#0077BB">0</font>.<font color="#0077BB">075</font> ) ); <i><font color="#FFFF00">// south curve</font></i>
  <i><font color="#FFFF00">//  return ref - sky_top - sky_radial; // show remnant signal to match</font></i>
  <i><font color="#FFFF00">// maching the sun glow is more awkward</font></i>
  <b><font color="0000BB">vec3</font></b> sun_glow = <i><font color="#FFFF00">// note: this affects lighting a lot as we sample sun center color for the main light</font></i>
    spherical_gaussian( sd, <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">8</font>, <font color="#0077BB">0</font>.<font color="#0077BB">6</font>, <font color="#0077BB">0</font>.<font color="#0077BB">3</font> ) * <font color="#0077BB">1</font>., <font color="#0077BB">27</font>. ) +
    spherical_gaussian( sd, <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">8</font>, <font color="#0077BB">0</font>.<font color="#0077BB">4</font>, <font color="#0077BB">0</font>.<font color="#0077BB">1</font> ) * <font color="#0077BB">0</font>.<font color="#0077BB">3</font>, <font color="#0077BB">8</font>. );
  sun_glow *= cheat_glow_scale;
  <i><font color="#FFFF00">//  return sun_glow;</font></i>
  <i><font color="#FFFF00">//  return ref - sky_top - sky_radial - sun_glow; // show remnant signal to match... should be black excepy for sun glow</font></i>
  <b><font color="0000BB">return</font></b> max( <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">0</font>. ), ( sky_top + sky_radial + sun_glow ) ) * <font color="#0077BB">1</font>.;
}
<i><font color="#FFFF00">// align sky probe with l direction</font></i>
<b><font color="0000BB">vec3</font></b> get_sky( <b><font color="0000BB">vec3</font></b> v, <b><font color="0000BB">vec3</font></b> l, <b><font color="0000BB">float</font></b> cheat_glow_scale )
{
  <b><font color="0000BB">if</font></b> ( l.z != <font color="#0077BB">0</font>. ) v.xy = rotate_with_unit_vector_neg( v.xy, normalize( l.xy ) );
  <b><font color="0000BB">return</font></b> get_sky( v, l.z, cheat_glow_scale );
}
<b><font color="0000BB">vec3</font></b> test_sky( <b><font color="0000BB">vec2</font></b> fragCoord, <b><font color="0000BB">vec3</font></b> l )
{
  <b><font color="0000BB">vec2</font></b> u = fragCoord.xy / min( iResolution.x, iResolution.y );
  <b><font color="0000BB">float</font></b> theta = length( u - <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">5</font> ) ) * <font color="#0077BB">3</font>.<font color="#0077BB">141592654</font>;
  <b><font color="0000BB">float</font></b> phi = calc_angle( u - <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">5</font> ) );
  <b><font color="0000BB">vec3</font></b> v = zup_spherical_coords_to_vector( theta, phi );
  <b><font color="0000BB">if</font></b> ( theta > <font color="#0077BB">3</font>.<font color="#0077BB">141592654</font> * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> ) <b><font color="0000BB">return</font></b> <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">1</font>, <font color="#0077BB">0</font>, <font color="#0077BB">1</font> );
  <b><font color="0000BB">return</font></b> l2g( get_sky( v, l, <font color="#0077BB">1</font>. ) );
}
<i><font color="#FFFF00">// tentative japanese city building palette</font></i>
<b><font color="0000BB">vec3</font></b> get_building_palette( <b><font color="0000BB">vec2</font></b> h )
{
  <b><font color="0000BB">vec3</font></b> ivory = <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">1</font>, <font color="#0077BB">0</font>.<font color="#0077BB">85</font>, <font color="#0077BB">0</font>.<font color="#0077BB">7</font> ); <i><font color="#FFFF00">// c11</font></i>
  <b><font color="0000BB">vec3</font></b> white = <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">1</font>., <font color="#0077BB">1</font>., <font color="#0077BB">1</font>. ); <i><font color="#FFFF00">// c01</font></i>
  <b><font color="0000BB">vec3</font></b> c = mix( mix( <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">32</font>, <font color="#0077BB">0</font>.<font color="#0077BB">38</font>, <font color="#0077BB">0</font>.<font color="#0077BB">47</font> ), <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">35</font>, <font color="#0077BB">0</font>.<font color="#0077BB">36</font>, <font color="#0077BB">0</font>.<font color="#0077BB">41</font> ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>, h.x ), mix( white, ivory, h.x ), h.y );
  <i><font color="#FFFF00">//  vec3 c = mix( mix( c00, c10, h.x ), mix( c01, c11, h.x ), h.y );</font></i>
  <b><font color="0000BB">return</font></b> c = mix( c, <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">6</font>, <font color="#0077BB">0</font>.<font color="#0077BB">2</font>, <font color="#0077BB">0</font>.<font color="#0077BB">2</font> ), band( h.y - <font color="#0077BB">0</font>.<font color="#0077BB">5</font>, <font color="#0077BB">0</font>.<font color="#0077BB">045</font>, <font color="#0077BB">0</font>.<font color="#0077BB">01</font> ) * h.x * h.x * h.x ); <i><font color="#FFFF00">// add rare reddish colors for occasional red tiles building</font></i>
}
<b><font color="0000BB">struct</font></b> NumberArg {
  <b><font color="0000BB">float</font></b> h;
  <b><font color="0000BB">vec2</font></b> s;
  <b><font color="0000BB">float</font></b> r;
  <b><font color="0000BB">float</font></b> w;
  <b><font color="0000BB">float</font></b> m;
};
<i><font color="#FFFF00">// only works with 3 and 8 because those are easy :-)</font></i>
<b><font color="0000BB">float</font></b> sd_Number3or8( <b><font color="0000BB">vec2</font></b> p, <b><font color="0000BB">int</font></b> num, NumberArg a )
{
  a.s *= <font color="#0077BB">0</font>.<font color="#0077BB">5</font>;
  p.y = abs( p.y );
  <b><font color="0000BB">float</font></b> d = sd_bounds_range_round( p, <b><font color="0000BB">vec2</font></b>( -a.s.x + a.w + a.m, a.w * <font color="#0077BB">0</font>. ), a.s - a.w - a.m, a.r );
  d = opB_range( d, -a.w, a.w );
  <b><font color="0000BB">if</font></b> ( num == <font color="#0077BB">3</font> ) d = opS( d, sd_bounds_range( p, <b><font color="0000BB">vec2</font></b>( -a.s.x - a.w, -a.w ), <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>., a.s.y * a.h ) ) );
  <b><font color="0000BB">return</font></b> d;
}
<i><font color="#FFFF00">// http://www.airbus.com/aircraft/passenger-aircraft/a350xwb-family/a350-900.html</font></i>
<i><font color="#FFFF00">// -10,10 -> 64m</font></i>
<i><font color="#FFFF00">// the silhouette is pretty accurate, modeled on top of blueprint</font></i>
<i><font color="#FFFF00">// in this shader it just becomes pixel vomit covering a few pixels but I couldn't let go</font></i>
<b><font color="0000BB">float</font></b> sd_airliner_a350( <b><font color="0000BB">vec2</font></b> p )
{
  p.y = abs( p.y ); <i><font color="#FFFF00">// vertical symmetry</font></i>
  <b><font color="0000BB">float</font></b> db1 = p.y - <font color="#0077BB">0</font>.<font color="#0077BB">98</font> * rcp_decay( max( -<font color="#0077BB">0</font>.<font color="#0077BB">666</font>, -( p.x - <font color="#0077BB">10</font>. ) ) ); <i><font color="#FFFF00">// fuselage front</font></i>
  <b><font color="0000BB">float</font></b> db2 = p.y - <font color="#0077BB">0</font>.<font color="#0077BB">98</font> * rcp_decay( max( -<font color="#0077BB">0</font>.<font color="#0077BB">666</font>, p.x - -<font color="#0077BB">7</font>.<font color="#0077BB">8</font> ) ); <i><font color="#FFFF00">// fuselage back</font></i>
  <b><font color="0000BB">float</font></b> db = opI( db1, db2 ); <i><font color="#FFFF00">// fuselage</font></i>
  <b><font color="0000BB">float</font></b> dw1 = -( curved_max_vfunc_weld_quadric( p.x + <font color="#0077BB">3</font>.<font color="#0077BB">85</font>, <font color="#0077BB">0</font>.<font color="#0077BB">85</font> ) * <font color="#0077BB">2</font>.<font color="#0077BB">3</font> - ( <font color="#0077BB">9</font>.<font color="#0077BB">7</font> - p.y ) ); <i><font color="#FFFF00">// back wing curve</font></i>
  <b><font color="0000BB">float</font></b> dw2 = curved_max_vfunc_weld_quadric( p.x + <font color="#0077BB">3</font>.<font color="#0077BB">45</font>, <font color="#0077BB">0</font>.<font color="#0077BB">85</font> ) * <font color="#0077BB">1</font>.<font color="#0077BB">26</font> - ( <font color="#0077BB">9</font>.<font color="#0077BB">2</font> - p.y ); <i><font color="#FFFF00">// front wing curve</font></i>
  <b><font color="0000BB">float</font></b> d3 = -( p.x - ( -<font color="#0077BB">0</font>.<font color="#0077BB">8</font> ) ); <i><font color="#FFFF00">// back wing curve flat bit</font></i>
  dw1 = opU( dw1, d3 );
  <b><font color="0000BB">float</font></b> dw = opI( opI( dw1, dw2 ), -( p.x + <font color="#0077BB">4</font>. ) ); <i><font color="#FFFF00">// wing</font></i>
  <b><font color="0000BB">float</font></b> ds = -( ( smoothstep( -<font color="#0077BB">6</font>.<font color="#0077BB">5</font>, -<font color="#0077BB">9</font>.<font color="#0077BB">8</font>, p.x ) ) * <font color="#0077BB">2</font>.<font color="#0077BB">55</font> - p.y ); <i><font color="#FFFF00">// stabilizer</font></i>
  ds = opI( ds, ( p.x + <font color="#0077BB">6</font>.<font color="#0077BB">5</font> ) );
  ds = opS( ds, ( p.x + <font color="#0077BB">8</font>.<font color="#0077BB">94</font> + p.y * <font color="#0077BB">0</font>.<font color="#0077BB">4</font> ) ); <i><font color="#FFFF00">// final tail bit</font></i>
  <b><font color="0000BB">float</font></b> dt = opI( p.x + <font color="#0077BB">8</font>., p.y - <font color="#0077BB">0</font>.<font color="#0077BB">45</font> * rcp_decay( max( -<font color="#0077BB">0</font>.<font color="#0077BB">666</font>, ( p.x - -<font color="#0077BB">9</font>.<font color="#0077BB">75</font> ) * <font color="#0077BB">1</font>. ) ) );
  ds = opU( dt, ds ); <i><font color="#FFFF00">// cut garbage</font></i>
  <b><font color="0000BB">vec2</font></b> pe = p - <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">1</font>.<font color="#0077BB">5</font>, <font color="#0077BB">2</font>.<font color="#0077BB">77</font> ); <i><font color="#FFFF00">// engine pos</font></i>
  <b><font color="0000BB">float</font></b> de = abs( pe.y ) - <font color="#0077BB">0</font>.<font color="#0077BB">8</font> * min( powerful_scurve( pe.x, <font color="#0077BB">0</font>.<font color="#0077BB">5</font>, <font color="#0077BB">4</font>. ), powerful_scurve( <font color="#0077BB">1</font>. - ( pe.x - <font color="#0077BB">1</font>. ), <font color="#0077BB">0</font>.<font color="#0077BB">1</font>, <font color="#0077BB">4</font>. ) ) + <font color="#0077BB">0</font>.<font color="#0077BB">3</font>; <i><font color="#FFFF00">// engine</font></i>
  <b><font color="0000BB">return</font></b> opU( de, opU( ds, opU( dw, db ) ) );
}
<i><font color="#FFFF00">// another blob of stuff, yey</font></i>
<b><font color="0000BB">struct</font></b> TraceCityRetval
{
  <b><font color="0000BB">float</font></b> t; <i><font color="#FFFF00">// fixme: t or p. pick one? they might not be consistent</font></i>
  <b><font color="0000BB">vec3</font></b> p, n; <i><font color="#FFFF00">// position, normal</font></i>
  <b><font color="0000BB">float</font></b> ao;
  <b><font color="0000BB">vec2</font></b> tile_index; <i><font color="#FFFF00">// mostly for debug purpose</font></i>
  <b><font color="0000BB">float</font></b> split_case; <i><font color="#FFFF00">// split case [0,3] for coloring and randomization</font></i>
  <b><font color="0000BB">float</font></b> sub_id; <i><font color="#FFFF00">// children id in the 4 split</font></i>
  <b><font color="0000BB">int</font></b> type;
};
<b><font color="0000BB">void</font></b> pack_info( <b><font color="0000BB">inout</font></b> TraceCityRetval ct, <b><font color="0000BB">vec2</font></b> tile_index, <b><font color="0000BB">float</font></b> split_case, <b><font color="0000BB">float</font></b> sub_id ) {
  ct.tile_index = tile_index;
  ct.split_case = split_case;
  ct.sub_id = sub_id;
}
<b><font color="0000BB">void</font></b> pack_info1( <b><font color="0000BB">inout</font></b> TraceCityRetval ct, <b><font color="0000BB">float</font></b> t, <b><font color="0000BB">vec3</font></b> p, <b><font color="0000BB">vec3</font></b> n, <b><font color="0000BB">float</font></b> ao, <b><font color="0000BB">int</font></b> type ) {
  ct.t = t;
  ct.p = p;
  ct.n = n;
  ct.ao = ao;
  ct.type = type;
}
<i><font color="#FFFF00">// to easily make a polar coords heart, draw the heart you want, lay out r(theta) in cartesian space, and manual curve match it</font></i>
<b><font color="0000BB">float</font></b> heart( <b><font color="0000BB">float</font></b> x ) {
  x = abs( repeat_e( x, -<font color="#0077BB">3</font>.<font color="#0077BB">141592654</font>, <font color="#0077BB">3</font>.<font color="#0077BB">141592654</font> ) );
  <b><font color="0000BB">return</font></b> exp_decay( x * <font color="#0077BB">1</font>.<font color="#0077BB">2</font> ) * <font color="#0077BB">0</font>.<font color="#0077BB">7</font> + pow( max( x - <font color="#0077BB">3</font>.<font color="#0077BB">141592654</font> * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>, <font color="#0077BB">0</font>. ) / ( <font color="#0077BB">3</font>.<font color="#0077BB">141592654</font> * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> ), <font color="#0077BB">10</font>. ) * <font color="#0077BB">0</font>.<font color="#0077BB">3</font>;
}
<b><font color="0000BB">float</font></b> heart_grid( <b><font color="0000BB">vec2</font></b> sp, <b><font color="0000BB">vec2</font></b> c )
{
  <b><font color="0000BB">vec3</font></b> h = hash32( floor( sp / c ) );
  <b><font color="0000BB">float</font></b> s = <font color="#0077BB">12</font>. - <font color="#0077BB">5</font>. + <font color="#0077BB">10</font>. * h.z;
  <b><font color="0000BB">vec2</font></b> sp3 = repeat( sp, c ) - c * <font color="#0077BB">0</font>.<font color="#0077BB">2</font> * h.xy;
  <b><font color="0000BB">vec2</font></b> beat = impulse( <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">10</font>. ), repeat( <b><font color="0000BB">vec2</font></b>( iTime, iTime + <font color="#0077BB">0</font>.<font color="#0077BB">08</font> ), <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">1</font>.<font color="#0077BB">2</font> ) ) );
  <b><font color="0000BB">float</font></b> r = length( ( sp3 - c * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> ) / ( <font color="#0077BB">1</font>. + beat * <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">3</font>, <font color="#0077BB">0</font>.<font color="#0077BB">4</font> ) ) );
  <b><font color="0000BB">float</font></b> l = heart( calc_angle( sp3 - c * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> ) );
  <b><font color="0000BB">return</font></b> step( r, l * s );
}
<i><font color="#FFFF00">// ika is japanese for squid</font></i>
<b><font color="0000BB">float</font></b> ika( <b><font color="0000BB">vec2</font></b> p, <b><font color="0000BB">float</font></b> anim )
{
  <b><font color="0000BB">vec2</font></b> p2 = p.xy;
  p2.y += <font color="#0077BB">0</font>.<font color="#0077BB">25</font>;
  p2.x = abs( p.x );
  <b><font color="0000BB">float</font></b> d = opI_soft2( dot( p2 - <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>., <font color="#0077BB">1</font>. ), <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">707106781</font>, <font color="#0077BB">0</font>.<font color="#0077BB">707106781</font> ) ), -p2.y - <font color="#0077BB">0</font>.<font color="#0077BB">1</font>, <font color="#0077BB">6</font>. );
  d = opI_soft2( d, p2.y - <font color="#0077BB">1</font>., <font color="#0077BB">10</font>. );
  <b><font color="0000BB">float</font></b> a = calc_angle( p.xy );
  <b><font color="0000BB">float</font></b> r = length( p.xy );
  a = abs( repeat_e( a, -<font color="#0077BB">3</font>.<font color="#0077BB">141592654</font> * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>, <font color="#0077BB">3</font>.<font color="#0077BB">141592654</font> * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> ) );
  <b><font color="0000BB">float</font></b> d3 = r - ( <font color="#0077BB">0</font>.<font color="#0077BB">3</font> + spherical_gaussian( cos( a - <font color="#0077BB">3</font>.<font color="#0077BB">141592654</font> * mix( <font color="#0077BB">0</font>.<font color="#0077BB">4</font>, <font color="#0077BB">0</font>.<font color="#0077BB">5</font>, anim ) ), <font color="#0077BB">0</font>.<font color="#0077BB">8</font>, <font color="#0077BB">40</font>. )
                   + spherical_gaussian( cos( a - <font color="#0077BB">3</font>.<font color="#0077BB">141592654</font> * mix( <font color="#0077BB">0</font>.<font color="#0077BB">1</font>, <font color="#0077BB">0</font>.<font color="#0077BB">4</font>, anim ) ), <font color="#0077BB">1</font>.<font color="#0077BB">1</font>, <font color="#0077BB">40</font>. ) );
  d3 = opI_soft2( p2.y, d3, <font color="#0077BB">8</font>. );
  d = opU( d, d3 );
  d = opS( d, length( ( p2 - <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">2</font> - anim * <font color="#0077BB">0</font>.<font color="#0077BB">075</font>, <font color="#0077BB">0</font>.<font color="#0077BB">15</font> ) ) * <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">1</font>. + anim * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>, <font color="#0077BB">1</font>. ) ) - <font color="#0077BB">0</font>.<font color="#0077BB">16</font> * ( <font color="#0077BB">1</font>. + anim * <font color="#0077BB">0</font>.<font color="#0077BB">4</font> ) ); <i><font color="#FFFF00">// eyes</font></i>
  <b><font color="0000BB">return</font></b> d;
}
<b><font color="0000BB">float</font></b> ika_grid( <b><font color="0000BB">vec2</font></b> sp, <b><font color="0000BB">float</font></b> anim, <b><font color="0000BB">vec2</font></b> c ) {
  <b><font color="0000BB">return</font></b> ika( repeat_e( sp, -c, c ) * <font color="#0077BB">0</font>.<font color="#0077BB">1</font>, <font color="#0077BB">1</font>. - anim );
}
<b><font color="0000BB">float</font></b> star( <b><font color="0000BB">vec2</font></b> p )
{
  <b><font color="0000BB">vec2</font></b> n = normalize( <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">1</font>., <font color="#0077BB">0</font>.<font color="#0077BB">4</font> ) ); <i><font color="#FFFF00">// slope controls</font></i>
  p.x = abs( p.x );
  p = fold( p, <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>. ), <b><font color="0000BB">vec2</font></b>( -<font color="#0077BB">0</font>.<font color="#0077BB">309016994</font>, <font color="#0077BB">0</font>.<font color="#0077BB">951056516</font> ) ); <i><font color="#FFFF00">// perp(90-72=18)</font></i>
  p = fold( p, <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>. ), <b><font color="0000BB">vec2</font></b>( -<font color="#0077BB">0</font>.<font color="#0077BB">809016994</font>, <font color="#0077BB">0</font>.<font color="#0077BB">587785252</font> ) ); <i><font color="#FFFF00">// perp(90-72/2=54)</font></i>
  <b><font color="0000BB">vec2</font></b> v = p - <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>., <font color="#0077BB">1</font> );
  <b><font color="0000BB">return</font></b> opI( dot( v, n ), dot( v, <b><font color="0000BB">vec2</font></b>( -n.x, n.y ) ) );
}
<b><font color="0000BB">float</font></b> star_trail( <b><font color="0000BB">vec2</font></b> p, <b><font color="0000BB">out</font></b> <b><font color="0000BB">vec2</font></b> uv )
{
  p = rotate_with_angle( p, radians( -<font color="#0077BB">25</font>. ) * p.x );
  p.y *= exp( p.x * <font color="#0077BB">2</font>. );
  p.x *= exp( p.y * <font color="#0077BB">1</font>. );
  <b><font color="0000BB">vec2</font></b> pmin = <b><font color="0000BB">vec2</font></b>( -<font color="#0077BB">0</font>.<font color="#0077BB">4</font>, -<font color="#0077BB">0</font>.<font color="#0077BB">1</font> );
  <b><font color="0000BB">vec2</font></b> pmax = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">4</font>, <font color="#0077BB">0</font>.<font color="#0077BB">1</font> );
  uv = ( p - pmin ) / ( pmax - pmin );
  <b><font color="0000BB">return</font></b> sd_bounds_range( p, pmin, pmax );
}
<b><font color="0000BB">void</font></b> surfaceColor( TraceCityRetval ct, <b><font color="0000BB">inout</font></b> <b><font color="0000BB">vec3</font></b> albedo, <b><font color="0000BB">inout</font></b> <b><font color="0000BB">vec3</font></b> emitter, <b><font color="0000BB">inout</font></b> <b><font color="0000BB">float</font></b> road_marking_material )
{
  <b><font color="0000BB">if</font></b> ( ct.type == <font color="#0077BB">8</font> ) albedo = max( <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">0</font>. ), contrast( albedo, <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">1</font>.<font color="#0077BB">75</font> ) ) ); <i><font color="#FFFF00">// enhance disparity of roof colors</font></i>
  <b><font color="0000BB">float</font></b> aa = <font color="#0077BB">0</font>.<font color="#0077BB">003</font>; <i><font color="#FFFF00">// sorry...</font></i>
  NearestHighwayRetval nh;
  <b><font color="0000BB">float</font></b> is_highway_columns_zone = <font color="#0077BB">0</font>.; <i><font color="#FFFF00">// just columns</font></i>
  <b><font color="0000BB">float</font></b> d_pavement_below_highway = /* FLT_MAX */<font color="#0077BB">1000000</font>.;
  <b><font color="0000BB">float</font></b> d_highway_columns_zone = /* FLT_MAX */<font color="#0077BB">1000000</font>.;
  <b><font color="0000BB">if</font></b> ( ( ct.sub_id == /* TYPE_HIGHWAY */<font color="#0077BB">8</font>. ) || ( ct.sub_id == /* TYPE_ROAD */<font color="#0077BB">9</font>. ) )
  {
    nh = evalHighway( ct.p.xy );
    d_pavement_below_highway = nh.d - (<font color="#0077BB">1</font>.) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>;
    d_highway_columns_zone = nh.d - (<font color="#0077BB">1</font>.) * <font color="#0077BB">0</font>.<font color="#0077BB">25</font>;
    is_highway_columns_zone = smoothstep_c( -d_highway_columns_zone, <font color="#0077BB">0</font>., <font color="#0077BB">0</font>.<font color="#0077BB">005</font> ); <i><font color="#FFFF00">// account for the bevel (mask of road flat bit)</font></i>
  }
  <b><font color="0000BB">vec3</font></b> road_base_color0 = <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">5</font>, <font color="#0077BB">0</font>.<font color="#0077BB">53</font>, <font color="#0077BB">0</font>.<font color="#0077BB">65</font> );
  <b><font color="0000BB">if</font></b> ( ( ct.sub_id == /* TYPE_HIGHWAY */<font color="#0077BB">8</font>. ) && <b><font color="0000BB">true</font></b> )
  {
    <i><font color="#FFFF00">// roadmarkings on top of highway</font></i>
    <b><font color="0000BB">float</font></b> hd = nh.d - (<font color="#0077BB">1</font>.);
    <b><font color="0000BB">float</font></b> highway_road_bit_mask = <font color="#0077BB">1</font>. - smoothstep_c( nh.d, (<font color="#0077BB">1</font>.) - <font color="#0077BB">0</font>.<font color="#0077BB">2</font>, <font color="#0077BB">0</font>.<font color="#0077BB">005</font> ); <i><font color="#FFFF00">// account for the bevel (mask of road flat bit)</font></i>
    <b><font color="0000BB">vec2</font></b> u = ( nh.pr + nh.d2f.xy ); <i><font color="#FFFF00">// works better</font></i>
    u.y = nh.d;
    <b><font color="0000BB">float</font></b> snhd = nh.d * sign( nh.d2f.y ); <i><font color="#FFFF00">// signed distance accross road when we need to distinguish ledft/right</font></i>
    <b><font color="0000BB">float</font></b> curvature = smin_pol( abs( nh.d2f.w ) * <font color="#0077BB">1</font>.<font color="#0077BB">2</font>, <font color="#0077BB">1</font>., <font color="#0077BB">0</font>.<font color="#0077BB">5</font> );
    <b><font color="0000BB">float</font></b> diagstripes0 = step( ( (<font color="#0077BB">1</font>.) * <font color="#0077BB">0</font>.<font color="#0077BB">9</font> - nh.d ) * sign( nh.d2f.y ), curvature );
    <b><font color="0000BB">float</font></b> diagstripes = diagstripes0 * band( snhd, (<font color="#0077BB">1</font>.) * <font color="#0077BB">0</font>.<font color="#0077BB">1</font>, (<font color="#0077BB">1</font>.) * <font color="#0077BB">0</font>.<font color="#0077BB">7</font>, <font color="#0077BB">0</font>.<font color="#0077BB">005</font> ); <i><font color="#FFFF00">// select road v band, sign( nh.d2f.y ) tells us which side of the road we are on</font></i>
    <b><font color="0000BB">vec3</font></b> road_marking_color_white = <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">1</font>. ) * <font color="#0077BB">3</font>.;
    <b><font color="0000BB">vec3</font></b> road_marking_color_yellow = <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">1</font>., <font color="#0077BB">1</font>., <font color="#0077BB">0</font>. ) * <font color="#0077BB">2</font>.;
    <b><font color="0000BB">vec3</font></b> albedo_markings = <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">0</font>. );
    albedo_markings = mix( albedo_markings, road_marking_color_white, ( band( abs( u.y ) - ((<font color="#0077BB">1</font>.) * <font color="#0077BB">2</font>.) * <font color="#0077BB">0</font>.<font color="#0077BB">18</font>, <font color="#0077BB">0</font>.<font color="#0077BB">016</font>, aa ) ) * ( stripes2( u.x, <font color="#0077BB">0</font>.<font color="#0077BB">4</font>, <font color="#0077BB">0</font>.<font color="#0077BB">1</font>, aa ) ) * ( <font color="#0077BB">1</font>. - diagstripes ) );
    albedo_markings = mix( albedo_markings, mix( road_marking_color_yellow, road_marking_color_white, <font color="#0077BB">1</font>. ), highway_road_bit_mask * ( stripes( u.y, <font color="#0077BB">0</font>.<font color="#0077BB">75</font>, <font color="#0077BB">0</font>.<font color="#0077BB">016</font>, aa ) ) * ( <font color="#0077BB">1</font>. - diagstripes ) );
    <i><font color="#FFFF00">// the wide warning stripes</font></i>
    albedo_markings = mix( albedo_markings, road_marking_color_white, diagstripes * ( stripes( u.x + hd * sign( nh.d2f.y ) * <font color="#0077BB">1</font>.<font color="#0077BB">5</font>, <font color="#0077BB">0</font>.<font color="#0077BB">15</font> * <font color="#0077BB">1</font>.<font color="#0077BB">8</font>, <font color="#0077BB">0</font>.<font color="#0077BB">05</font>, aa ) ) );
    albedo_markings = mix( albedo_markings, road_marking_color_white, ( ( stripes2( u.x - fold(snhd, ((<font color="#0077BB">1</font>.) * <font color="#0077BB">2</font>.) * (-<font color="#0077BB">0</font>.<font color="#0077BB">28</font>)) * (<font color="#0077BB">0</font>.<font color="#0077BB">5</font>), <font color="#0077BB">0</font>.<font color="#0077BB">4</font> * <font color="#0077BB">16</font>., <font color="#0077BB">0</font>.<font color="#0077BB">1</font> * <font color="#0077BB">12</font>., aa ) ) * band( snhd - ((<font color="#0077BB">1</font>.) * <font color="#0077BB">2</font>.) * (-<font color="#0077BB">0</font>.<font color="#0077BB">28</font>), (<font color="#0077BB">0</font>.<font color="#0077BB">24</font>) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>, aa ) ) * ( ( stripes2( u.x - fold(snhd, ((<font color="#0077BB">1</font>.) * <font color="#0077BB">2</font>.) * (-<font color="#0077BB">0</font>.<font color="#0077BB">28</font>)) * (<font color="#0077BB">0</font>.<font color="#0077BB">5</font>), <font color="#0077BB">0</font>.<font color="#0077BB">4</font>, <font color="#0077BB">0</font>.<font color="#0077BB">1</font>, aa ) ) * band( snhd - ((<font color="#0077BB">1</font>.) * <font color="#0077BB">2</font>.) * (-<font color="#0077BB">0</font>.<font color="#0077BB">28</font>), (<font color="#0077BB">0</font>.<font color="#0077BB">24</font>) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>, aa ) ) * ( <font color="#0077BB">1</font>. - diagstripes ) );
    {
      <i><font color="#FFFF00">// highway road marking number</font></i>
      <b><font color="0000BB">vec2</font></b> np = ( ct.p.xy ); <i><font color="#FFFF00">// vec2( u.x, nh.d2f.y );</font></i>
      np.x = repeat_e( np.x, -<font color="#0077BB">20</font>., <font color="#0077BB">20</font>. );
      np = ( perp( np ) + <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">25</font>, <font color="#0077BB">9</font>. ) ) * <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">3</font>.<font color="#0077BB">5</font>, <font color="#0077BB">0</font>.<font color="#0077BB">75</font> );
      NumberArg args;
      args.h = <font color="#0077BB">0</font>.<font color="#0077BB">7</font>;
      args.s = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">1</font>., <font color="#0077BB">2</font>. ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>;
      args.r = <font color="#0077BB">0</font>.<font color="#0077BB">1</font>;
      args.w = <font color="#0077BB">0</font>.<font color="#0077BB">045</font>;
      args.m = <font color="#0077BB">0</font>.<font color="#0077BB">025</font>;
      <b><font color="0000BB">float</font></b> dn = sd_Number3or8( np, <font color="#0077BB">8</font>, args );
      dn = opU( dn, sd_Number3or8( np + <b><font color="0000BB">vec2</font></b>( -args.s.x * <font color="#0077BB">1</font>., <font color="#0077BB">0</font>. ), <font color="#0077BB">3</font>, args ) );
      <b><font color="0000BB">if</font></b> ( sign( nh.d2f.y ) > <font color="#0077BB">0</font>. ) dn = /* FLT_MAX */<font color="#0077BB">1000000</font>.;
      albedo_markings = mix( albedo_markings, road_marking_color_yellow, smoothstep( aa, -aa, dn ) );
    }
    <i><font color="#FFFF00">// make sure roadmarkings are only on top highway surface</font></i>
    <b><font color="0000BB">float</font></b> space_filter = step( <font color="#0077BB">2</font>., ct.p.z ) <i><font color="#FFFF00">// must be above highway height</font></i>
                         * step( <font color="#0077BB">0</font>., ct.n.z ) <i><font color="#FFFF00">// surface must be pointing up</font></i>
                         * step( ct.p.z, <font color="#0077BB">2</font>. + <font color="#0077BB">0</font>.<font color="#0077BB">5</font> ); <i><font color="#FFFF00">// not higher than highway border walls</font></i>
    {
      <b><font color="0000BB">float</font></b> blend = maxcomp( albedo_markings ) * space_filter;
      albedo = mix( albedo, min( albedo_markings + road_base_color0 * <font color="#0077BB">0</font>.<font color="#0077BB">70</font>, <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">1</font>. ) ), blend );
      road_marking_material = max( road_marking_material, blend );
    }
    <b><font color="0000BB">if</font></b> ( ct.type == <font color="#0077BB">2</font> )
    {
      <i><font color="#FFFF00">// render stuff on LCD panels... shadertoy within shadertoy, hehe</font></i>
      albedo_markings = <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">0</font>. );
      <b><font color="0000BB">float</font></b> h2 = <font color="#0077BB">1</font>.<font color="#0077BB">2</font>; <i><font color="#FFFF00">// sign start h</font></i>
      <b><font color="0000BB">float</font></b> h3 = <font color="#0077BB">0</font>.<font color="#0077BB">3</font>; <i><font color="#FFFF00">// sign end h</font></i>
      <b><font color="0000BB">if</font></b> ( ct.p.z > <font color="#0077BB">2</font>. + h2 - <font color="#0077BB">0</font>.<font color="#0077BB">0</font> )
      {
        <b><font color="0000BB">float</font></b> screenpixel = <font color="#0077BB">0</font>.<font color="#0077BB">01</font>; <i><font color="#FFFF00">// highway panel pizel size, in world size</font></i>
        <b><font color="0000BB">vec2</font></b> gp = ct.p.yz;
        gp.x = snhd;
        gp.y -= ( <font color="#0077BB">2</font>. + h2 ); <i><font color="#FFFF00">// make botton line be pixel coord y=0</font></i>
        <b><font color="0000BB">float</font></b> d = sd_bounds_repeat_size_margin( gp, <b><font color="0000BB">vec2</font></b>( screenpixel ), <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">001</font> ) );
        <b><font color="0000BB">float</font></b> margin = step( d, <font color="#0077BB">0</font>. );
        <i><font color="#FFFF00">// I don't AA properly because I suck, but at least tone the grid down</font></i>
        margin = mix( margin, <font color="#0077BB">1</font>., ( <font color="#0077BB">1</font>. - exp( -max( ct.t - <font color="#0077BB">6</font>., <font color="#0077BB">0</font>. ) ) * <font color="#0077BB">0</font>.<font color="#0077BB">7</font> ) );
        <b><font color="0000BB">vec2</font></b> sp = floor( gp / screenpixel ); <i><font color="#FFFF00">// screen pixel</font></i>
        <i><font color="#FFFF00">// bottom margin x top margin x sides component</font></i>
        <b><font color="0000BB">float</font></b> is_ldc_surface = step( <font color="#0077BB">1</font>., sp.y ) * step( sp.y, floor( <font color="#0077BB">0</font>.<font color="#0077BB">3</font> / screenpixel ) - <font color="#0077BB">2</font>. ) * step( <font color="#0077BB">0</font>.<font color="#0077BB">5</font>, abs( ct.n.x ) );
        margin *= is_ldc_surface;
        <b><font color="0000BB">float</font></b> index = floor( u.x / (<font color="#0077BB">2</font>.*<font color="#0077BB">20</font>. / (<font color="#0077BB">3</font>.)) ); <i><font color="#FFFF00">// same repeat as sd_HighwaySigns</font></i>
        index = mod( index, <font color="#0077BB">4</font>. );
        <b><font color="0000BB">if</font></b> ( index == <font color="#0077BB">0</font>. )
        {
          <i><font color="#FFFF00">// airliners</font></i>
          <b><font color="0000BB">vec2</font></b> c = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">110</font>., <font color="#0077BB">110</font>. );
          <b><font color="0000BB">vec2</font></b> sp3 = rotate_with_unit_vector( sp, -<b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">5</font>, <font color="#0077BB">0</font>.<font color="#0077BB">866025403</font> ) ) + <b><font color="0000BB">vec2</font></b>( -iTime * <font color="#0077BB">100</font>., <font color="#0077BB">0</font>. );
          sp3 = repeat( sp3, c );
          <b><font color="0000BB">float</font></b> d3 = sd_airliner_a350( ( sp3 - c * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> ) * <font color="#0077BB">0</font>.<font color="#0077BB">2</font> );
          emitter += (<b><font color="0000BB">vec3</font></b>( <font color="#0077BB">1</font>. )) * (step( d3, <font color="#0077BB">0</font>. )) * margin * <font color="#0077BB">1</font>.;;
        }
        <b><font color="0000BB">else</font></b> <b><font color="0000BB">if</font></b> ( index == <font color="#0077BB">1</font>. )
        {
          <i><font color="#FFFF00">// hearts</font></i>
          <b><font color="0000BB">float</font></b> hg = heart_grid( -perp( sp ) + <b><font color="0000BB">vec2</font></b>( sin( iTime * <font color="#0077BB">3</font>. ) * <font color="#0077BB">8</font>., <font color="#0077BB">6</font>. + iTime * <font color="#0077BB">40</font>. ), <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">32</font>., <font color="#0077BB">40</font>. ) );
          emitter += (<b><font color="0000BB">vec3</font></b>( <font color="#0077BB">1</font>., <font color="#0077BB">0</font>., <font color="#0077BB">0</font>. )) * (hg) * margin * <font color="#0077BB">1</font>.;;
          <b><font color="0000BB">float</font></b> hg2 = heart_grid( ( rotate_with_unit_vector( -sp, <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">707106781</font>, <font color="#0077BB">0</font>.<font color="#0077BB">707106781</font> ) ) * <font color="#0077BB">2</font>. ) + <b><font color="0000BB">vec2</font></b>( -iTime * <font color="#0077BB">18</font>., <font color="#0077BB">6</font>. ), <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">30</font>., <font color="#0077BB">30</font>. ) );
          emitter += (<b><font color="0000BB">vec3</font></b>( <font color="#0077BB">0</font>., <font color="#0077BB">1</font>., <font color="#0077BB">1</font>. )) * (hg2 * ( <font color="#0077BB">1</font>. - hg )) * margin * <font color="#0077BB">1</font>.;;
        }
        <b><font color="0000BB">else</font></b> <b><font color="0000BB">if</font></b> ( index == <font color="#0077BB">2</font>. )
        {
          <i><font color="#FFFF00">// rainbow stars</font></i>
          <b><font color="0000BB">vec2</font></b> sp3 = sp;
          sp3 *= <font color="#0077BB">1</font>.;
          sp3.y -= <font color="#0077BB">100</font>.;
          sp3 = rotate_with_angle( sp3, iTime );
          <b><font color="0000BB">float</font></b> a = calc_angle( sp3 );
          <b><font color="0000BB">float</font></b> r = length( sp3 );
          <b><font color="0000BB">float</font></b> r0 = <font color="#0077BB">30</font>.;
          <b><font color="0000BB">float</font></b> arclen0 = r0 * <font color="#0077BB">2</font>.; <i><font color="#FFFF00">// use a rough sie ratio</font></i>
          <b><font color="0000BB">float</font></b> ri = floor( r / r0 );
          <b><font color="0000BB">float</font></b> R = ri * r0;
          <b><font color="0000BB">float</font></b> numarc = floor( <font color="#0077BB">2</font>. * <font color="#0077BB">3</font>.<font color="#0077BB">141592654</font> * R / arclen0 );
          <b><font color="0000BB">float</font></b> da = ( <font color="#0077BB">2</font>. * <font color="#0077BB">3</font>.<font color="#0077BB">141592654</font> / numarc );
          <b><font color="0000BB">float</font></b> dai = floor( a / da );
          <b><font color="0000BB">vec2</font></b> y = unit_vector2( da * ( dai + <font color="#0077BB">0</font>.<font color="#0077BB">5</font> ) );
          <b><font color="0000BB">vec2</font></b> x = -perp( y );
          <b><font color="0000BB">vec2</font></b> c = y * ( ri + <font color="#0077BB">0</font>.<font color="#0077BB">5</font> ) * r0;
          sp3 = <b><font color="0000BB">vec2</font></b>( dot( x, sp3 - c ), dot( y, sp3 - c ) );
          sp3 *= <font color="#0077BB">0</font>.<font color="#0077BB">025</font>;
          sp3.y = -sp3.y;
          <b><font color="0000BB">float</font></b> d1 = star( sp3.xy * <font color="#0077BB">3</font>. );
          <b><font color="0000BB">vec2</font></b> trail_uv;
          <b><font color="0000BB">float</font></b> d2 = star_trail( sp3.xy - <b><font color="0000BB">vec2</font></b>( -<font color="#0077BB">0</font>.<font color="#0077BB">6</font>, -<font color="#0077BB">0</font>.<font color="#0077BB">1</font> ), trail_uv );
          <b><font color="0000BB">vec3</font></b> rainbow = hsv2rgb( <b><font color="0000BB">vec3</font></b>( trail_uv.y, <font color="#0077BB">1</font>., <font color="#0077BB">1</font>. ) );
          <b><font color="0000BB">vec3</font></b> c2 = <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">0</font>. );
          <b><font color="0000BB">if</font></b> ( d2 < <font color="#0077BB">0</font>. ) c2 = rainbow;
          <b><font color="0000BB">if</font></b> ( d1 < <font color="#0077BB">0</font>. ) c2 = <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">1</font>., <font color="#0077BB">1</font>., <font color="#0077BB">0</font>. );
          emitter += (c2) * (max( step( d1, <font color="#0077BB">0</font>. ), step( d2, <font color="#0077BB">0</font>. ) )) * margin * <font color="#0077BB">1</font>.;;
        }
        <b><font color="0000BB">else</font></b> <b><font color="0000BB">if</font></b> ( index == <font color="#0077BB">3</font>. )
        {
          <i><font color="#FFFF00">// 2 layers of swimming squids or something</font></i>
          <b><font color="0000BB">float</font></b> anim1 = ( sin( iTime * <font color="#0077BB">8</font>. ) + <font color="#0077BB">1</font>. ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>;
          <b><font color="0000BB">vec2</font></b> sp1 = rotate_with_unit_vector( sp, -<b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">707106781</font>, <font color="#0077BB">0</font>.<font color="#0077BB">707106781</font> ) ) + <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>., <font color="#0077BB">18</font>. - iTime * <font color="#0077BB">20</font>. + anim1 * <font color="#0077BB">4</font>. );
          <b><font color="0000BB">float</font></b> l1 = step( ika_grid( sp1, anim1, <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">15</font>., <font color="#0077BB">15</font>. ) ), <font color="#0077BB">0</font>. );
          emitter += (<b><font color="0000BB">vec3</font></b>( <font color="#0077BB">0</font>., <font color="#0077BB">1</font>., <font color="#0077BB">1</font>. )) * (l1) * margin * <font color="#0077BB">1</font>.;;
          <b><font color="0000BB">float</font></b> anim2 = ( sin( iTime * <font color="#0077BB">9</font>. ) + <font color="#0077BB">1</font>. ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>;
          <b><font color="0000BB">vec2</font></b> sp2 = rotate_with_unit_vector( sp, -<b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">707106781</font>, <font color="#0077BB">0</font>.<font color="#0077BB">707106781</font> ) ) + <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">5</font>., <font color="#0077BB">9</font>. - iTime * <font color="#0077BB">35</font>. + anim1 * <font color="#0077BB">4</font>. );
          <b><font color="0000BB">float</font></b> l2 = step( ika_grid( sp2, anim2, <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">40</font>., <font color="#0077BB">40</font>. ) ), <font color="#0077BB">0</font>. );
          emitter += (<b><font color="0000BB">vec3</font></b>( <font color="#0077BB">1</font>., <font color="#0077BB">0</font>., <font color="#0077BB">0</font>. )) * (l2 * ( <font color="#0077BB">1</font>. - l1 )) * margin * <font color="#0077BB">1</font>.;;
        }
        albedo = mix( albedo, albedo * <font color="#0077BB">0</font>.<font color="#0077BB">3</font>, is_ldc_surface );
      }
    }
  }
  <b><font color="0000BB">if</font></b> ( ( ct.sub_id == /* TYPE_ROAD */<font color="#0077BB">9</font>. ) && <b><font color="0000BB">true</font></b> )
  {
    <i><font color="#FFFF00">// regular streets road markings</font></i>
    NearestHighwayRetval nh = evalHighway( ct.p.xy );
    <b><font color="0000BB">vec2</font></b> pp = repeat_mirror_l( ct.p.xy, <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>., <font color="#0077BB">0</font>. ), /* CELL_SIZE */<b><font color="0000BB">vec3</font></b>( <font color="#0077BB">8</font>., <font color="#0077BB">8</font>., <font color="#0077BB">100</font>. ).xy ); <i><font color="#FFFF00">// road cells</font></i>
    <b><font color="0000BB">vec2</font></b> extra = -<b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">15</font> );
    <b><font color="0000BB">vec2</font></b> mina = /* CELL_SPACING */<b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">47</font>, <font color="#0077BB">1</font>.<font color="#0077BB">3</font> ).yy * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> + extra;
    <b><font color="0000BB">vec2</font></b> minb = /* CELL_SIZE */<b><font color="0000BB">vec3</font></b>( <font color="#0077BB">8</font>., <font color="#0077BB">8</font>., <font color="#0077BB">100</font>. ).xy - /* CELL_SPACING */<b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">47</font>, <font color="#0077BB">1</font>.<font color="#0077BB">3</font> ).xx - extra;
    <b><font color="0000BB">float</font></b> d1 = sd_bounds_range_round( pp, mina, minb, <font color="#0077BB">0</font>.<font color="#0077BB">075</font> );
    <b><font color="0000BB">float</font></b> is_pure_road = step( <font color="#0077BB">0</font>., d1 );
    d1 = opS( d1, d_pavement_below_highway ); <i><font color="#FFFF00">// empty the bit below the highway</font></i>
    <b><font color="0000BB">float</font></b> is_road_or_below_highway_road = step( <font color="#0077BB">0</font>., d1 );
    <b><font color="0000BB">vec2</font></b> is_wide_road = step( pp, mina );
    <b><font color="0000BB">vec2</font></b> is_small_road = step( minb, pp );
    <b><font color="0000BB">float</font></b> is_wide_road_crossing = is_wide_road.x * is_wide_road.y;
    <b><font color="0000BB">float</font></b> is_small_road_crossing = is_small_road.x * is_small_road.y;
    <b><font color="0000BB">float</font></b> is_small_wide_road_crossing = min( is_wide_road.x * is_small_road.y + is_wide_road.y * is_small_road.x, <font color="#0077BB">1</font>. );
    <b><font color="0000BB">float</font></b> crossing = min( is_small_road_crossing + is_wide_road_crossing + is_small_wide_road_crossing, <font color="#0077BB">1</font>. );
    <b><font color="0000BB">vec3</font></b> road_marking_color_white = <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">1</font>. ) * <font color="#0077BB">2</font>.;
    <b><font color="0000BB">vec3</font></b> road_marking_color_yellow = <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">1</font>., <font color="#0077BB">1</font>., <font color="#0077BB">0</font>. ) * <font color="#0077BB">2</font>.;
    <b><font color="0000BB">vec3</font></b> albedo_markings = <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">0</font>. );
    <i><font color="#FFFF00">// white lines all around</font></i>
    albedo_markings = mix( albedo_markings, road_marking_color_white, band( d1, <font color="#0077BB">0</font>.<font color="#0077BB">05</font>, <font color="#0077BB">0</font>.<font color="#0077BB">05</font> + <font color="#0077BB">0</font>.<font color="#0077BB">02</font>, aa ) );
    <i><font color="#FFFF00">// wide roads markings</font></i>
    albedo_markings = mix( albedo_markings, road_marking_color_white, band( pp.x, <font color="#0077BB">0</font>.<font color="#0077BB">01</font>, aa ) * is_wide_road.x * ( <font color="#0077BB">1</font>. - crossing ) ); <i><font color="#FFFF00">//DOTTEDLINE</font></i>
    albedo_markings = mix( albedo_markings, road_marking_color_white, band( pp.y, <font color="#0077BB">0</font>.<font color="#0077BB">01</font>, aa ) * is_wide_road.y * ( <font color="#0077BB">1</font>. - crossing ) ); <i><font color="#FFFF00">//DOTTEDLINE</font></i>
    <i><font color="#FFFF00">// small road markings</font></i>
    albedo_markings = mix( albedo_markings, road_marking_color_white, band( pp.x - /* CELL_SIZE */<b><font color="0000BB">vec3</font></b>( <font color="#0077BB">8</font>., <font color="#0077BB">8</font>., <font color="#0077BB">100</font>. ).x, <font color="#0077BB">0</font>.<font color="#0077BB">01</font>, aa ) * stripes( pp.y - /* CELL_SIZE */<b><font color="0000BB">vec3</font></b>( <font color="#0077BB">8</font>., <font color="#0077BB">8</font>., <font color="#0077BB">100</font>. ).y, <font color="#0077BB">0</font>.<font color="#0077BB">2</font>, <font color="#0077BB">0</font>.<font color="#0077BB">05</font>, aa ) * ( <font color="#0077BB">1</font>. - crossing ) ); <i><font color="#FFFF00">//DOTTEDLINE</font></i>
    albedo_markings = mix( albedo_markings, road_marking_color_white, band( pp.y - /* CELL_SIZE */<b><font color="0000BB">vec3</font></b>( <font color="#0077BB">8</font>., <font color="#0077BB">8</font>., <font color="#0077BB">100</font>. ).y, <font color="#0077BB">0</font>.<font color="#0077BB">01</font>, aa ) * stripes( pp.x - /* CELL_SIZE */<b><font color="0000BB">vec3</font></b>( <font color="#0077BB">8</font>., <font color="#0077BB">8</font>., <font color="#0077BB">100</font>. ).x, <font color="#0077BB">0</font>.<font color="#0077BB">2</font>, <font color="#0077BB">0</font>.<font color="#0077BB">05</font>, aa ) * ( <font color="#0077BB">1</font>. - crossing ) ); <i><font color="#FFFF00">//DOTTEDLINE</font></i>
    <i><font color="#FFFF00">// yellow strips alongside highway columns</font></i>
    albedo_markings = mix( albedo_markings, road_marking_color_yellow, band( d_highway_columns_zone, <font color="#0077BB">0</font>.<font color="#0077BB">05</font>, aa ) * ( <font color="#0077BB">1</font>. - is_wide_road.x ) * ( <font color="#0077BB">1</font>. - is_small_road.x ) );
    {
      <i><font color="#FFFF00">// pedestrian crossings on large roads</font></i>
      <b><font color="0000BB">float</font></b> crossing_width = <font color="#0077BB">0</font>.<font color="#0077BB">24</font>;
      <b><font color="0000BB">float</font></b> dd = <font color="#0077BB">0</font>.<font color="#0077BB">5</font>; <i><font color="#FFFF00">// where do start crossing from</font></i>
      <b><font color="0000BB">vec2</font></b> pedestrian_crossingmask = stripes( pp - ( mina + <b><font color="0000BB">vec2</font></b>( dd ) ), minb - mina - <b><font color="0000BB">vec2</font></b>( dd ) * <font color="#0077BB">2</font>., <b><font color="0000BB">vec2</font></b>( crossing_width ), <b><font color="0000BB">vec2</font></b>( aa ) );
      <b><font color="0000BB">vec2</font></b> pedestrian_crossingmask2 = stripes( pp - ( mina + <b><font color="0000BB">vec2</font></b>( dd ) ), minb - mina - <b><font color="0000BB">vec2</font></b>( dd ) * <font color="#0077BB">2</font>., <b><font color="0000BB">vec2</font></b>( crossing_width * <font color="#0077BB">1</font>.<font color="#0077BB">2</font> ), <b><font color="0000BB">vec2</font></b>( aa ) );
      pedestrian_crossingmask *= is_pure_road * ( <font color="#0077BB">1</font>. - is_highway_columns_zone );
      pedestrian_crossingmask2 *= is_pure_road * ( <font color="#0077BB">1</font>. - is_highway_columns_zone );
      albedo_markings *= ( <font color="#0077BB">1</font>. - pedestrian_crossingmask2.x ) * ( <font color="#0077BB">1</font>. - pedestrian_crossingmask2.y );
      albedo_markings = mix( albedo_markings, road_marking_color_white, stripes( pp.y, <font color="#0077BB">0</font>.<font color="#0077BB">1</font>, <font color="#0077BB">0</font>.<font color="#0077BB">025</font>, aa ) * pedestrian_crossingmask.x );
      albedo_markings = mix( albedo_markings, road_marking_color_white, stripes( pp.x, <font color="#0077BB">0</font>.<font color="#0077BB">1</font>, <font color="#0077BB">0</font>.<font color="#0077BB">025</font>, aa ) * pedestrian_crossingmask.y );
    }
    <b><font color="0000BB">float</font></b> blend = maxcomp( albedo_markings ) * is_road_or_below_highway_road * ( <font color="#0077BB">1</font>. - is_highway_columns_zone );
    albedo = mix( albedo, min( albedo_markings + road_base_color0 * <font color="#0077BB">0</font>.<font color="#0077BB">75</font>, <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">1</font>. ) ), blend );
    road_marking_material = max( road_marking_material, blend );
  }
}
<b><font color="0000BB">vec3</font></b> shadeCity( TraceCityRetval ct, <b><font color="0000BB">vec3</font></b> e, <b><font color="0000BB">vec3</font></b> v, <b><font color="0000BB">vec3</font></b> l, <b><font color="0000BB">float</font></b> shadow
                , <b><font color="0000BB">float</font></b> airliner, <b><font color="0000BB">float</font></b> a_contrast, <b><font color="0000BB">vec2</font></b> uv, <b><font color="0000BB">float</font></b> aspect, <b><font color="0000BB">float</font></b> ground_ao )
{
  <b><font color="0000BB">vec3</font></b> col = <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">0</font>. );
  <b><font color="0000BB">vec3</font></b> emitter = <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">0</font>. );
  <b><font color="0000BB">float</font></b> is_sky = (((ct.sub_id) != (/* TYPE_SKY */<font color="#0077BB">10</font>.)) ? <font color="#0077BB">0</font>. : <font color="#0077BB">1</font>.);
  <i><font color="#FFFF00">// hack stretch sky horizon so it matches our trace horizon (means the sun position won't quite match with real sun position)</font></i>
  <b><font color="0000BB">float</font></b> gamma = -e.z / /* MAX_DDA_TRACE */<font color="#0077BB">640</font>.; <i><font color="#FFFF00">//=cos(PI/2.+beta)=sin(beta), beta is the extra angle that goes into the ground</font></i>
  <b><font color="0000BB">float</font></b> alpha = -<font color="#0077BB">1</font>. / ( gamma - <font color="#0077BB">1</font>. );
  <b><font color="0000BB">vec3</font></b> v_hacked = <b><font color="0000BB">vec3</font></b>( v.xy, <font color="#0077BB">1</font>. + ( v.z - <font color="#0077BB">1</font>. ) * mix( alpha, <font color="#0077BB">1</font>., <font color="#0077BB">0</font>. ) ); <i><font color="#FFFF00">// mix control how much hack correction (alpha) we want on horizon</font></i>
  <b><font color="0000BB">vec3</font></b> skycol_view = get_sky( normalize( v_hacked ), l, <font color="#0077BB">0</font>.<font color="#0077BB">4</font> );
  <i><font color="#FFFF00">//  if ( ct.t > MAX_DDA_TRACE ) return GREEN;</font></i>
  <i><font color="#FFFF00">// sun disk</font></i>
  <b><font color="0000BB">float</font></b> sun0 = dot( l, v );
  <b><font color="0000BB">if</font></b> ( ct.sub_id == /* TYPE_SKY */<font color="#0077BB">10</font>. )
  {
    col = skycol_view;
    <i><font color="#FFFF00">// we don't need to add a disk... let get_sky do it (also we messed with horizon and therefore sun position)</font></i>
    <i><font color="#FFFF00">//    col += vec3( pow( sun, 20. ) * is_sky * 100. ); // sun disk (not flare/not glow, just the sun disk)</font></i>
    <b><font color="0000BB">float</font></b> d_airliners = <font color="#0077BB">1</font>. - pow( max( <font color="#0077BB">0</font>., sun0 ), <font color="#0077BB">8</font>. ); <i><font color="#FFFF00">// airliners</font></i>
    col = mix( col, <b><font color="0000BB">vec3</font></b>( airliner ) + d_airliners * skycol_view * <font color="#0077BB">2</font>., airliner * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> );
  }
  <b><font color="0000BB">else</font></b>
  {
    <b><font color="0000BB">ivec4</font></b> ch = <b><font color="0000BB">ivec4</font></b>( ct.split_case, ct.sub_id, ct.tile_index );
    <b><font color="0000BB">vec3</font></b> albedo = get_building_palette( hash24_( ch ) * mix( <font color="#0077BB">1</font>., <font color="#0077BB">0</font>.<font color="#0077BB">2</font>, (((ct.type) != (<font color="#0077BB">8</font>)) ? <font color="#0077BB">0</font>. : <font color="#0077BB">1</font>.) ) ); <i><font color="#FFFF00">// roof tiles use bottom left part of the 2d palette (ardoise)</font></i>
    <b><font color="0000BB">float</font></b> road_marking_material = <font color="#0077BB">0</font>.;
    surfaceColor( ct, albedo, emitter, road_marking_material );
    <b><font color="0000BB">float</font></b> kdiffuse = mix( <font color="#0077BB">0</font>.<font color="#0077BB">75</font>, <font color="#0077BB">1</font>., road_marking_material );
    <b><font color="0000BB">float</font></b> kspecular = mix( <font color="#0077BB">0</font>.<font color="#0077BB">15</font>, <font color="#0077BB">0</font>.<font color="#0077BB">8</font>, road_marking_material ) * shadow;
    <b><font color="0000BB">float</font></b> roughness = mix( <font color="#0077BB">0</font>.<font color="#0077BB">62</font>, <font color="#0077BB">0</font>.<font color="#0077BB">1</font>, road_marking_material );
    <b><font color="0000BB">if</font></b> ( ct.type == <font color="#0077BB">8</font> ) {
      kspecular = <font color="#0077BB">0</font>.<font color="#0077BB">7</font>;
      roughness = <font color="#0077BB">0</font>.<font color="#0077BB">2</font>;
    }
    <b><font color="0000BB">float</font></b> Li_sky_color_saturation = <font color="#0077BB">0</font>.<font color="#0077BB">65</font>; <i><font color="#FFFF00">// how much we blend sky color in</font></i>
    <b><font color="0000BB">vec3</font></b> skycol_top = get_sky( <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">0</font>., <font color="#0077BB">0</font>., <font color="#0077BB">1</font>. ), l, <font color="#0077BB">1</font>. );
    <b><font color="0000BB">vec3</font></b> skycol_sun = get_sky( l, l, <font color="#0077BB">1</font>. );
    <b><font color="0000BB">vec3</font></b> lr = <b><font color="0000BB">vec3</font></b>( -l.xy, l.z ); <i><font color="#FFFF00">// sun light reflected from buildings from behind ("1 bounce")</font></i>
    <b><font color="0000BB">vec3</font></b> l2 = <b><font color="0000BB">vec3</font></b>( perp( l.xy ), l.z );
    <b><font color="0000BB">vec3</font></b> l3 = <b><font color="0000BB">vec3</font></b>( -l2.xy, l.z );
    <b><font color="0000BB">vec3</font></b> Li_sky_top = mix( skycol_top, <b><font color="0000BB">vec3</font></b>( luminance( skycol_top ) ), Li_sky_color_saturation );
    <b><font color="0000BB">float</font></b> s2 = mix( <font color="#0077BB">0</font>.<font color="#0077BB">8</font>, <font color="#0077BB">1</font>., shadow );
    <i><font color="#FFFF00">// only add ambient on shadows</font></i>
    col += <font color="#0077BB">0</font>.<font color="#0077BB">005</font> * ( <font color="#0077BB">1</font>. - shadow );
    <i><font color="#FFFF00">// skydome top light (highlights rooftops, too)</font></i>
    col += s2 * add_light_contrib( albedo, <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">0</font>., <font color="#0077BB">0</font>., <font color="#0077BB">1</font>. ), ct.n, -v, Li_sky_top, <font color="#0077BB">5</font>., kdiffuse, kspecular, roughness );
    <i><font color="#FFFF00">// a couple of lateral directions, pretend Li_sky_top, this works well for our axis aligned scene...</font></i>
    col += s2 * add_light_contrib( albedo, l2, ct.n, -v, Li_sky_top, <font color="#0077BB">1</font>., kdiffuse, <font color="#0077BB">0</font>., roughness );
    col += s2 * add_light_contrib( albedo, l3, ct.n, -v, Li_sky_top, <font color="#0077BB">1</font>., kdiffuse, <font color="#0077BB">0</font>., roughness );
    <i><font color="#FFFF00">// sun light reflected by "buildings from behind" (1 bounce-ish) tip from iq's http://iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm</font></i>
    <b><font color="0000BB">vec3</font></b> Li_sky_sun_back = <font color="#0077BB">0</font>.<font color="#0077BB">2</font> * mix( skycol_sun, <b><font color="0000BB">vec3</font></b>( luminance( skycol_sun ) ), Li_sky_color_saturation );
    <i><font color="#FFFF00">// fade the highest positions as they don't get that much reflected light as there are no taller buildings, also that gives a bit of gradient</font></i>
    Li_sky_sun_back *= <font color="#0077BB">1</font>. - min( ct.p.z / ( /* MAX_BUILDING_HEIGHT */<font color="#0077BB">14</font>.<font color="#0077BB">3</font> * <font color="#0077BB">0</font>.<font color="#0077BB">8</font> ), <font color="#0077BB">1</font>. );
    col += s2 * add_light_contrib( albedo, lr, ct.n, -v, Li_sky_sun_back, <font color="#0077BB">0</font>.<font color="#0077BB">5</font>, kdiffuse, .<font color="#0077BB">0</font>, roughness );
    col *= ct.ao * ct.ao * ct.ao * mix( ground_ao, <font color="#0077BB">1</font>., exp_decay( ct.p.z * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> ) ); <i><font color="#FFFF00">// we add a simple vertical occlusion term in addition to he marched ao</font></i>
    <i><font color="#FFFF00">// direct sun light (post ao!)</font></i>
    <b><font color="0000BB">vec3</font></b> Li_sky_sun_front = mix( skycol_sun, <b><font color="0000BB">vec3</font></b>( luminance( skycol_sun ) ), Li_sky_color_saturation );
    col += shadow * add_light_contrib( albedo, l, ct.n, -v, Li_sky_sun_front, <font color="#0077BB">1</font>., kdiffuse, kspecular, roughness );
    <i><font color="#FFFF00">//    col = mix( vec3( 1., 0., 0. ), col, shadow );</font></i>
    <b><font color="0000BB">if</font></b> ( ct.type == <font color="#0077BB">4</font> )
    {
      <b><font color="0000BB">vec3</font></b> vr = reflect( v, ct.n );
      <i><font color="#FFFF00">// windows sky reflections, assumes sky fades to black in lower hemisphere</font></i>
      col += get_sky( vr, l, <font color="#0077BB">1</font>. ) * mix( <font color="#0077BB">0</font>.<font color="#0077BB">5</font>, <font color="#0077BB">1</font>., shadow );
      <i><font color="#FFFF00">// make windows a bit reflective in bottom hemisphere too</font></i>
      <i><font color="#FFFF00">// just reflect a constant "ground color", fading with distance</font></i>
      <b><font color="0000BB">if</font></b> ( v.z < <font color="#0077BB">0</font>. )
      {
        <b><font color="0000BB">float</font></b> wt = plane_trace_z( mkray( e, vr ), <font color="#0077BB">0</font>., <font color="#0077BB">1</font>.e-<font color="#0077BB">6</font> );
        <b><font color="0000BB">if</font></b> ( wt > <font color="#0077BB">0</font>. && wt != /* FLT_MAX */<font color="#0077BB">1000000</font>. )
        {
          <i><font color="#FFFF00">//          col += RED * exp( -wt * 0.09 ); // red is kind of cool too :-)</font></i>
          col += <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">32</font>, <font color="#0077BB">0</font>.<font color="#0077BB">38</font>, <font color="#0077BB">0</font>.<font color="#0077BB">47</font> ) * exp( -wt * <font color="#0077BB">0</font>.<font color="#0077BB">09</font> ) * <font color="#0077BB">0</font>.<font color="#0077BB">25</font>; <i><font color="#FFFF00">// reflect a city ground color, maybe this gradient could be a function of building height</font></i>
        }
      }
      <i><font color="#FFFF00">// upper hemisphere window reflections (sky and office neon)</font></i>
      <b><font color="0000BB">if</font></b> ( v.z > <font color="#0077BB">0</font>. )
      {
        <i><font color="#FFFF00">// cheap but efficient neon hack</font></i>
        Ray vr = mkray( e, v );
        <b><font color="0000BB">float</font></b> wt = plane_trace_z( vr, ceil( ct.p.z / /*FLOOR_HEIGHT*/<font color="#0077BB">0</font>.<font color="#0077BB">6</font> ) * /*FLOOR_HEIGHT*/<font color="#0077BB">0</font>.<font color="#0077BB">6</font>, <font color="#0077BB">1</font>.e-<font color="#0077BB">6</font> ); <i><font color="#FFFF00">// infinite neon plane</font></i>
        <b><font color="0000BB">if</font></b> ( wt > <font color="#0077BB">0</font>. && wt != /* FLT_MAX */<font color="#0077BB">1000000</font>. )
        {
          <b><font color="0000BB">vec3</font></b> wp = vr.o + vr.d * wt;
          <b><font color="0000BB">float</font></b> neondepth = dot( ct.p - wp, ct.n );
          <b><font color="0000BB">vec2</font></b> y = normalize( ct.n.xy );
          <b><font color="0000BB">vec2</font></b> x = -perp( y );
          <b><font color="0000BB">float</font></b> dneon = sd_bounds_repeat_range_range( wp.x * x + wp.y * y, <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>., <font color="#0077BB">0</font>. ), <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">8</font>, <font color="#0077BB">0</font>.<font color="#0077BB">3</font> ) <i><font color="#FFFF00">// neon periodicity</font></i>
                        , <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>., <font color="#0077BB">0</font>. ), <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">34</font>, <font color="#0077BB">0</font>.<font color="#0077BB">05</font> ) ); <i><font color="#FFFF00">// neon size</font></i>
          col += step( dneon, <font color="#0077BB">0</font>. ) * exp2( -neondepth * <font color="#0077BB">2</font>.<font color="#0077BB">8</font> );
        }
      }
    }
    col += (((ct.type) != (<font color="#0077BB">1</font>)) ? <font color="#0077BB">0</font>. : <font color="#0077BB">1</font>.) * <font color="#0077BB">0</font>.<font color="#0077BB">9</font>;
    col += emitter;
    <i><font color="#FFFF00">//    vec3 fog_color = mix( RED, GREEN, pow( ( sun0 + 1. ) * 0.5, mix( 7., 40., shadow ) ) );</font></i>
    <b><font color="0000BB">vec3</font></b> fog_color = mix( skycol_top * <font color="#0077BB">1</font>.<font color="#0077BB">5</font>, skycol_sun, pow( ( sun0 + <font color="#0077BB">1</font>. ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>, mix( <font color="#0077BB">7</font>., <font color="#0077BB">5</font>., shadow ) ) ); <i><font color="#FFFF00">// skycol_top color is a bit weak so boost it a bit</font></i>
    col += fog_color * <font color="#0077BB">0</font>.<font color="#0077BB">55</font> * exp_decay( ct.t * <font color="#0077BB">0</font>.<font color="#0077BB">002</font> + ct.p.z * <font color="#0077BB">0</font>.<font color="#0077BB">007</font> ); <i><font color="#FFFF00">// some kind of inscatter (so we add), along view distance and world height</font></i>
    col = mix( col, skycol_view, smoothstep( /* FADE_START */<font color="#0077BB">480</font>., /* MAX_DDA_TRACE */<font color="#0077BB">640</font>., ct.t ) ); <i><font color="#FFFF00">// fade with background</font></i>
    <i><font color="#FFFF00">//    if ( ct.t > FADE_START ) return RED;</font></i>
    <i><font color="#FFFF00">//    return skycol_view;</font></i>
    <i><font color="#FFFF00">//    return skycol_top * 8.;</font></i>
    <i><font color="#FFFF00">//    return skycol_sun;</font></i>
    <i><font color="#FFFF00">//    return col;</font></i>
  }
  col = <font color="#0077BB">3</font>.<font color="#0077BB">5</font> * tonemap_reinhard( col ); <i><font color="#FFFF00">// expose</font></i>
  <i><font color="#FFFF00">//  col = max( vec3( 0. ), contrast( col, vec3( a_contrast ) ) ); // post process</font></i>
  col *= .<font color="#0077BB">2</font> + <font color="#0077BB">0</font>.<font color="#0077BB">8</font> * pow( <font color="#0077BB">20</font>. * uv.x * uv.y * ( <font color="#0077BB">1</font>. - uv.x ) * ( <font color="#0077BB">1</font>. - uv.y ), <font color="#0077BB">0</font>.<font color="#0077BB">075</font> ); <i><font color="#FFFF00">// vignette</font></i>
  col = gamma_correction_itu( col );
  <i><font color="#FFFF00">//  if ( v.z < 0. ) col = RED; // view real horizon</font></i>
  <b><font color="0000BB">return</font></b> col;
}
<i><font color="#FFFF00">// building heights distribution function</font></i>
<b><font color="0000BB">vec4</font></b> icdf( <b><font color="0000BB">vec4</font></b> x ) {
  <b><font color="0000BB">return</font></b> mix( saturate( safe_acos( <b><font color="0000BB">vec4</font></b>( <font color="#0077BB">1</font>. ) - <font color="#0077BB">4</font>. * x ) / <font color="#0077BB">3</font>.<font color="#0077BB">141592654</font> ), (x - <b><font color="0000BB">vec4</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">5</font> )) * <font color="#0077BB">0</font>.<font color="#0077BB">1</font>, step( <font color="#0077BB">0</font>.<font color="#0077BB">5</font>, x ) );
}
ParametricBuildingRetval sd_ParametricBuilding( <b><font color="0000BB">float</font></b> t, <b><font color="0000BB">vec3</font></b> p, <b><font color="0000BB">float</font></b> building_type, bounds2 b2, <b><font color="0000BB">float</font></b> height, NearestHighwayRetval nh, <b><font color="0000BB">vec3</font></b> rnd )
{
  <b><font color="0000BB">if</font></b> ( building_type == <font color="#0077BB">0</font>. ) <b><font color="0000BB">return</font></b> sd_House( p, t, b2, min( height, <font color="#0077BB">2</font>. ), nh );
  <b><font color="0000BB">return</font></b> sd_Building( t, p, b2, height, nh, rnd );
}
<b><font color="0000BB">struct</font></b> ParametricBuildingHit
{
  <b><font color="0000BB">float</font></b> t;
  <b><font color="0000BB">float</font></b> tile_child_index;
  <b><font color="0000BB">float</font></b> building_type; <i><font color="#FFFF00">// 0:house 1:building (could use 0. and 4. instead)</font></i>
  <b><font color="0000BB">float</font></b> height;
  bounds2 b2;
  <b><font color="0000BB">float</font></b> d;
  <b><font color="0000BB">vec3</font></b> windr;
  <b><font color="0000BB">float</font></b> is_roof;
  Ray ray2; <i><font color="#FFFF00">// potentially permuted ray</font></i>
  <b><font color="0000BB">bool</font></b> permuted;
  NearestHighwayRetval nh;
  <b><font color="0000BB">vec3</font></b> rnd;
};
<b><font color="0000BB">void</font></b> rayMarchParametricBuilding( Ray ray2, <b><font color="0000BB">bool</font></b> permuted, <b><font color="0000BB">vec2</font></b> ri, bounds3 bi, <b><font color="0000BB">float</font></b> kk, <b><font color="0000BB">inout</font></b> ParametricBuildingHit hit, <b><font color="0000BB">vec2</font></b> cell_index )
{
  <b><font color="0000BB">if</font></b> ( ri.y <= ri.x || ri.y < <font color="#0077BB">0</font>. ) <b><font color="0000BB">return</font></b>; <i><font color="#FFFF00">// no hit</font></i>
  ri.x = max( ri.x, <font color="#0077BB">0</font>. );
  <i><font color="#FFFF00">// warning: if you fiddle with early return here, check what happens to the shadow term!</font></i>
  bounds2 b2 = mkbounds_unchecked( bi.pmin.xy, bi.pmax.xy ); <i><font color="#FFFF00">// b2 is in maybe permuted space and contains the object</font></i>
  <b><font color="0000BB">vec2</font></b> base_size = size( b2 ); <i><font color="#FFFF00">// this is the base size with x and y maybe permuted</font></i>
  <i><font color="#FFFF00">//  if ( base_size.x <= 0. || base_size.y <= 0. ) return; // doesn't seem to contribute to the image... and is slower?</font></i>
  NearestHighwayRetval nh;
  nh.d = /* FLT_MAX */<font color="#0077BB">1000000</font>.; <i><font color="#FFFF00">// disable the clip plane</font></i>
  {
    <i><font color="#FFFF00">// some basic layout intersection tests outside marching loop... tedious block of code</font></i>
    <b><font color="0000BB">vec2</font></b> b2c = center( b2 );
    <b><font color="0000BB">vec2</font></b> b2s = base_size; <i><font color="#FFFF00">// size( b2 )</font></i>
    <b><font color="0000BB">if</font></b> ( permuted ) <i><font color="#FFFF00">// remember: b2 is in permuted space, dont use it in calculations below</font></i>
    {
      b2c = b2c.yx; <i><font color="#FFFF00">// back to world</font></i>
      b2s = b2s.yx;
    }
    nh = evalHighway( b2c );
    nh.o_clip = nh.p + nh.d2f.xy; <i><font color="#FFFF00">// closest highway center line point (b2c==nh.p)</font></i>
    nh.n_clip = normalize( perp( nh.d2f.zw ) ); <i><font color="#FFFF00">// can't use hret2.d2f.xy as it may be null</font></i>
    <i><font color="#FFFF00">//    float b2cd = dot( b2c - nh.o_clip, nh.n_clip ); // distance to higway center line, signed</font></i>
    <b><font color="0000BB">float</font></b> b2cd = dot( -nh.d2f.xy, nh.n_clip ); <i><font color="#FFFF00">// should be same as above, saves a sub (lol)</font></i>
    nh.n_clip *= sign( b2cd ); <i><font color="#FFFF00">// orient the clip normal so we can build a facade (box center is on positive side)</font></i>
    b2cd = abs( b2cd ); <i><font color="#FFFF00">// now we are on the positive side</font></i>
    <b><font color="0000BB">float</font></b> ml = length( b2s );
    <b><font color="0000BB">if</font></b> ( b2cd > ( ml + ((<font color="#0077BB">1</font>.) * <font color="#0077BB">2</font>.) ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> ) nh.d = /* FLT_MAX */<font color="#0077BB">1000000</font>.; <i><font color="#FFFF00">// building far away enough regardless of rotation, disable the clip plane</font></i>
    <b><font color="0000BB">else</font></b>
    {
      <b><font color="0000BB">float</font></b> l = b2s.y; <i><font color="#FFFF00">// (fixme: corrected with slope) if we can assume horizonal ish roads</font></i>
      <b><font color="0000BB">float</font></b> clipped_l = ( b2cd + l * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> ) - max( b2cd - l * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>, (<font color="#0077BB">1</font>.) ); <i><font color="#FFFF00">// size left after clipping</font></i>
      base_size = b2s;
      base_size.y = clipped_l;
      <i><font color="#FFFF00">// if the building was ultra thin to begin with, clipping is not going to make things any better</font></i>
      <i><font color="#FFFF00">// that filters out some garbage thin buildings</font></i>
      <b><font color="0000BB">if</font></b> ( maxcomp( base_size ) > <font color="#0077BB">10</font>. * mincomp( base_size ) ) <b><font color="0000BB">return</font></b>;
    }
    <i><font color="#FFFF00">//    nh.d = FLT_MAX; // uncomment to check actual size of building if they weren't clipped</font></i>
    <b><font color="0000BB">if</font></b> ( permuted )
    {
      <i><font color="#FFFF00">// back to permuted space</font></i>
      nh.p = nh.p.yx;
      nh.pr = nh.pr.yx;
      nh.d2f = nh.d2f.yxwz;
      nh.n_clip = nh.n_clip.yx;
      nh.o_clip = nh.o_clip.yx;
    }
  }
  <b><font color="0000BB">float</font></b> height = bi.pmax.z; <i><font color="#FFFF00">// pmax.z awkward?</font></i>
  <i><font color="#FFFF00">// make height not bigger than n times the smallest dimension on the 2d base, not that base_size may be permuted, we only care about the min dimension</font></i>
  height = min( height, <font color="#0077BB">8</font>. * mincomp( base_size ) );
  <b><font color="0000BB">float</font></b> building_type = height < <font color="#0077BB">3</font>.<font color="#0077BB">4</font> ? <font color="#0077BB">0</font>. : <font color="#0077BB">1</font>.;
  <b><font color="0000BB">if</font></b> ( building_type == <font color="#0077BB">1</font>. ) height = ( <font color="#0077BB">0</font>.<font color="#0077BB">5</font> + floor( height / /*FLOOR_HEIGHT*/<font color="#0077BB">0</font>.<font color="#0077BB">6</font> - <font color="#0077BB">0</font>.<font color="#0077BB">5</font> ) ) * /*FLOOR_HEIGHT*/<font color="#0077BB">0</font>.<font color="#0077BB">6</font>; <i><font color="#FFFF00">// make building height a multiple of floor height</font></i>
  <b><font color="0000BB">float</font></b> t = ri.x; <i><font color="#FFFF00">// start marching from first hit point</font></i>
  <b><font color="0000BB">vec3</font></b> rnd = <b><font color="0000BB">vec3</font></b>( cell_index, kk );
  <b><font color="0000BB">for</font></b> ( <b><font color="0000BB">int</font></b> j = <font color="#0077BB">0</font>; j < <font color="#0077BB">70</font> /*FORCE_LOOP*/ + min(<font color="#0077BB">0</font>, iFrame); ++j )
  {
    <i><font color="#FFFF00">// no need to trace further than max cell size == massive win</font></i>
    <i><font color="#FFFF00">// we then have to pick a max trace distance, for that cell 2d diagonal size would be a start</font></i>
    <i><font color="#FFFF00">// but since cell height is higher than max building height, we use max building height instead</font></i>
    <b><font color="0000BB">if</font></b> ( t - ri.x > /* MAX_BUILDING_HEIGHT */<font color="#0077BB">14</font>.<font color="#0077BB">3</font> ) <b><font color="0000BB">break</font></b>;
    <b><font color="0000BB">vec3</font></b> p = ray2.o + t * ray2.d;
    ParametricBuildingRetval ddd = sd_ParametricBuilding( t, p, building_type, b2, height, nh, rnd );
    <b><font color="0000BB">float</font></b> d = ddd.d;
    <b><font color="0000BB">if</font></b> ( abs( d ) <= <font color="#0077BB">0</font>.<font color="#0077BB">001</font> * t )
    {
      <b><font color="0000BB">if</font></b> ( t < hit.t ) <i><font color="#FFFF00">// we need to check vs other objects in the cell</font></i>
      {
        <i><font color="#FFFF00">// record a few things we need to do extra evals deriving from the final hit</font></i>
        hit.t = t;
        hit.tile_child_index = kk;
        hit.building_type = building_type;
        hit.b2 = b2;
        hit.height = height;
        hit.d = d;
        hit.windr = ddd.windr;
        hit.is_roof = step( abs( d - ddd.droof ), <font color="#0077BB">0</font>.<font color="#0077BB">001</font> );
        hit.ray2 = ray2;
        hit.permuted = permuted;
        hit.nh = nh;
        hit.rnd = rnd;
      }
      <b><font color="0000BB">break</font></b>; <i><font color="#FFFF00">// "return" is slower on radeon: 29ms -> 31ms (ancient wip timings)</font></i>
    }
    <b><font color="0000BB">float</font></b> dt = d;
    <i><font color="#FFFF00">//    float dt = d * TFRAC; // shadows a bit better with this</font></i>
    <i><font color="#FFFF00">//    float dt = abs( d ); // *TFRAC // only move forward (see inside of buildings...)</font></i>
    t += dt;
    <i><font color="#FFFF00">//    p += dt * ray2.d; // do not do this, instead increment t and reevaluate p fully (loss of precision else)</font></i>
  }
}
<b><font color="0000BB">void</font></b> rayMarchCellObjects( Ray ray2, Ranges_x4 iv, <b><font color="0000BB">bool</font></b> permuted, <b><font color="0000BB">inout</font></b> ParametricBuildingHit hit, <b><font color="0000BB">vec2</font></b> cell_index, <b><font color="0000BB">bool</font></b> shadow_trace )
{
  <b><font color="0000BB">vec2</font></b> ranges[<font color="#0077BB">4</font>] = <b><font color="0000BB">vec2</font></b>[<font color="#0077BB">4</font>]( iv.rA, iv.rB, iv.rC, iv.rD );
  bounds3 b4s[<font color="#0077BB">4</font>] = bounds3[<font color="#0077BB">4</font>]( iv.bA, iv.bB, iv.bC, iv.bD );
  <b><font color="0000BB">for</font></b> ( <b><font color="0000BB">int</font></b> i = <font color="#0077BB">0</font>; i < ( <font color="#0077BB">4</font> /*FORCE_LOOP*/ + min(<font color="#0077BB">0</font>, iFrame) ); ++i )
  {
    rayMarchParametricBuilding( ray2, permuted, ranges[i], b4s[i], <b><font color="0000BB">float</font></b>( i ), hit, cell_index );
  }
}
<i><font color="#FFFF00">// ray march buildings in a cell</font></i>
<b><font color="0000BB">void</font></b> traceBuildings( Ray a_ray, <b><font color="0000BB">inout</font></b> TraceCityRetval ct, <b><font color="0000BB">float</font></b> split_cells_spacing, <b><font color="0000BB">bool</font></b> shadow_trace )
{
  <b><font color="0000BB">float</font></b> maxh = /* MAX_BUILDING_HEIGHT */<font color="#0077BB">14</font>.<font color="#0077BB">3</font>;
  <b><font color="0000BB">float</font></b> minh = <font color="#0077BB">2</font>.;
  <b><font color="0000BB">float</font></b> rmin = -<font color="#0077BB">0</font>.<font color="#0077BB">1</font>;
  <b><font color="0000BB">float</font></b> rmax = max( <font color="#0077BB">1</font>., maxh );
  <i><font color="#FFFF00">// we only dda trace the rmin, rmax z range</font></i>
  <b><font color="0000BB">float</font></b> tbottom = plane_trace_z( a_ray, rmin, <font color="#0077BB">1</font>e-<font color="#0077BB">6</font> );
  <b><font color="0000BB">float</font></b> ttop = plane_trace_z( a_ray, rmax, <font color="#0077BB">1</font>e-<font color="#0077BB">6</font> );
  <b><font color="0000BB">vec2</font></b> r0 = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>., /* MAX_DDA_TRACE */<font color="#0077BB">640</font>. );
  <b><font color="0000BB">vec2</font></b> r1 = <b><font color="0000BB">vec2</font></b>( min( ttop, tbottom ), max( ttop, tbottom ) );
  <b><font color="0000BB">vec2</font></b> r2 = <b><font color="0000BB">vec2</font></b>( max( r0.x, r1.x ), min( r0.y, r1.y ) ); <i><font color="#FFFF00">// intersection of r0 and r1</font></i>
  <i><font color="#FFFF00">//  if ( r2.y <= r2.x ) return; // non sensical per drop if we return...</font></i>
  r2 *= step( r2.x, r2.y ); <i><font color="#FFFF00">// ...so instead do a zero length iteration</font></i>
  <b><font color="0000BB">float</font></b> start_t = r2.x; <i><font color="#FFFF00">// remember initial jump to return something along a_ray</font></i>
  Ray ray = mkray( a_ray.o + a_ray.d * start_t, a_ray.d ); <i><font color="#FFFF00">// warp to tmin</font></i>
  <b><font color="0000BB">vec3</font></b> ray_end = a_ray.o + a_ray.d * r2.y;
  DDA3 dda = dda_init( ray.o, ray_end, /* CELL_SIZE */<b><font color="0000BB">vec3</font></b>( <font color="#0077BB">8</font>., <font color="#0077BB">8</font>., <font color="#0077BB">100</font>. ), <b><font color="0000BB">false</font></b> );
  <i><font color="#FFFF00">// trace within dda traversed cell</font></i>
  ParametricBuildingHit hit;
  hit.t = /* FLT_MAX */<font color="#0077BB">1000000</font>.;
  <b><font color="0000BB">float</font></b> split_case = -<font color="#0077BB">1</font>.;
  <i><font color="#FFFF00">// dda traverse</font></i>
  <b><font color="0000BB">for</font></b> ( <b><font color="0000BB">int</font></b> i = <font color="#0077BB">0</font>; i < ( <font color="#0077BB">37</font> /*FORCE_LOOP*/ + min(<font color="#0077BB">0</font>, iFrame) )
        && dot( dda.p - a_ray.o, dda.p - a_ray.o ) < r2.y * r2.y; ++i )
  {
    <i><font color="#FFFF00">// raytrace 4 boxes inside each cell</font></i>
    bounds2 b = mkbounds_unchecked( dda.c.xy * /* CELL_SIZE */<b><font color="0000BB">vec3</font></b>( <font color="#0077BB">8</font>., <font color="#0077BB">8</font>., <font color="#0077BB">100</font>. ).xy, ( dda.c.xy + <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">1</font>., <font color="#0077BB">1</font>. ) ) * /* CELL_SIZE */<b><font color="0000BB">vec3</font></b>( <font color="#0077BB">8</font>., <font color="#0077BB">8</font>., <font color="#0077BB">100</font>. ).xy ); <i><font color="#FFFF00">// cell bounds</font></i>
    <b><font color="0000BB">ivec2</font></b> index = <b><font color="0000BB">ivec2</font></b>( dda.c.xy );
    <b><font color="0000BB">vec4</font></b> a; a.xy = /* CELL_SPACING */<b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">47</font>, <font color="#0077BB">1</font>.<font color="#0077BB">3</font> ).xy * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>; a.zw = a.xy;
    <b><font color="0000BB">if</font></b> ( ( index.x & <font color="#0077BB">1</font> ) == <font color="#0077BB">0</font> ) a.xy = a.yx;
    <b><font color="0000BB">if</font></b> ( ( index.y & <font color="#0077BB">1</font> ) == <font color="#0077BB">0</font> ) a.zw = a.wz;
    b.pmin.xy += a.xz; <i><font color="#FFFF00">// shrink cell bounds according to street margins (we alternate wide and narrow streets hence logic above)</font></i>
    b.pmax.xy -= a.yw;
    <b><font color="0000BB">vec2</font></b> margin = <b><font color="0000BB">vec2</font></b>( split_cells_spacing * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> + <font color="#0077BB">0</font>.<font color="#0077BB">2</font> );
    <b><font color="0000BB">vec2</font></b> r55 = hash22_( index ); <i><font color="#FFFF00">// split type, permute</font></i>
    Ray ray2 = ray;
    <b><font color="0000BB">bool</font></b> permuted = <b><font color="0000BB">false</font></b>;
    <b><font color="0000BB">if</font></b> ( r55.y > <font color="#0077BB">0</font>.<font color="#0077BB">5</font> )
    {
      <i><font color="#FFFF00">// random permutations, else default patterns look more or less all aligned</font></i>
      ray2.o.xyz = ray.o.yxz;
      ray2.d.xyz = ray.d.yxz;
      b.pmin.xy = b.pmin.yx;
      b.pmax.xy = b.pmax.yx;
      permuted = <b><font color="0000BB">true</font></b>;
    }
    <b><font color="0000BB">vec4</font></b> r4 = icdf( hash42_( index * <font color="#0077BB">0</font>x<font color="#0077BB">8</font>da6b343 ) ); <i><font color="#FFFF00">// heights hash</font></i>
    <b><font color="0000BB">vec4</font></b> rheights = mix( <b><font color="0000BB">vec4</font></b>( minh ), <b><font color="0000BB">vec4</font></b>( maxh ), r4 );
    <b><font color="0000BB">vec4</font></b> r3 = hash42_( index * <font color="#0077BB">0</font>xb68f63e4 ); <i><font color="#FFFF00">// split hash</font></i>
    <b><font color="0000BB">vec4</font></b> r3_0 = r3;
    r3.xyw = mix( <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">1</font>. ), <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">5</font>. ), r3.xyw ); <i><font color="#FFFF00">// ratio of smallest to largest size</font></i>
    r3.xy = fractions( r3.xyw ); <i><font color="#FFFF00">// use r3.xyw as relative unit sizes</font></i>
    r3.z = mix( <font color="#0077BB">0</font>.<font color="#0077BB">2</font>, <font color="#0077BB">0</font>.<font color="#0077BB">8</font>, r3.z );
    Ranges_x4 iv;
    Split4bSetup s4su = setup_Split4b( ray2, b.pmin.xy, b.pmax.xy, margin );
    <i><font color="#FFFF00">// select a tile split pattern</font></i>
    <b><font color="0000BB">if</font></b> ( r55.x > <font color="#0077BB">0</font>.<font color="#0077BB">75</font> )
    {
      bound_Split4b_xxy( iv, ray2, b.pmin.xy, b.pmax.xy, mix( b.pmin.xxy, b.pmax.xxy, r3.xyz ), rheights, margin );
      trace_Split4b_xxy( iv, ray2, s4su, mix( b.pmin.xxy, b.pmax.xxy, r3.xyz ), rheights );
      split_case = <font color="#0077BB">0</font>.;
    }
    <b><font color="0000BB">else</font></b> <b><font color="0000BB">if</font></b> ( r55.x > <font color="#0077BB">0</font>.<font color="#0077BB">5</font> )
    {
      r3.xyz = fractions( mix( <b><font color="0000BB">vec4</font></b>( <font color="#0077BB">2</font>. ), <b><font color="0000BB">vec4</font></b>( <font color="#0077BB">3</font>. ), r3_0 ) );
      bound_Split4b_xxx( iv, ray2, b.pmin.xy, b.pmax.xy, mix( b.pmin.xxx, b.pmax.xxx, r3.xyz ), rheights, margin );
      trace_Split4b_xxx( iv, ray2, s4su, mix( b.pmin.xxx, b.pmax.xxx, r3.xyz ), rheights );
      split_case = <font color="#0077BB">1</font>.;
    }
    <b><font color="0000BB">else</font></b> <b><font color="0000BB">if</font></b> ( r55.x > <font color="#0077BB">0</font>.<font color="#0077BB">25</font> )
    {
      bound_Split4b_xyy( iv, ray2, b.pmin.xy, b.pmax.xy, mix( b.pmin.xyy, b.pmax.xyy, r3.zxy ), rheights, margin );
      trace_Split4b_xyy( iv, ray2, s4su, mix( b.pmin.xyy, b.pmax.xyy, r3.zxy ), rheights );
      split_case = <font color="#0077BB">2</font>.;
    }
    <b><font color="0000BB">else</font></b>
    {
      bound_Split4b_xyx( iv, ray2, b.pmin.xy, b.pmax.xy, mix( b.pmin.xyx, b.pmax.xyx, r3.xzy ), rheights, margin );
      trace_Split4b_xyx( iv, ray2, s4su, mix( b.pmin.xyx, b.pmax.xyx, r3.xzy ), rheights );
      split_case = <font color="#0077BB">3</font>.;
    }
    hit.t = /* FLT_MAX */<font color="#0077BB">1000000</font>.;
    hit.tile_child_index = -<font color="#0077BB">1</font>.; <i><font color="#FFFF00">// no hit</font></i>
    rayMarchCellObjects( ray2, iv, permuted, hit, dda.c.xy, shadow_trace );
    <b><font color="0000BB">if</font></b> ( hit.t != /* FLT_MAX */<font color="#0077BB">1000000</font>. ) <b><font color="0000BB">break</font></b>; <i><font color="#FFFF00">// we have hit, gtfo and fill other extra bits out of the loop</font></i>
    <i><font color="#FFFF00">//    if ( hit.t > ct.t ) return; // fixme: no point in continuing, but we should just set dda end point instead</font></i>
    dda_step_infinite( dda ); <i><font color="#FFFF00">// make sure you set a_finite to false in dda_init when calling this version</font></i>
  }
  <b><font color="0000BB">if</font></b> ( hit.t >= ct.t ) <b><font color="0000BB">return</font></b>; <i><font color="#FFFF00">// ct.t might be FLT_MAX so >= is important here</font></i>
  <i><font color="#FFFF00">// we hit a building</font></i>
  ct.p = ray.o + hit.t * ray.d;
  ct.t = start_t + hit.t; <i><font color="#FFFF00">// remember that we jumped at start</font></i>
  <b><font color="0000BB">if</font></b> ( shadow_trace ) <b><font color="0000BB">return</font></b>; <i><font color="#FFFF00">// we don't need normal, ao, material... gtfo</font></i>
  <i><font color="#FFFF00">// house type will use type index [0,3], building type will use index [4,7]</font></i>
  pack_info( ct, dda.c.xy, split_case, hit.tile_child_index + hit.building_type * <font color="#0077BB">4</font>. );
  <b><font color="0000BB">vec3</font></b> p = hit.ray2.o + hit.t * hit.ray2.d;
  <b><font color="0000BB">vec3</font></b> h = <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">01</font>, <font color="#0077BB">0</font>., <font color="#0077BB">0</font>. ); <i><font color="#FFFF00">// h.x *= hit.t; // grainy normals tweak</font></i>
  ct.n = normalize( <b><font color="0000BB">vec3</font></b>( sd_ParametricBuilding( hit.t, p + h.xyz, hit.building_type, hit.b2, hit.height, hit.nh, hit.rnd ).d,
                          sd_ParametricBuilding( hit.t, p + h.zxy, hit.building_type, hit.b2, hit.height, hit.nh, hit.rnd ).d,
                          sd_ParametricBuilding( hit.t, p + h.yzx, hit.building_type, hit.b2, hit.height, hit.nh, hit.rnd ).d )
                    - hit.d ); <i><font color="#FFFF00">// hit.d should be equal to sd_ParametricBuilding( hit.t, p, hit.building_type, hit.b2, hit.height, hit.nh, hit.rnd ).d</font></i>
  <i><font color="#FFFF00">// do ao in permuted space</font></i>
  {
    Ray ao_ray = mkray( p, ct.n );
  { /* ao algo from http:<i><font color="#FFFF00">//www.iquilezles.org/www/material/nvscene2008/rwwtt.pdf macrofified to avoid repetition */ float _delta = 0.1, _a = 0.0, _b = 1.0; for ( int _i = 0; _i < 5 /*FORCE_LOOP*/ + min(0, iFrame); _i++ ) {</font></i>
        <b><font color="0000BB">float</font></b> _fi = <b><font color="0000BB">float</font></b>( _i ); <b><font color="0000BB">float</font></b> _ao_t = _delta * _fi;
        <b><font color="0000BB">float</font></b> d = sd_ParametricBuilding( _ao_t, ao_ray.o + _ao_t * ao_ray.d, hit.building_type, hit.b2, hit.height, hit.nh, hit.rnd ).d;
        _a += ( _ao_t - d ) * _b; _b *= <font color="#0077BB">0</font>.<font color="#0077BB">5</font>;
      } ct.ao = max( <font color="#0077BB">1</font>.<font color="#0077BB">0</font> - <font color="#0077BB">1</font>.<font color="#0077BB">2</font> * _a, <font color="#0077BB">0</font>.<font color="#0077BB">0</font> );
    }
  }
  <b><font color="0000BB">if</font></b> ( hit.is_roof > <font color="#0077BB">0</font>. ) ct.type = <font color="#0077BB">8</font>;
  <b><font color="0000BB">if</font></b> ( ( abs( hit.d - hit.windr.x ) < <font color="#0077BB">0</font>.<font color="#0077BB">001</font> ) <i><font color="#FFFF00">// distance must be close to windows plane, stored in hit.windr.x</font></i>
       && ( <font color="#0077BB">0</font>.<font color="#0077BB">01</font> < abs( dot( hit.windr.yz, ct.n.xy ) ) ) <i><font color="#FFFF00">// normal must match window orientation</font></i>
       <i><font color="#FFFF00">// normal must be vertical</font></i>
       && ( abs( ct.n.z ) < <font color="#0077BB">0</font>.<font color="#0077BB">005</font> ) ) ct.type = <font color="#0077BB">4</font>;
  <b><font color="0000BB">if</font></b> ( hit.permuted ) ct.n.xy = ct.n.yx;
}
TraceCityRetval traceCity( Ray ray, <b><font color="0000BB">bool</font></b> shadow_trace )
{
  TraceCityRetval ct;
  pack_info1( ct, /* FLT_MAX */<font color="#0077BB">1000000</font>., <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">0</font>. ), <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">0</font>. ), <font color="#0077BB">1</font>., <font color="#0077BB">0</font> );
  pack_info( ct, <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>. ), <font color="#0077BB">0</font>., /* TYPE_SKY */<font color="#0077BB">10</font>. );
  <b><font color="0000BB">float</font></b> split_cells_spacing = <font color="#0077BB">0</font>.<font color="#0077BB">025</font>;
  {
    <i><font color="#FFFF00">// raytrace ground to close the horizon, only matters at street level (in bird view buildings occlude everything so it's useless) and traceBuildings needs its own ground for AO</font></i>
    <b><font color="0000BB">float</font></b> t = plane_trace_z( ray, <font color="#0077BB">0</font>., <font color="#0077BB">1</font>e-<font color="#0077BB">6</font> );
    <b><font color="0000BB">if</font></b> ( <font color="#0077BB">0</font>. < t && t < ct.t && t < /* MAX_DDA_TRACE */<font color="#0077BB">640</font>. ) <i><font color="#FFFF00">// use a max distance so the infinite plane doesn't extend beyond buildings horizon</font></i>
    {
      pack_info1( ct, t, <b><font color="0000BB">vec3</font></b>( ( ray.o + t * ray.d ).xy, <font color="#0077BB">0</font>. ), <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">0</font>., <font color="#0077BB">0</font>., <font color="#0077BB">1</font>. ), <font color="#0077BB">1</font>., <font color="#0077BB">0</font> );
      pack_info( ct, <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>. ), <font color="#0077BB">0</font>., /* TYPE_ROAD */<font color="#0077BB">9</font>. );
    }
  }
  <b><font color="0000BB">if</font></b> ( !/* SHADOW_EARLY_RET */(shadow_trace && ((ct.t) !=/* FLT_MAX */<font color="#0077BB">1000000</font>.)) )
  {
    <i><font color="#FFFF00">// assuming highway is at constant height, we can raytrace that too and close a lot of the sdf marching hole at vanishing point</font></i>
    <b><font color="0000BB">float</font></b> t = plane_trace_z( ray, <font color="#0077BB">2</font>., <font color="#0077BB">1</font>e-<font color="#0077BB">6</font> );
    <b><font color="0000BB">if</font></b> ( <font color="#0077BB">0</font>. < t && t < ct.t && t < /* MAX_HIGHWAY_TRACE */<font color="#0077BB">640</font>. )
    {
      <b><font color="0000BB">vec3</font></b> p = ray.o + t * ray.d; <i><font color="#FFFF00">// hit point</font></i>
      <b><font color="0000BB">if</font></b> ( evalHighway( p.xy ).d < (<font color="#0077BB">1</font>.) )
      {
        pack_info1( ct, t, p, <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">0</font>., <font color="#0077BB">0</font>., <font color="#0077BB">1</font>. ), <font color="#0077BB">1</font>., <font color="#0077BB">0</font> );
        pack_info( ct, <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>. ), <font color="#0077BB">0</font>., /* TYPE_HIGHWAY */<font color="#0077BB">8</font>. );
      }
    }
  }
  <b><font color="0000BB">if</font></b> ( !/* SHADOW_EARLY_RET */(shadow_trace && ((ct.t) !=/* FLT_MAX */<font color="#0077BB">1000000</font>.)) ) traceBuildings( ray, ct, split_cells_spacing, shadow_trace );
  <b><font color="0000BB">if</font></b> ( !/* SHADOW_EARLY_RET */(shadow_trace && ((ct.t) !=/* FLT_MAX */<font color="#0077BB">1000000</font>.)) )
  {
    <i><font color="#FFFF00">// ray marched scene component</font></i>
    <b><font color="0000BB">float</font></b> t = <font color="#0077BB">0</font>.;
    <b><font color="0000BB">bool</font></b> hit = <b><font color="0000BB">false</font></b>;
    <b><font color="0000BB">vec3</font></b> p, dd;
    <i><font color="#FFFF00">// narrow fov need 200</font></i>
    <b><font color="0000BB">for</font></b> ( <b><font color="0000BB">int</font></b> j = <font color="#0077BB">0</font>; j < <font color="#0077BB">110</font> /*FORCE_LOOP*/ + min(<font color="#0077BB">0</font>, iFrame); ++j )
    {
      p = ray.o + t * ray.d;
      dd = sd_RayMarchedCityBits( p, <font color="#0077BB">0</font> );
      <b><font color="0000BB">bool</font></b> has_hit = abs( dd.x ) <= <font color="#0077BB">0</font>.<font color="#0077BB">001</font> * t; <i><font color="#FFFF00">// no need to trace further than first building hit, or ground hit</font></i>
      <b><font color="0000BB">bool</font></b> too_far = t > /* MAX_HIGHWAY_TRACE */<font color="#0077BB">640</font>. || t > ct.t; <i><font color="#FFFF00">// hide glitter artifact in the distance, saves some ms too</font></i>
      <b><font color="0000BB">if</font></b> ( has_hit || too_far )
      {
        hit = has_hit;
        <b><font color="0000BB">break</font></b>;
      }
      t += dd.x; <i><font color="#FFFF00">// *TFRAC</font></i>
    }
    <b><font color="0000BB">if</font></b> ( t < ct.t && hit )
    {
      ct.p = p;
      ct.t = t;
      <b><font color="0000BB">if</font></b> ( !shadow_trace ) <i><font color="#FFFF00">// doubt it makes a difference, anyway shadow only need t</font></i>
      {
        pack_info( ct, <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>. ), <font color="#0077BB">0</font>., p.z < <font color="#0077BB">0</font>.<font color="#0077BB">004</font> * t ? /* TYPE_ROAD */<font color="#0077BB">9</font>. : /* TYPE_HIGHWAY */<font color="#0077BB">8</font>. );
        <b><font color="0000BB">vec3</font></b> h = <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">01</font>, <font color="#0077BB">0</font>., <font color="#0077BB">0</font>. );
        <i><font color="#FFFF00">//    h.x *= t; // grainy normals tweak => but that inflate pavement edges weirdly</font></i>
        ct.n = normalize( <b><font color="0000BB">vec3</font></b>( sd_RayMarchedCityBits( ct.p + h.xyz, <font color="#0077BB">0</font> ).x,
                                sd_RayMarchedCityBits( ct.p + h.zxy, <font color="#0077BB">0</font> ).x,
                                sd_RayMarchedCityBits( ct.p + h.yzx, <font color="#0077BB">0</font> ).x )
                          - dd.x );
        {
          Ray ao_ray = mkray( ct.p, ct.n );
        { /* ao algo from http:<i><font color="#FFFF00">//www.iquilezles.org/www/material/nvscene2008/rwwtt.pdf macrofified to avoid repetition */ float _delta = 0.1, _a = 0.0, _b = 1.0; for ( int _i = 0; _i < 5 /*FORCE_LOOP*/ + min(0, iFrame); _i++ ) {</font></i>
              <b><font color="0000BB">float</font></b> _fi = <b><font color="0000BB">float</font></b>( _i ); <b><font color="0000BB">float</font></b> _ao_t = _delta * _fi;
              <b><font color="0000BB">float</font></b> d = sd_RayMarchedCityBits( ao_ray.o + _ao_t * ao_ray.d, <font color="#0077BB">0</font> ).x;
              _a += ( _ao_t - d ) * _b; _b *= <font color="#0077BB">0</font>.<font color="#0077BB">5</font>;
            } ct.ao = max( <font color="#0077BB">1</font>.<font color="#0077BB">0</font> - <font color="#0077BB">1</font>.<font color="#0077BB">2</font> * _a, <font color="#0077BB">0</font>.<font color="#0077BB">0</font> );
          }
        }
        ct.type = <font color="#0077BB">0</font>;
        <b><font color="0000BB">if</font></b> ( abs( dd.y - dd.x ) < <font color="#0077BB">0</font>.<font color="#0077BB">0000007</font> ) ct.type = <font color="#0077BB">1</font>;
        <b><font color="0000BB">if</font></b> ( abs( dd.z - dd.x ) < <font color="#0077BB">0</font>.<font color="#0077BB">0000007</font> ) ct.type = <font color="#0077BB">2</font>;
      }
    }
  }
  ct.ao = min( ct.ao, <font color="#0077BB">1</font>. ); <i><font color="#FFFF00">// apparently this goes above 1 and whitens far away pixel... so clamp</font></i>
  <b><font color="0000BB">return</font></b> ct;
}
<b><font color="0000BB">struct</font></b> CameraPosAndTangent {
  <b><font color="0000BB">vec3</font></b> eye;
  <b><font color="0000BB">vec2</font></b> tangent;
};
<b><font color="0000BB">struct</font></b> CameraRet {
  <b><font color="0000BB">vec3</font></b> eye;
  <b><font color="0000BB">vec3</font></b> target;
  <b><font color="0000BB">float</font></b> roll;
  <b><font color="0000BB">float</font></b> pitch;
};
CameraRet init_cam() {
  CameraRet cam;
  cam.roll = <font color="#0077BB">0</font>.;
  cam.pitch = <font color="#0077BB">0</font>.;
  <b><font color="0000BB">return</font></b> cam;
}
<b><font color="0000BB">mat4</font></b> look_around_mouse_control( <b><font color="0000BB">mat4</font></b> camera, <b><font color="0000BB">float</font></b> pitch, <b><font color="0000BB">float</font></b> tan_half_fovy, <b><font color="0000BB">float</font></b> look_at_the_abyss )
{
  <b><font color="0000BB">float</font></b> mouse_ctrl = <font color="#0077BB">1</font>.<font color="#0077BB">0</font>;
  <b><font color="0000BB">vec2</font></b> mm_offset = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">0</font>, pitch );
  <b><font color="0000BB">vec2</font></b> mm = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">0</font>, <font color="#0077BB">0</font>.<font color="#0077BB">0</font> );
  <b><font color="0000BB">if</font></b> ( iMouse.z > <font color="#0077BB">0</font>.<font color="#0077BB">0</font> || <b><font color="0000BB">false</font></b> ) mm = ( iMouse.xy - iResolution.xy * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> ) / ( min( iResolution.x, iResolution.y ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> );
  <b><font color="0000BB">float</font></b> mm_y = mm.y;
  mm.x = -mm.x;
  mm = sign( mm ) * pow( abs( mm ), <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">9</font> ) );
  mm *= <font color="#0077BB">3</font>.<font color="#0077BB">141592654</font> * tan_half_fovy * mouse_ctrl;
  mm += mm_offset;
  <b><font color="0000BB">if</font></b> ( mm_y < <font color="#0077BB">0</font>. )
  {
    <i><font color="#FFFF00">// very special case camera control for getRoofTopCoffeeBreakCamera</font></i>
    <b><font color="0000BB">vec3</font></b> v = camera[<font color="#0077BB">2</font>].xyz;
    v.xy = rotate_with_angle( v.xy, mm.x );
    camera[<font color="#0077BB">3</font>].xyz += v * mm.y * look_at_the_abyss;
  }
  <b><font color="0000BB">return</font></b> camera * yup_spherical_offset( mm.y, mm.x );
}
CameraPosAndTangent getDriveCameraPosAndTangent( <b><font color="0000BB">float</font></b> t, <b><font color="0000BB">float</font></b> lateral_move_amplitude )
{
  <i><font color="#FFFF00">//  t -= 200. * iSlider0;</font></i>
  <b><font color="0000BB">float</font></b> x = t * <font color="#0077BB">4</font>.;
  <b><font color="0000BB">float</font></b> e = <font color="#0077BB">1</font>e-<font color="#0077BB">2</font>;
  <b><font color="0000BB">vec3</font></b> p1 = sd_CameraCurveXY( x );
  <b><font color="0000BB">vec3</font></b> p2 = sd_CameraCurveXY( x + e );
  <b><font color="0000BB">vec2</font></b> tangent = ( p2.xy - p1.xy ) / e;
  CameraPosAndTangent ret;
  ret.eye = p1;
  ret.tangent = tangent;
  ret.eye.xy += lateral_move_amplitude * perp( tangent ) * sin( <font color="#0077BB">2</font>. * <font color="#0077BB">3</font>.<font color="#0077BB">141592654</font> * t / <font color="#0077BB">5</font>. ) * (<font color="#0077BB">1</font>.) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> * abs( tangent.y );
  <b><font color="0000BB">return</font></b> ret;
}
<i><font color="#FFFF00">// we use those for drive camera vibrations</font></i>
<b><font color="0000BB">float</font></b> noise( <b><font color="0000BB">float</font></b> x ) {
  <b><font color="0000BB">float</font></b> xi = floor( x );
  <b><font color="0000BB">return</font></b> mix( hash11( xi ), hash11( xi + <font color="#0077BB">1</font>. ), smoothstep_unchecked( x - xi ) );
}
<b><font color="0000BB">float</font></b> noisem11( <b><font color="0000BB">float</font></b> x ) {
  <b><font color="0000BB">return</font></b> <font color="#0077BB">2</font>. * ( noise( x ) - <font color="#0077BB">0</font>.<font color="#0077BB">5</font> );
}
<b><font color="0000BB">float</font></b> fbm( <b><font color="0000BB">float</font></b> x ) {
  <b><font color="0000BB">return</font></b> noisem11( x ) + noisem11( x * <font color="#0077BB">2</font>. ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> + noisem11( x * <font color="#0077BB">4</font>. ) * <font color="#0077BB">0</font>.<font color="#0077BB">25</font> + noisem11( x * <font color="#0077BB">8</font>. ) * <font color="#0077BB">0</font>.<font color="#0077BB">125</font>;
}
CameraRet getDriveCamera( <b><font color="0000BB">float</font></b> t )
{
  <b><font color="0000BB">float</font></b> lateral_move_amplitude = <font color="#0077BB">1</font>.;
  CameraPosAndTangent cam0 = getDriveCameraPosAndTangent( t, lateral_move_amplitude );
  CameraRet cam = init_cam();
  cam.eye = cam0.eye;
  <i><font color="#FFFF00">// those 2 evals are for camera acceleration effects and target eval</font></i>
  CameraPosAndTangent camnext1 = getDriveCameraPosAndTangent( t - <font color="#0077BB">1</font>.<font color="#0077BB">0</font>, lateral_move_amplitude );
  CameraPosAndTangent camnext2 = getDriveCameraPosAndTangent( t + <font color="#0077BB">0</font>.<font color="#0077BB">5</font>, lateral_move_amplitude );
  {
    <i><font color="#FFFF00">// for road vibrations we must be close enough to road surface</font></i>
    <b><font color="0000BB">float</font></b> driving_vibrations = max( smoothbump( <font color="#0077BB">2</font>., <font color="#0077BB">4</font>., cam.eye.z ), smoothbump( <font color="#0077BB">0</font>., <font color="#0077BB">4</font>., cam.eye.z ) );
    cam.eye.xy += driving_vibrations * perp( cam0.tangent ) * fbm( <font color="#0077BB">100</font>. + t * <font color="#0077BB">0</font>.<font color="#0077BB">1</font> ) * <font color="#0077BB">0</font>.<font color="#0077BB">3</font>;
    cam.eye.z += driving_vibrations * fbm( t ) * <font color="#0077BB">0</font>.<font color="#0077BB">015</font>; <i><font color="#FFFF00">// road roughness</font></i>
  }
  cam.roll = ( camnext2.tangent.y - camnext1.tangent.y ) * <font color="#0077BB">0</font>.<font color="#0077BB">3</font>; <i><font color="#FFFF00">// roll</font></i>
  cam.target = camnext2.eye;
  <i><font color="#FFFF00">// drift logic</font></i>
  <b><font color="0000BB">float</font></b> tr = repeat_e( t, <font color="#0077BB">0</font>., <font color="#0077BB">30</font>. );
  cam.target.xy = cam.eye.xy + rotate_with_unit_vector( cam.target.xy - cam.eye.xy, unit_vector2( <font color="#0077BB">3</font>.<font color="#0077BB">141592654</font> * smoothstep( <font color="#0077BB">5</font>., <font color="#0077BB">10</font>., tr ) + <i><font color="#FFFF00">// 180 = flying looking backward for a while</font></i>
                  <font color="#0077BB">3</font>.<font color="#0077BB">141592654</font> * smoothstep( <font color="#0077BB">15</font>., <font color="#0077BB">20</font>., tr ) ) ); <i><font color="#FFFF00">// 360 = back to travel direction</font></i>
  <b><font color="0000BB">return</font></b> cam;
}
<b><font color="0000BB">vec3</font></b> getStraightFlightCameraPos( <b><font color="0000BB">float</font></b> time )
{
  time += <font color="#0077BB">200</font>.;
  <b><font color="0000BB">vec2</font></b> v = unit_vector2( -time * <font color="#0077BB">0</font>.<font color="#0077BB">05</font> );
  <b><font color="0000BB">return</font></b> <b><font color="0000BB">vec3</font></b>( v * <font color="#0077BB">100</font>. + <font color="#0077BB">50</font>. * log( <font color="#0077BB">1</font>. + time ), <font color="#0077BB">15</font>. );
}
CameraRet getStraightFlightCamera( <b><font color="0000BB">float</font></b> t, <b><font color="0000BB">inout</font></b> <b><font color="0000BB">float</font></b> tan_half_fovy, <b><font color="0000BB">float</font></b> duration )
{
  <b><font color="0000BB">float</font></b> u = t / duration;
  t += <font color="#0077BB">8</font>.;
  CameraRet cam = init_cam();
  cam.eye = getStraightFlightCameraPos( t );
  cam.target = getStraightFlightCameraPos( t + <font color="#0077BB">1</font>. );
  cam.target.xy = cam.eye.xy + rotate_with_unit_vector( cam.target.xy - cam.eye.xy, unit_vector2( -<font color="#0077BB">3</font>.<font color="#0077BB">141592654</font> * smoothstep( <font color="#0077BB">1</font>., <font color="#0077BB">0</font>., u ) ) );
  tan_half_fovy = <font color="#0077BB">0</font>.<font color="#0077BB">5</font>;
  cam.pitch = radians( -<font color="#0077BB">20</font>. );
  <b><font color="0000BB">return</font></b> cam;
}
<i><font color="#FFFF00">// get position of a point that travelled at constant speed a long a log spiral, starting from theta0</font></i>
<b><font color="0000BB">vec2</font></b> log_spiral( <b><font color="0000BB">float</font></b> d, <b><font color="0000BB">float</font></b> theta0, <b><font color="0000BB">float</font></b> a, <b><font color="0000BB">float</font></b> b )
{
  <i><font color="#FFFF00">//  d( theta ) = integral of a * exp( b * theta ) dtheta = ( exp( b * theta ) - exp( b * theta0 ) ) * a / b;</font></i>
  <b><font color="0000BB">float</font></b> theta = log( d * ( b / a ) + exp( b * theta0 ) ) / b;
  <b><font color="0000BB">return</font></b> a * exp( b * theta ) * unit_vector2( theta );
}
<b><font color="0000BB">vec3</font></b> getRoofTopCoffeeBreakCameraPos( <b><font color="0000BB">float</font></b> u )
{
  <b><font color="0000BB">vec2</font></b> v = log_spiral( (u) * <font color="#0077BB">4</font>.<font color="#0077BB">3</font>, <font color="#0077BB">0</font>., <font color="#0077BB">1</font>., <font color="#0077BB">1</font>. );
  v -= normalize( v ) * <font color="#0077BB">1</font>.;
  v.xy *= <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">51</font>, <font color="#0077BB">0</font>.<font color="#0077BB">95</font> );
  <b><font color="0000BB">return</font></b> <b><font color="0000BB">vec3</font></b>(v.xy, <font color="#0077BB">0</font>.) + <b><font color="0000BB">vec3</font></b>(<font color="#0077BB">593</font>.<font color="#0077BB">983276</font>, -<font color="#0077BB">76</font>.<font color="#0077BB">936417</font>, <font color="#0077BB">8</font>.<font color="#0077BB">693137</font>); <i><font color="#FFFF00">// add start position</font></i>
}
<i><font color="#FFFF00">// walk on a roof top and lookup at airliner</font></i>
CameraRet getRoofTopCoffeeBreakCamera( <b><font color="0000BB">float</font></b> t, <b><font color="0000BB">inout</font></b> <b><font color="0000BB">float</font></b> tan_half_fovy, <b><font color="0000BB">float</font></b> duration, <b><font color="0000BB">inout</font></b> <b><font color="0000BB">float</font></b> look_at_the_abyss )
{
  CameraRet cam = init_cam();
  <b><font color="0000BB">vec3</font></b> start_pos = <b><font color="0000BB">vec3</font></b>(<font color="#0077BB">593</font>.<font color="#0077BB">983276</font>, -<font color="#0077BB">76</font>.<font color="#0077BB">936417</font>, <font color="#0077BB">8</font>.<font color="#0077BB">693137</font>);
  <b><font color="0000BB">float</font></b> u = saturate( t / duration );
  cam.eye = getRoofTopCoffeeBreakCameraPos( u );
  cam.eye.z += ( ( <font color="#0077BB">1</font>. + sin( u * <font color="#0077BB">95</font>. ) ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> ) * <font color="#0077BB">0</font>.<font color="#0077BB">001</font>; <i><font color="#FFFF00">// walk</font></i>
  <b><font color="0000BB">float</font></b> ra = mix( -radians( <font color="#0077BB">1</font>.<font color="#0077BB">5</font> ), <font color="#0077BB">3</font>.<font color="#0077BB">141592654</font> * <font color="#0077BB">1</font>.<font color="#0077BB">17</font>, smoothstep( <font color="#0077BB">0</font>.<font color="#0077BB">2</font>, <font color="#0077BB">1</font>., u ) );
  cam.target = cam.eye + <b><font color="0000BB">vec3</font></b>( unit_vector2( ra ), <font color="#0077BB">0</font>. );
  cam.pitch = smoothbump( u, <font color="#0077BB">0</font>.<font color="#0077BB">6</font>, <font color="#0077BB">0</font>.<font color="#0077BB">75</font>, <font color="#0077BB">0</font>.<font color="#0077BB">82</font>, <font color="#0077BB">1</font>.<font color="#0077BB">01</font> ) * <font color="#0077BB">3</font>.<font color="#0077BB">141592654</font> * <font color="#0077BB">0</font>.<font color="#0077BB">5</font> * <font color="#0077BB">0</font>.<font color="#0077BB">75</font>;
  look_at_the_abyss = <font color="#0077BB">0</font>.<font color="#0077BB">2</font> * smoothstep( <font color="#0077BB">0</font>.<font color="#0077BB">8</font>, <font color="#0077BB">0</font>.<font color="#0077BB">6</font>, u );
  <b><font color="0000BB">return</font></b> cam;
}
<i><font color="#FFFF00">// ( offset x, offset y, angle, time offset )</font></i>
<i><font color="#FFFF00">//#define LSFC vec4(iSlider2,iSlider3,iSlider4,iSlider5)</font></i>
<b><font color="0000BB">vec3</font></b> getLogSpiralCameraFlyPos( <b><font color="0000BB">float</font></b> t, <b><font color="0000BB">inout</font></b> <b><font color="0000BB">float</font></b> pitch )
{
  <b><font color="0000BB">float</font></b> dz = exp_bell( t - <font color="#0077BB">15</font>.<font color="#0077BB">5</font>, <font color="#0077BB">5</font>. ) * <font color="#0077BB">0</font>.<font color="#0077BB">5</font>;
  pitch = radians( -<font color="#0077BB">18</font>. );
  pitch -= dz * radians( <font color="#0077BB">3</font>.<font color="#0077BB">5</font> );
  <b><font color="0000BB">return</font></b> <b><font color="0000BB">vec3</font></b>( <b><font color="0000BB">vec2</font></b>( -<font color="#0077BB">100</font>. ) + <font color="#0077BB">200</font>. * <b><font color="0000BB">vec4</font></b>(<font color="#0077BB">0</font>., <font color="#0077BB">0</font>.<font color="#0077BB">35</font>, <font color="#0077BB">0</font>.<font color="#0077BB">2214</font>, <font color="#0077BB">0</font>.<font color="#0077BB">0928</font>).xy, <font color="#0077BB">8</font>.<font color="#0077BB">3</font> )
         + <b><font color="0000BB">vec3</font></b>( rotate_with_angle( log_spiral( <b><font color="0000BB">vec4</font></b>(<font color="#0077BB">0</font>., <font color="#0077BB">0</font>.<font color="#0077BB">35</font>, <font color="#0077BB">0</font>.<font color="#0077BB">2214</font>, <font color="#0077BB">0</font>.<font color="#0077BB">0928</font>).w * <font color="#0077BB">200</font>. + t * <font color="#0077BB">1</font>.<font color="#0077BB">2</font>, <font color="#0077BB">0</font>.<font color="#0077BB">1</font>, <font color="#0077BB">1</font>., <font color="#0077BB">1</font>. )
                                    , -<b><font color="0000BB">vec4</font></b>(<font color="#0077BB">0</font>., <font color="#0077BB">0</font>.<font color="#0077BB">35</font>, <font color="#0077BB">0</font>.<font color="#0077BB">2214</font>, <font color="#0077BB">0</font>.<font color="#0077BB">0928</font>).z * <font color="#0077BB">3</font>.<font color="#0077BB">141592654</font> * <font color="#0077BB">2</font>. ), dz * <font color="#0077BB">3</font>. );
}
<i><font color="#FFFF00">// fly along a log spiral with constant roll</font></i>
CameraRet getLogSpiralCameraFly( <b><font color="0000BB">float</font></b> t, <b><font color="0000BB">inout</font></b> <b><font color="0000BB">float</font></b> tan_half_fovy )
{
  CameraRet cam = init_cam();
  cam.eye = getLogSpiralCameraFlyPos( t, cam.pitch );
  cam.target = getLogSpiralCameraFlyPos( t + <font color="#0077BB">1</font>., cam.pitch );
  cam.roll = radians( <font color="#0077BB">10</font>. );
  tan_half_fovy = <font color="#0077BB">0</font>.<font color="#0077BB">53</font>;
  <b><font color="0000BB">return</font></b> cam;
}
<i><font color="#FFFF00">// goes through p1,p2</font></i>
<b><font color="0000BB">void</font></b> catmullrom( <b><font color="0000BB">out</font></b> <b><font color="0000BB">vec3</font></b> point, <b><font color="0000BB">out</font></b> <b><font color="0000BB">vec3</font></b> derivative, <b><font color="0000BB">float</font></b> t, <b><font color="0000BB">vec3</font></b> p0, <b><font color="0000BB">vec3</font></b> p1, <b><font color="0000BB">vec3</font></b> p2, <b><font color="0000BB">vec3</font></b> p3 )
{
  <b><font color="0000BB">float</font></b> t2 = t * t;
  <b><font color="0000BB">float</font></b> t3 = t2 * t;
  <b><font color="0000BB">vec3</font></b> a1 = -p0 + p2;
  <b><font color="0000BB">vec3</font></b> a2 = <font color="#0077BB">2</font>. * p0 - <font color="#0077BB">5</font>. * p1 + <font color="#0077BB">4</font>. * p2 - p3;
  <b><font color="0000BB">vec3</font></b> a3 = -p0 + <font color="#0077BB">3</font>. * p1 - <font color="#0077BB">3</font>. * p2 + p3;
  point = <font color="#0077BB">0</font>.<font color="#0077BB">5</font> * ( ( <font color="#0077BB">2</font>. * p1 ) + a1 * t + a2 * t2 + a3 * t3 );
  derivative = <font color="#0077BB">0</font>.<font color="#0077BB">5</font> * ( a1 + a2 * <font color="#0077BB">2</font>. * t + a3 * <font color="#0077BB">3</font>. * t2 ); <i><font color="#FFFF00">// whilst we are at it</font></i>
}
<i><font color="#FFFF00">// goes through p1,p2,p3</font></i>
<b><font color="0000BB">void</font></b> catmullrom( <b><font color="0000BB">out</font></b> <b><font color="0000BB">vec3</font></b> point, <b><font color="0000BB">out</font></b> <b><font color="0000BB">vec3</font></b> derivative, <b><font color="0000BB">float</font></b> t, <b><font color="0000BB">vec3</font></b> p0, <b><font color="0000BB">vec3</font></b> p1, <b><font color="0000BB">vec3</font></b> p2, <b><font color="0000BB">vec3</font></b> p3, <b><font color="0000BB">vec3</font></b> p4 )
{
  <b><font color="0000BB">if</font></b> ( t < <font color="#0077BB">0</font>.<font color="#0077BB">5</font> ) catmullrom( point, derivative, t * <font color="#0077BB">2</font>., p0, p1, p2, p3 );
  <b><font color="0000BB">else</font></b> catmullrom( point, derivative, <font color="#0077BB">2</font>. * ( t - <font color="#0077BB">0</font>.<font color="#0077BB">5</font> ), p1, p2, p3, p4 );
}
<i><font color="#FFFF00">//#define UTBSC vec2(iSlider0,iSlider1)</font></i>
<i><font color="#FFFF00">//#define UTBSC vec2(0.585714,0.35)</font></i>
CameraRet getUnderTheBridgeStreetCamera( <b><font color="0000BB">float</font></b> t, <b><font color="0000BB">inout</font></b> <b><font color="0000BB">float</font></b> tan_half_fovy, <b><font color="0000BB">float</font></b> duration )
{
  CameraRet cam = init_cam();
  <b><font color="0000BB">float</font></b> u = saturate( t / duration );
  <b><font color="0000BB">vec3</font></b> o = <b><font color="0000BB">vec3</font></b>( floor( <b><font color="0000BB">vec2</font></b>(<font color="#0077BB">0</font>.<font color="#0077BB">585714</font>, <font color="#0077BB">0</font>.<font color="#0077BB">707143</font>) /* best*/.x * <font color="#0077BB">100</font>. ) * <font color="#0077BB">80</font>. * <font color="#0077BB">2</font>.,
                 floor( <b><font color="0000BB">vec2</font></b>(<font color="#0077BB">0</font>.<font color="#0077BB">585714</font>, <font color="#0077BB">0</font>.<font color="#0077BB">707143</font>) /* best*/.y * <font color="#0077BB">100</font>. ) * /* CELL_SIZE */<b><font color="0000BB">vec3</font></b>( <font color="#0077BB">8</font>., <font color="#0077BB">8</font>., <font color="#0077BB">100</font>. ).y, <font color="#0077BB">0</font>. );
  <b><font color="0000BB">vec3</font></b> p0 = o + <b><font color="0000BB">vec3</font></b>( -<font color="#0077BB">80</font>.<font color="#0077BB">457870</font>, -<font color="#0077BB">10</font>.<font color="#0077BB">903438</font>, <font color="#0077BB">0</font>.<font color="#0077BB">591591</font> );
  <b><font color="0000BB">vec3</font></b> p1 = o + <b><font color="0000BB">vec3</font></b>( -<font color="#0077BB">80</font>.<font color="#0077BB">274940</font>, -<font color="#0077BB">3</font>.<font color="#0077BB">2</font>, <font color="#0077BB">0</font>.<font color="#0077BB">517319</font> );
  <b><font color="0000BB">vec3</font></b> p2 = o + <b><font color="0000BB">vec3</font></b>( -<font color="#0077BB">79</font>.<font color="#0077BB">289925</font>, <font color="#0077BB">2</font>.<font color="#0077BB">674706</font>, <font color="#0077BB">1</font>.<font color="#0077BB">934119</font> );
  <b><font color="0000BB">vec3</font></b> p3 = o + <b><font color="0000BB">vec3</font></b>( -<font color="#0077BB">74</font>.<font color="#0077BB">650077819</font>, <font color="#0077BB">3</font>.<font color="#0077BB">327467679</font>, <font color="#0077BB">3</font>.<font color="#0077BB">193379163</font> );
  <b><font color="0000BB">vec3</font></b> p4 = o + <b><font color="0000BB">vec3</font></b>( -<font color="#0077BB">71</font>.<font color="#0077BB">289779663</font>, <font color="#0077BB">4</font>.<font color="#0077BB">606474399</font>, <font color="#0077BB">3</font>.<font color="#0077BB">521366834</font> );
  <b><font color="0000BB">vec3</font></b> derivative;
  catmullrom( cam.eye, derivative, u, p0, p1, p2, p3, p4 );
  cam.target = cam.eye + derivative;
  cam.pitch = mix( radians( -<font color="#0077BB">22</font>. ), <font color="#0077BB">0</font>., u );
  cam.roll = mix( radians( <font color="#0077BB">0</font>. ), radians( -<font color="#0077BB">8</font>. ), smoothstep( <font color="#0077BB">0</font>.<font color="#0077BB">2</font>, <font color="#0077BB">0</font>.<font color="#0077BB">8</font>, u ) );
  <b><font color="0000BB">return</font></b> cam;
}
<i><font color="#FFFF00">//#define IFC vec3(iSlider0,iSlider1,iSlider2)</font></i>
CameraRet getIsoFlyCamera( <b><font color="0000BB">float</font></b> t, <b><font color="0000BB">inout</font></b> <b><font color="0000BB">float</font></b> tan_half_fovy, <b><font color="0000BB">float</font></b> duration )
{
  CameraRet cam = init_cam();
  <b><font color="0000BB">vec2</font></b> travel_dir = normalize( <b><font color="0000BB">vec2</font></b>( -<font color="#0077BB">1</font>.<font color="#0077BB">8</font>, <font color="#0077BB">1</font>.<font color="#0077BB">4</font> ) );
  cam.eye = <b><font color="0000BB">vec3</font></b>( travel_dir * t * <font color="#0077BB">4</font>., <font color="#0077BB">65</font>. );
  cam.eye += <b><font color="0000BB">vec3</font></b>( <b><font color="0000BB">vec3</font></b>(<font color="#0077BB">0</font>.<font color="#0077BB">6</font>, <font color="#0077BB">0</font>.<font color="#0077BB">62</font>, <font color="#0077BB">0</font>.<font color="#0077BB">328</font>).x * <font color="#0077BB">200</font>., <b><font color="0000BB">vec3</font></b>(<font color="#0077BB">0</font>.<font color="#0077BB">6</font>, <font color="#0077BB">0</font>.<font color="#0077BB">62</font>, <font color="#0077BB">0</font>.<font color="#0077BB">328</font>).y * <font color="#0077BB">200</font>., <font color="#0077BB">0</font>. );
  cam.target = cam.eye + <b><font color="0000BB">vec3</font></b>( perp( travel_dir ), <font color="#0077BB">0</font>. );
  cam.pitch = radians( -<font color="#0077BB">60</font>. * <b><font color="0000BB">vec3</font></b>(<font color="#0077BB">0</font>.<font color="#0077BB">6</font>, <font color="#0077BB">0</font>.<font color="#0077BB">62</font>, <font color="#0077BB">0</font>.<font color="#0077BB">328</font>).z );
  tan_half_fovy = <font color="#0077BB">0</font>.<font color="#0077BB">1</font>;
  <b><font color="0000BB">return</font></b> cam;
}
<i><font color="#FFFF00">// get close to a LCD panel that shows the squid invaders things</font></i>
CameraRet getLCDScreenCloseUpCamera( <b><font color="0000BB">float</font></b> t, <b><font color="0000BB">inout</font></b> <b><font color="0000BB">float</font></b> tan_half_fovy, <b><font color="0000BB">float</font></b> duration )
{
  CameraRet cam = init_cam();
  cam.eye = <b><font color="0000BB">vec3</font></b>( -<font color="#0077BB">5</font>.<font color="#0077BB">514656066</font>, -<font color="#0077BB">0</font>.<font color="#0077BB">541317582</font>, <font color="#0077BB">2</font>.<font color="#0077BB">770161151</font> );
  cam.target = cam.eye + <b><font color="0000BB">vec3</font></b>( -<font color="#0077BB">1</font>., <font color="#0077BB">0</font>., <font color="#0077BB">0</font>. );
  <b><font color="0000BB">vec3</font></b> a = <b><font color="0000BB">vec3</font></b>( -<font color="#0077BB">6</font>.<font color="#0077BB">56</font>, -<font color="#0077BB">0</font>.<font color="#0077BB">8</font>, <font color="#0077BB">3</font>.<font color="#0077BB">3</font> );
  <b><font color="0000BB">vec3</font></b> b = <b><font color="0000BB">vec3</font></b>( -<font color="#0077BB">6</font>.<font color="#0077BB">56</font>, <font color="#0077BB">0</font>.<font color="#0077BB">8</font>, <font color="#0077BB">3</font>.<font color="#0077BB">3</font> );
  cam.eye.x += <font color="#0077BB">1</font>.<font color="#0077BB">5</font>;
  cam.eye.z -= <font color="#0077BB">0</font>.<font color="#0077BB">5</font>;
  <b><font color="0000BB">float</font></b> u = saturate( t / duration );
  <b><font color="0000BB">vec3</font></b> c = mix( a, b, u );
  c.x += <font color="#0077BB">0</font>.<font color="#0077BB">8</font>;
  cam.eye = mix( cam.eye, c - <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">0</font>., <font color="#0077BB">0</font>., <font color="#0077BB">0</font>.<font color="#0077BB">5</font> ), u );
  cam.target = mix( cam.target, mix( a, b, <font color="#0077BB">0</font>.<font color="#0077BB">8</font> ), pow( u, <font color="#0077BB">2</font>. ) );
  tan_half_fovy = mix( <font color="#0077BB">0</font>.<font color="#0077BB">47</font>, <font color="#0077BB">0</font>.<font color="#0077BB">4</font>, u );
  <b><font color="0000BB">return</font></b> cam;
}
<b><font color="0000BB">mat4</font></b> getCamera( <b><font color="0000BB">inout</font></b> <b><font color="0000BB">float</font></b> tan_half_fovy, <b><font color="0000BB">inout</font></b> <b><font color="0000BB">float</font></b> fade, <b><font color="0000BB">inout</font></b> <b><font color="0000BB">float</font></b> a_contrast, <b><font color="0000BB">vec3</font></b> l, <b><font color="0000BB">inout</font></b> <b><font color="0000BB">float</font></b> time, <b><font color="0000BB">inout</font></b> <b><font color="0000BB">float</font></b> ground_ao )
{
  <b><font color="0000BB">float</font></b> total = <font color="#0077BB">0</font>.;
  <i><font color="#FFFF00">// per camera time range: array of start, duration (yes I am aware of the syntax that pretends we can have arrays)</font></i>
  <b><font color="0000BB">vec2</font></b> r1 = <b><font color="0000BB">vec2</font></b>( total, <font color="#0077BB">41</font>. ); total += r1.y;
  <b><font color="0000BB">vec2</font></b> r2 = <b><font color="0000BB">vec2</font></b>( total, <font color="#0077BB">20</font>. ); total += r2.y;
  <b><font color="0000BB">vec2</font></b> r3 = <b><font color="0000BB">vec2</font></b>( total, <font color="#0077BB">20</font>. ); total += r3.y;
  <b><font color="0000BB">vec2</font></b> r4 = <b><font color="0000BB">vec2</font></b>( total, <font color="#0077BB">8</font>.<font color="#0077BB">5</font> ); total += r4.y;
  <b><font color="0000BB">vec2</font></b> r5 = <b><font color="0000BB">vec2</font></b>( total, <font color="#0077BB">12</font>. ); total += r5.y;
  <b><font color="0000BB">vec2</font></b> r6 = <b><font color="0000BB">vec2</font></b>( total, <font color="#0077BB">8</font>. ); total += r6.y;
  <b><font color="0000BB">vec2</font></b> r7 = <b><font color="0000BB">vec2</font></b>( total, <font color="#0077BB">22</font>. ); total += r7.y;
  time = mod( time, total ); <i><font color="#FFFF00">// cycle through all cameras</font></i>
  <i><font color="#FFFF00">//  vec2 r = r2; // <= select a specific camera to test here</font></i>
  <i><font color="#FFFF00">//  time = r.x + mod( time, r.y );</font></i>
  <i><font color="#FFFF00">//  time = r.x + 1.;</font></i>
  <b><font color="0000BB">float</font></b> tr = <font color="#0077BB">0</font>.<font color="#0077BB">7</font>; <i><font color="#FFFF00">// fade half durations</font></i>
  fade *= <font color="#0077BB">1</font>. - ( max( cosbump( time, <font color="#0077BB">0</font>., tr ), cosbump( time, total, tr )) <i><font color="#FFFF00">// those 2 overlap</font></i>
                 + cosbump( time, r2.x, tr ) + cosbump( time, r3.x, tr )
                 + cosbump( time, r4.x, tr ) + cosbump( time, r5.x, tr )
                 + cosbump( time, r6.x, tr ) + cosbump( time, r7.x, tr ));
  <b><font color="0000BB">float</font></b> look_at_the_abyss = <font color="#0077BB">0</font>.;
  CameraRet cam;
  <b><font color="0000BB">if</font></b> ( time < r1.x + r1.y ) {
    time -= r1.x;
    cam = getDriveCamera( time );
  }
  <b><font color="0000BB">else</font></b> <b><font color="0000BB">if</font></b> ( time < r2.x + r2.y ) {
    time -= r2.x;
    cam = getLogSpiralCameraFly( time, tan_half_fovy );
    ground_ao = <font color="#0077BB">0</font>.<font color="#0077BB">7</font>;
  }
  <b><font color="0000BB">else</font></b> <b><font color="0000BB">if</font></b> ( time < r3.x + r3.y ) {
    time -= r3.x;
    cam = getRoofTopCoffeeBreakCamera( time, tan_half_fovy, r3.y, look_at_the_abyss );
    ground_ao = <font color="#0077BB">0</font>.<font color="#0077BB">375</font>;
  }
  <b><font color="0000BB">else</font></b> <b><font color="0000BB">if</font></b> ( time < r4.x + r4.y ) {
    time -= r4.x;
    cam = getUnderTheBridgeStreetCamera( time, tan_half_fovy, r4.y );
  }
  <b><font color="0000BB">else</font></b> <b><font color="0000BB">if</font></b> ( time < r5.x + r5.y ) {
    time -= r5.x;
    cam = getStraightFlightCamera( time, tan_half_fovy, r5.y );
    ground_ao = <font color="#0077BB">0</font>.<font color="#0077BB">7</font>;
  }
  <b><font color="0000BB">else</font></b> <b><font color="0000BB">if</font></b> ( time < r6.x + r6.y ) {
    time -= r6.x;
    cam = getLCDScreenCloseUpCamera( time, tan_half_fovy, r6.y );
  }
  <b><font color="0000BB">else</font></b> {
    time -= r7.x;
    cam = getIsoFlyCamera( time, tan_half_fovy, r7.y );
    ground_ao = <font color="#0077BB">0</font>.<font color="#0077BB">375</font>;
  }
  <b><font color="0000BB">mat4</font></b> camera = lookat( cam.eye, cam.target, <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">0</font>., <font color="#0077BB">0</font>., <font color="#0077BB">1</font>. ) ) * z_rotation( cam.roll );
  <b><font color="0000BB">return</font></b> look_around_mouse_control( camera, cam.pitch, tan_half_fovy, look_at_the_abyss );
}
<i><font color="#FFFF00">// trace the silhouette of an a350 airliner, alt = 10000 at cruising altitude</font></i>
<b><font color="0000BB">float</font></b> get_airliner( Ray view_ray, <b><font color="0000BB">float</font></b> alt, <b><font color="0000BB">float</font></b> cruising_speed_fraction, <b><font color="0000BB">float</font></b> d, <b><font color="0000BB">vec2</font></b> mv <i><font color="#FFFF00">// normalized please</font></i>
                    , <b><font color="0000BB">float</font></b> tan_half_fovy, <b><font color="0000BB">float</font></b> time_offset, <b><font color="0000BB">float</font></b> direction, <b><font color="0000BB">float</font></b> trail_fade, <b><font color="0000BB">float</font></b> time )
{
  <i><font color="#FFFF00">//  cruising_speed_fraction *= 5.; // DEBUG</font></i>
  <b><font color="0000BB">float</font></b> airliner_cruising_speed = cruising_speed_fraction * ( <font color="#0077BB">950000</font>. / ( <font color="#0077BB">60</font>. * <font color="#0077BB">60</font>. ) ); <i><font color="#FFFF00">// m/s</font></i>
  <b><font color="0000BB">float</font></b> R1 = <font color="#0077BB">5</font>. * alt * tan_half_fovy; <i><font color="#FFFF00">// make all trajectory disks roughly same radius from ground</font></i>
  <b><font color="0000BB">float</font></b> R2 = R1 * <font color="#0077BB">1</font>.<font color="#0077BB">4</font>;
  <b><font color="0000BB">float</font></b> fade_time = <font color="#0077BB">1</font>.;
  <b><font color="0000BB">float</font></b> h1 = sqrt( R1 * R1 - d * d );
  <b><font color="0000BB">float</font></b> h2 = sqrt( R2 * R2 - d * d );
  <b><font color="0000BB">vec2</font></b> O = <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>., <font color="#0077BB">0</font> );
  <b><font color="0000BB">vec2</font></b> c = O + mv * d;
  <b><font color="0000BB">vec2</font></b> travel_direction = perp( mv ) * direction;
  <b><font color="0000BB">float</font></b> looptime = <font color="#0077BB">2</font>. * h2 / airliner_cruising_speed;
  <b><font color="0000BB">float</font></b> rt = mod( time + time_offset, looptime );
  <b><font color="0000BB">float</font></b> u = rt * airliner_cruising_speed;
  <b><font color="0000BB">vec3</font></b> plane_pos = <b><font color="0000BB">vec3</font></b>( c + travel_direction * ( u - h2 ), alt );
  <b><font color="0000BB">float</font></b> t = plane_trace_z( view_ray, alt, <font color="#0077BB">0</font>. ); <i><font color="#FFFF00">// epsilon zero, we don't care it's in the sky</font></i>
  <b><font color="0000BB">vec3</font></b> it = view_ray.o + view_ray.d * t;
  <b><font color="0000BB">float</font></b> dd = length( it.xy );
  <b><font color="0000BB">float</font></b> x = dot( it.xy - plane_pos.xy, -travel_direction ) - <font color="#0077BB">47</font>.;
  <b><font color="0000BB">float</font></b> y = abs( dot( it.xy - plane_pos.xy, perp( travel_direction ) ) );
  <b><font color="0000BB">float</font></b> fade = smoothstep( h2, h1, abs( u - h2 ) );
  <b><font color="0000BB">float</font></b> trail_disk_fade = smoothstep( R2, R1, dd );
  <i><font color="#FFFF00">// note: y is already symmetrized</font></i>
  <b><font color="0000BB">float</font></b> trail_half_spacing = <font color="#0077BB">9</font>.;
  <b><font color="0000BB">float</font></b> dc = exp_decay( x * <font color="#0077BB">0</font>.<font color="#0077BB">02</font> );
  <b><font color="0000BB">float</font></b> engine_trail = ( x < <font color="#0077BB">0</font>. ? <font color="#0077BB">0</font>. : smoothstep( <font color="#0077BB">2</font>., -<font color="#0077BB">1</font>., abs( y - trail_half_spacing ) - dc * <font color="#0077BB">4</font>. ) )
                       <i><font color="#FFFF00">// trail distance decay</font></i>
                       * exp( -x * <font color="#0077BB">0</font>.<font color="#0077BB">00175</font> );
  <b><font color="0000BB">float</font></b> trail = engine_trail * fade * trail_disk_fade * trail_fade;
  <b><font color="0000BB">float</font></b> debug = <font color="#0077BB">0</font>.;
  <b><font color="0000BB">vec2</font></b> uv = ( it - plane_pos ).xy * ( <font color="#0077BB">20</font>. / <font color="#0077BB">64</font>. ); <i><font color="#FFFF00">// plane outline sdf to scale</font></i>
  <b><font color="0000BB">if</font></b> ( length( uv ) > <font color="#0077BB">12</font>. ) <b><font color="0000BB">return</font></b> debug + trail + <font color="#0077BB">0</font>.; <i><font color="#FFFF00">// outside plane sdf's disk</font></i>
  <b><font color="0000BB">return</font></b> debug + trail + fade * smoothstep( <font color="#0077BB">0</font>.<font color="#0077BB">1</font>, -<font color="#0077BB">0</font>.<font color="#0077BB">1</font>, sd_airliner_a350( rotate_with_unit_vector( uv, <b><font color="0000BB">vec2</font></b>( travel_direction.x, -travel_direction.y ) ) ) ); <i><font color="#FFFF00">// plane</font></i>
}


<i><font color="#FFFF00">//void mainImage( out vec4 fragColor, in vec2 fragCoord ) {</font></i>
<b><font color="0000BB">void</font></b> main(<b><font color="0000BB">void</font></b>) {
  <b><font color="0000BB">vec2</font></b> fragCoord = pos;

  <b><font color="0000BB">float</font></b> aspect = iResolution.x / iResolution.y;
  <b><font color="0000BB">vec2</font></b> u = fragCoord.xy / iResolution.xy;
  fragColor.a = <font color="#0077BB">1</font>.;
  <b><font color="0000BB">float</font></b> a_contrast = <font color="#0077BB">1</font>.;
  <b><font color="0000BB">float</font></b> fade = <font color="#0077BB">1</font>.;
  <b><font color="0000BB">float</font></b> ground_ao = <font color="#0077BB">1</font>.; <i><font color="#FFFF00">// 1. == no ground ao... a bit of ground ao helps in flight cameras</font></i>
  <b><font color="0000BB">vec3</font></b> l = normalize( <b><font color="0000BB">vec3</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">8</font>, <font color="#0077BB">0</font>.<font color="#0077BB">025</font>, <font color="#0077BB">0</font>.<font color="#0077BB">125</font> ) ); <i><font color="#FFFF00">// sun direction</font></i>
  <i><font color="#FFFF00">//  fragColor.rgb = test_sky( fragCoord, l ); return; // contemplate sky probe, for the interested reader</font></i>
  <i><font color="#FFFF00">//  fragColor.rgb = get_building_palette( fragCoord.xy / min( iResolution.x, iResolution.y ) ); return; // for the curious</font></i>
  <b><font color="0000BB">float</font></b> time = iTime + <font color="#0077BB">20</font>.;
  <b><font color="0000BB">float</font></b> tan_half_fovy = <font color="#0077BB">0</font>.<font color="#0077BB">6</font>; <i><font color="#FFFF00">// fovy 61 deg</font></i>
  <b><font color="0000BB">mat4</font></b> camera = getCamera( tan_half_fovy, fade, a_contrast, l, time, ground_ao );
  Ray view_ray = get_view_ray( ( u - <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">5</font> )) * <font color="#0077BB">2</font>.<font color="#0077BB">0</font>, <font color="#0077BB">0</font>.<font color="#0077BB">1</font>, aspect, tan_half_fovy );
  view_ray = mkray( camera[<font color="#0077BB">3</font>].xyz, ( camera * <b><font color="0000BB">vec4</font></b>( view_ray.d, <font color="#0077BB">0</font>.<font color="#0077BB">0</font> )).xyz );
  view_ray.d.z += <font color="#0077BB">1</font>e-<font color="#0077BB">5</font>; <i><font color="#FFFF00">// divide by zero quick workaround</font></i>
  <i><font color="#FFFF00">// do view ray and shadow ray in a loop in hope to reduce chance of hitting webgl crashes</font></i>
  Ray r = view_ray;
  TraceCityRetval ct;
  <b><font color="0000BB">float</font></b> shadow = <font color="#0077BB">1</font>.;
  <b><font color="0000BB">for</font></b> ( <b><font color="0000BB">int</font></b> i = <font color="#0077BB">0</font>; i < <font color="#0077BB">2</font> /*FORCE_LOOP*/ + min(<font color="#0077BB">0</font>, iFrame) ; ++i )
  {
    TraceCityRetval ctr = traceCity( r, i == <font color="#0077BB">1</font> );
    r = mkray( ctr.p + ctr.n * <font color="#0077BB">0</font>.<font color="#0077BB">0025</font> * ctr.t, l ); <i><font color="#FFFF00">// set shadow ray for second pass</font></i>
    <b><font color="0000BB">if</font></b> ( i == <font color="#0077BB">0</font> ) ct = ctr;
    shadow = step( /* FLT_MAX */<font color="#0077BB">1000000</font>., ctr.t ); <i><font color="#FFFF00">// only relevant at end of second pass</font></i>
  }
  <i><font color="#FFFF00">// unrolling is cleaner than this horrible mess but I wanted the option to try force a loop</font></i>
  <b><font color="0000BB">float</font></b> airliner = <font color="#0077BB">0</font>.;
  <b><font color="0000BB">for</font></b> ( <b><font color="0000BB">int</font></b> i = <font color="#0077BB">0</font>; i < <font color="#0077BB">3</font> /*FORCE_LOOP*/ + min(<font color="#0077BB">0</font>, iFrame); ++i )
  {
    <b><font color="0000BB">float</font></b> airliner_alt = <font color="#0077BB">1000</font>. + (i == <font color="#0077BB">1</font> ? <font color="#0077BB">4000</font>. : <font color="#0077BB">0</font>.) + (i == <font color="#0077BB">2</font> ? <font color="#0077BB">500</font>. : <font color="#0077BB">0</font>.);
    <b><font color="0000BB">float</font></b> airliner_cruising_speed_fraction = <font color="#0077BB">0</font>.<font color="#0077BB">3</font> + (i == <font color="#0077BB">1</font> ? <font color="#0077BB">0</font>.<font color="#0077BB">5</font> : <font color="#0077BB">0</font>.) + (i == <font color="#0077BB">2</font> ? <font color="#0077BB">0</font>.<font color="#0077BB">1</font> : <font color="#0077BB">0</font>.);
    <b><font color="0000BB">float</font></b> airliner_d = <b><font color="0000BB">float</font></b>(<font color="#0077BB">2</font> - i) * <font color="#0077BB">500</font>. + (i == <font color="#0077BB">0</font> ? <font color="#0077BB">1000</font>. : <font color="#0077BB">0</font>.);
    <b><font color="0000BB">vec2</font></b> mv = (i == <font color="#0077BB">0</font> ? <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>.<font color="#0077BB">707106781</font>, <font color="#0077BB">0</font>.<font color="#0077BB">707106781</font> ) : <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>. )) + (i == <font color="#0077BB">1</font> ? <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">1</font>., <font color="#0077BB">0</font>. ) : <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>. )) + (i == <font color="#0077BB">2</font> ? <b><font color="0000BB">vec2</font></b>( -<font color="#0077BB">1</font>., <font color="#0077BB">0</font>. ) : <b><font color="0000BB">vec2</font></b>( <font color="#0077BB">0</font>. ));
    <b><font color="0000BB">float</font></b> time_offset = <font color="#0077BB">15</font>. + (i == <font color="#0077BB">1</font> ? <font color="#0077BB">30</font>. : <font color="#0077BB">0</font>.) + (i == <font color="#0077BB">2</font> ? <font color="#0077BB">25</font>. : <font color="#0077BB">0</font>.);
    <b><font color="0000BB">float</font></b> direction = (i == <font color="#0077BB">0</font> ? <font color="#0077BB">1</font>. : -<font color="#0077BB">1</font>.);
    <b><font color="0000BB">float</font></b> trail_fade = (i == <font color="#0077BB">2</font> ? <font color="#0077BB">0</font>.<font color="#0077BB">7</font> : <font color="#0077BB">1</font>.);
    airliner = max( airliner, get_airliner( view_ray, airliner_alt, airliner_cruising_speed_fraction, airliner_d, mv, tan_half_fovy, time_offset, direction, trail_fade, time ) );
  }
  fragColor.rgb = fade * shadeCity( ct, view_ray.o, view_ray.d, l, shadow, airliner, a_contrast, u, aspect, ground_ao );
}

</pre></code>

    <br><br><br>
<h2><a href="../../index.html">zur端ck</a></h2>
  </body>
</html>
